
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Settings
 * 
 */
export type Settings = $Result.DefaultSelection<Prisma.$SettingsPayload>
/**
 * Model UserTelegramData
 * 
 */
export type UserTelegramData = $Result.DefaultSelection<Prisma.$UserTelegramDataPayload>
/**
 * Model Referrals
 * 
 */
export type Referrals = $Result.DefaultSelection<Prisma.$ReferralsPayload>
/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model AdsViews
 * 
 */
export type AdsViews = $Result.DefaultSelection<Prisma.$AdsViewsPayload>
/**
 * Model AdsNetworks
 * 
 */
export type AdsNetworks = $Result.DefaultSelection<Prisma.$AdsNetworksPayload>
/**
 * Model UserBalance
 * 
 */
export type UserBalance = $Result.DefaultSelection<Prisma.$UserBalancePayload>
/**
 * Model Subscriptions
 * 
 */
export type Subscriptions = $Result.DefaultSelection<Prisma.$SubscriptionsPayload>
/**
 * Model Roles
 * 
 */
export type Roles = $Result.DefaultSelection<Prisma.$RolesPayload>
/**
 * Model Language
 * 
 */
export type Language = $Result.DefaultSelection<Prisma.$LanguagePayload>
/**
 * Model Currency
 * 
 */
export type Currency = $Result.DefaultSelection<Prisma.$CurrencyPayload>
/**
 * Model Transactions
 * 
 */
export type Transactions = $Result.DefaultSelection<Prisma.$TransactionsPayload>
/**
 * Model Withdrawals
 * 
 */
export type Withdrawals = $Result.DefaultSelection<Prisma.$WithdrawalsPayload>
/**
 * Model Payments
 * 
 */
export type Payments = $Result.DefaultSelection<Prisma.$PaymentsPayload>
/**
 * Model PaymentMethods
 * 
 */
export type PaymentMethods = $Result.DefaultSelection<Prisma.$PaymentMethodsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const DefaultEnum: {
  DEFAULT: 'DEFAULT'
};

export type DefaultEnum = (typeof DefaultEnum)[keyof typeof DefaultEnum]


export const AdsNetworkEnum: {
  YANDEX: 'YANDEX',
  ADSGRAM: 'ADSGRAM',
  ONCLICKA: 'ONCLICKA',
  ADSONAR: 'ADSONAR',
  GIGA: 'GIGA',
  MONETAG: 'MONETAG'
};

export type AdsNetworkEnum = (typeof AdsNetworkEnum)[keyof typeof AdsNetworkEnum]


export const AdsViewTypeEnum: {
  REWARD: 'REWARD',
  TASK: 'TASK',
  VIEW: 'VIEW'
};

export type AdsViewTypeEnum = (typeof AdsViewTypeEnum)[keyof typeof AdsViewTypeEnum]


export const SubscriptionPeriodEnum: {
  TRIAL: 'TRIAL',
  HOUR: 'HOUR',
  DAY: 'DAY',
  MONTH: 'MONTH',
  THREE_MONTH: 'THREE_MONTH',
  SIX_MONTH: 'SIX_MONTH',
  YEAR: 'YEAR',
  TWO_YEAR: 'TWO_YEAR',
  THREE_YEAR: 'THREE_YEAR'
};

export type SubscriptionPeriodEnum = (typeof SubscriptionPeriodEnum)[keyof typeof SubscriptionPeriodEnum]


export const UserRoleEnum: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  FRIEND: 'FRIEND',
  OLD_USER: 'OLD_USER',
  USER: 'USER'
};

export type UserRoleEnum = (typeof UserRoleEnum)[keyof typeof UserRoleEnum]


export const CurrencyEnum: {
  RUB: 'RUB',
  USD: 'USD',
  EUR: 'EUR',
  KZT: 'KZT',
  TON: 'TON',
  MAJOR: 'MAJOR',
  NOT: 'NOT',
  HMSTR: 'HMSTR',
  DOGS: 'DOGS',
  CATI: 'CATI',
  USDT: 'USDT',
  XCH: 'XCH',
  JETTON: 'JETTON',
  PX: 'PX',
  GRAM: 'GRAM',
  CATS: 'CATS'
};

export type CurrencyEnum = (typeof CurrencyEnum)[keyof typeof CurrencyEnum]


export const TransactionTypeEnum: {
  PLUS: 'PLUS',
  MINUS: 'MINUS'
};

export type TransactionTypeEnum = (typeof TransactionTypeEnum)[keyof typeof TransactionTypeEnum]


export const BalanceTypeEnum: {
  PAYMENT: 'PAYMENT',
  WITHDRAWAL: 'WITHDRAWAL'
};

export type BalanceTypeEnum = (typeof BalanceTypeEnum)[keyof typeof BalanceTypeEnum]


export const TransactionReasonEnum: {
  WITHDRAWAL: 'WITHDRAWAL',
  PAYMENT: 'PAYMENT',
  REWARD: 'REWARD',
  REFERRAL: 'REFERRAL'
};

export type TransactionReasonEnum = (typeof TransactionReasonEnum)[keyof typeof TransactionReasonEnum]


export const WithdrawalStatusEnum: {
  CONSIDERATION: 'CONSIDERATION',
  REJECTED: 'REJECTED',
  SENT: 'SENT',
  EXPIRED: 'EXPIRED'
};

export type WithdrawalStatusEnum = (typeof WithdrawalStatusEnum)[keyof typeof WithdrawalStatusEnum]


export const PaymentStatusEnum: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  CANCELED: 'CANCELED',
  FAILED: 'FAILED'
};

export type PaymentStatusEnum = (typeof PaymentStatusEnum)[keyof typeof PaymentStatusEnum]


export const PaymentSystemEnum: {
  PAYEER: 'PAYEER',
  VOLET: 'VOLET',
  WATA: 'WATA',
  TOME: 'TOME',
  TELEGRAM: 'TELEGRAM',
  CRYPTOMUS: 'CRYPTOMUS',
  CRYPTOBOT: 'CRYPTOBOT',
  TON_BLOCKCHAIN: 'TON_BLOCKCHAIN',
  PAYPALYCH: 'PAYPALYCH',
  SKINSBACK: 'SKINSBACK'
};

export type PaymentSystemEnum = (typeof PaymentSystemEnum)[keyof typeof PaymentSystemEnum]


export const PaymentMethodTypeEnum: {
  CRYPTOCURRENCY: 'CRYPTOCURRENCY',
  CARD: 'CARD',
  SBP: 'SBP',
  STARS: 'STARS',
  WALLET: 'WALLET',
  SKINS: 'SKINS'
};

export type PaymentMethodTypeEnum = (typeof PaymentMethodTypeEnum)[keyof typeof PaymentMethodTypeEnum]


export const PaymentMethodEnum: {
  STARS: 'STARS',
  TOME_CARD: 'TOME_CARD',
  TOME_SBP: 'TOME_SBP',
  PAYPALYCH_RUB: 'PAYPALYCH_RUB',
  PAYPALYCH_SBP: 'PAYPALYCH_SBP',
  PAYPALYCH_USD: 'PAYPALYCH_USD',
  PAYPALYCH_EUR: 'PAYPALYCH_EUR',
  WATA_RUB: 'WATA_RUB',
  WATA_USD: 'WATA_USD',
  WATA_EUR: 'WATA_EUR',
  PAYEER_RUB: 'PAYEER_RUB',
  PAYEER_USD: 'PAYEER_USD',
  PAYEER_EUR: 'PAYEER_EUR',
  VOLET_RUB: 'VOLET_RUB',
  VOLET_USD: 'VOLET_USD',
  VOLET_EUR: 'VOLET_EUR',
  CRYPTOMUS: 'CRYPTOMUS',
  CRYPTOBOT: 'CRYPTOBOT',
  XROCKET: 'XROCKET',
  TON_TON: 'TON_TON',
  USDT_TON: 'USDT_TON',
  NOT_TON: 'NOT_TON',
  MAJOR_TON: 'MAJOR_TON',
  HMSTR_TON: 'HMSTR_TON',
  DOGS_TON: 'DOGS_TON',
  CATI_TON: 'CATI_TON',
  JETTON_TON: 'JETTON_TON',
  PX_TON: 'PX_TON',
  GRAM_TON: 'GRAM_TON',
  CATS_TON: 'CATS_TON',
  SKINSBACK: 'SKINSBACK'
};

export type PaymentMethodEnum = (typeof PaymentMethodEnum)[keyof typeof PaymentMethodEnum]

}

export type DefaultEnum = $Enums.DefaultEnum

export const DefaultEnum: typeof $Enums.DefaultEnum

export type AdsNetworkEnum = $Enums.AdsNetworkEnum

export const AdsNetworkEnum: typeof $Enums.AdsNetworkEnum

export type AdsViewTypeEnum = $Enums.AdsViewTypeEnum

export const AdsViewTypeEnum: typeof $Enums.AdsViewTypeEnum

export type SubscriptionPeriodEnum = $Enums.SubscriptionPeriodEnum

export const SubscriptionPeriodEnum: typeof $Enums.SubscriptionPeriodEnum

export type UserRoleEnum = $Enums.UserRoleEnum

export const UserRoleEnum: typeof $Enums.UserRoleEnum

export type CurrencyEnum = $Enums.CurrencyEnum

export const CurrencyEnum: typeof $Enums.CurrencyEnum

export type TransactionTypeEnum = $Enums.TransactionTypeEnum

export const TransactionTypeEnum: typeof $Enums.TransactionTypeEnum

export type BalanceTypeEnum = $Enums.BalanceTypeEnum

export const BalanceTypeEnum: typeof $Enums.BalanceTypeEnum

export type TransactionReasonEnum = $Enums.TransactionReasonEnum

export const TransactionReasonEnum: typeof $Enums.TransactionReasonEnum

export type WithdrawalStatusEnum = $Enums.WithdrawalStatusEnum

export const WithdrawalStatusEnum: typeof $Enums.WithdrawalStatusEnum

export type PaymentStatusEnum = $Enums.PaymentStatusEnum

export const PaymentStatusEnum: typeof $Enums.PaymentStatusEnum

export type PaymentSystemEnum = $Enums.PaymentSystemEnum

export const PaymentSystemEnum: typeof $Enums.PaymentSystemEnum

export type PaymentMethodTypeEnum = $Enums.PaymentMethodTypeEnum

export const PaymentMethodTypeEnum: typeof $Enums.PaymentMethodTypeEnum

export type PaymentMethodEnum = $Enums.PaymentMethodEnum

export const PaymentMethodEnum: typeof $Enums.PaymentMethodEnum

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Settings
 * const settings = await prisma.settings.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Settings
   * const settings = await prisma.settings.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.settings`: Exposes CRUD operations for the **Settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.SettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userTelegramData`: Exposes CRUD operations for the **UserTelegramData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTelegramData
    * const userTelegramData = await prisma.userTelegramData.findMany()
    * ```
    */
  get userTelegramData(): Prisma.UserTelegramDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referrals`: Exposes CRUD operations for the **Referrals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referrals
    * const referrals = await prisma.referrals.findMany()
    * ```
    */
  get referrals(): Prisma.ReferralsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adsViews`: Exposes CRUD operations for the **AdsViews** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdsViews
    * const adsViews = await prisma.adsViews.findMany()
    * ```
    */
  get adsViews(): Prisma.AdsViewsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adsNetworks`: Exposes CRUD operations for the **AdsNetworks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdsNetworks
    * const adsNetworks = await prisma.adsNetworks.findMany()
    * ```
    */
  get adsNetworks(): Prisma.AdsNetworksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userBalance`: Exposes CRUD operations for the **UserBalance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBalances
    * const userBalances = await prisma.userBalance.findMany()
    * ```
    */
  get userBalance(): Prisma.UserBalanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptions`: Exposes CRUD operations for the **Subscriptions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscriptions.findMany()
    * ```
    */
  get subscriptions(): Prisma.SubscriptionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **Roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.RolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.language`: Exposes CRUD operations for the **Language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.language.findMany()
    * ```
    */
  get language(): Prisma.LanguageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.currency`: Exposes CRUD operations for the **Currency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Currencies
    * const currencies = await prisma.currency.findMany()
    * ```
    */
  get currency(): Prisma.CurrencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactions`: Exposes CRUD operations for the **Transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transactions.findMany()
    * ```
    */
  get transactions(): Prisma.TransactionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.withdrawals`: Exposes CRUD operations for the **Withdrawals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Withdrawals
    * const withdrawals = await prisma.withdrawals.findMany()
    * ```
    */
  get withdrawals(): Prisma.WithdrawalsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **Payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.PaymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentMethods`: Exposes CRUD operations for the **PaymentMethods** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMethods
    * const paymentMethods = await prisma.paymentMethods.findMany()
    * ```
    */
  get paymentMethods(): Prisma.PaymentMethodsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.5.0
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Settings: 'Settings',
    UserTelegramData: 'UserTelegramData',
    Referrals: 'Referrals',
    Users: 'Users',
    AdsViews: 'AdsViews',
    AdsNetworks: 'AdsNetworks',
    UserBalance: 'UserBalance',
    Subscriptions: 'Subscriptions',
    Roles: 'Roles',
    Language: 'Language',
    Currency: 'Currency',
    Transactions: 'Transactions',
    Withdrawals: 'Withdrawals',
    Payments: 'Payments',
    PaymentMethods: 'PaymentMethods'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "settings" | "userTelegramData" | "referrals" | "users" | "adsViews" | "adsNetworks" | "userBalance" | "subscriptions" | "roles" | "language" | "currency" | "transactions" | "withdrawals" | "payments" | "paymentMethods"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Settings: {
        payload: Prisma.$SettingsPayload<ExtArgs>
        fields: Prisma.SettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findFirst: {
            args: Prisma.SettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findMany: {
            args: Prisma.SettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          create: {
            args: Prisma.SettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          createMany: {
            args: Prisma.SettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          delete: {
            args: Prisma.SettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          update: {
            args: Prisma.SettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          deleteMany: {
            args: Prisma.SettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          upsert: {
            args: Prisma.SettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.SettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      UserTelegramData: {
        payload: Prisma.$UserTelegramDataPayload<ExtArgs>
        fields: Prisma.UserTelegramDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTelegramDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTelegramDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTelegramDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTelegramDataPayload>
          }
          findFirst: {
            args: Prisma.UserTelegramDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTelegramDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTelegramDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTelegramDataPayload>
          }
          findMany: {
            args: Prisma.UserTelegramDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTelegramDataPayload>[]
          }
          create: {
            args: Prisma.UserTelegramDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTelegramDataPayload>
          }
          createMany: {
            args: Prisma.UserTelegramDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserTelegramDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTelegramDataPayload>[]
          }
          delete: {
            args: Prisma.UserTelegramDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTelegramDataPayload>
          }
          update: {
            args: Prisma.UserTelegramDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTelegramDataPayload>
          }
          deleteMany: {
            args: Prisma.UserTelegramDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTelegramDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserTelegramDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTelegramDataPayload>[]
          }
          upsert: {
            args: Prisma.UserTelegramDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTelegramDataPayload>
          }
          aggregate: {
            args: Prisma.UserTelegramDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTelegramData>
          }
          groupBy: {
            args: Prisma.UserTelegramDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTelegramDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserTelegramDataCountArgs<ExtArgs>
            result: $Utils.Optional<UserTelegramDataCountAggregateOutputType> | number
          }
        }
      }
      Referrals: {
        payload: Prisma.$ReferralsPayload<ExtArgs>
        fields: Prisma.ReferralsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralsPayload>
          }
          findFirst: {
            args: Prisma.ReferralsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralsPayload>
          }
          findMany: {
            args: Prisma.ReferralsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralsPayload>[]
          }
          create: {
            args: Prisma.ReferralsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralsPayload>
          }
          createMany: {
            args: Prisma.ReferralsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralsPayload>[]
          }
          delete: {
            args: Prisma.ReferralsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralsPayload>
          }
          update: {
            args: Prisma.ReferralsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralsPayload>
          }
          deleteMany: {
            args: Prisma.ReferralsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReferralsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralsPayload>[]
          }
          upsert: {
            args: Prisma.ReferralsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralsPayload>
          }
          aggregate: {
            args: Prisma.ReferralsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferrals>
          }
          groupBy: {
            args: Prisma.ReferralsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralsCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralsCountAggregateOutputType> | number
          }
        }
      }
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      AdsViews: {
        payload: Prisma.$AdsViewsPayload<ExtArgs>
        fields: Prisma.AdsViewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdsViewsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsViewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdsViewsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsViewsPayload>
          }
          findFirst: {
            args: Prisma.AdsViewsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsViewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdsViewsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsViewsPayload>
          }
          findMany: {
            args: Prisma.AdsViewsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsViewsPayload>[]
          }
          create: {
            args: Prisma.AdsViewsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsViewsPayload>
          }
          createMany: {
            args: Prisma.AdsViewsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdsViewsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsViewsPayload>[]
          }
          delete: {
            args: Prisma.AdsViewsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsViewsPayload>
          }
          update: {
            args: Prisma.AdsViewsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsViewsPayload>
          }
          deleteMany: {
            args: Prisma.AdsViewsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdsViewsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdsViewsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsViewsPayload>[]
          }
          upsert: {
            args: Prisma.AdsViewsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsViewsPayload>
          }
          aggregate: {
            args: Prisma.AdsViewsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdsViews>
          }
          groupBy: {
            args: Prisma.AdsViewsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdsViewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdsViewsCountArgs<ExtArgs>
            result: $Utils.Optional<AdsViewsCountAggregateOutputType> | number
          }
        }
      }
      AdsNetworks: {
        payload: Prisma.$AdsNetworksPayload<ExtArgs>
        fields: Prisma.AdsNetworksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdsNetworksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsNetworksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdsNetworksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsNetworksPayload>
          }
          findFirst: {
            args: Prisma.AdsNetworksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsNetworksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdsNetworksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsNetworksPayload>
          }
          findMany: {
            args: Prisma.AdsNetworksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsNetworksPayload>[]
          }
          create: {
            args: Prisma.AdsNetworksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsNetworksPayload>
          }
          createMany: {
            args: Prisma.AdsNetworksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdsNetworksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsNetworksPayload>[]
          }
          delete: {
            args: Prisma.AdsNetworksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsNetworksPayload>
          }
          update: {
            args: Prisma.AdsNetworksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsNetworksPayload>
          }
          deleteMany: {
            args: Prisma.AdsNetworksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdsNetworksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdsNetworksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsNetworksPayload>[]
          }
          upsert: {
            args: Prisma.AdsNetworksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsNetworksPayload>
          }
          aggregate: {
            args: Prisma.AdsNetworksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdsNetworks>
          }
          groupBy: {
            args: Prisma.AdsNetworksGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdsNetworksGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdsNetworksCountArgs<ExtArgs>
            result: $Utils.Optional<AdsNetworksCountAggregateOutputType> | number
          }
        }
      }
      UserBalance: {
        payload: Prisma.$UserBalancePayload<ExtArgs>
        fields: Prisma.UserBalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBalanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBalanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBalancePayload>
          }
          findFirst: {
            args: Prisma.UserBalanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBalanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBalancePayload>
          }
          findMany: {
            args: Prisma.UserBalanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBalancePayload>[]
          }
          create: {
            args: Prisma.UserBalanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBalancePayload>
          }
          createMany: {
            args: Prisma.UserBalanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserBalanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBalancePayload>[]
          }
          delete: {
            args: Prisma.UserBalanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBalancePayload>
          }
          update: {
            args: Prisma.UserBalanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBalancePayload>
          }
          deleteMany: {
            args: Prisma.UserBalanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBalanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserBalanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBalancePayload>[]
          }
          upsert: {
            args: Prisma.UserBalanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBalancePayload>
          }
          aggregate: {
            args: Prisma.UserBalanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBalance>
          }
          groupBy: {
            args: Prisma.UserBalanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBalanceCountArgs<ExtArgs>
            result: $Utils.Optional<UserBalanceCountAggregateOutputType> | number
          }
        }
      }
      Subscriptions: {
        payload: Prisma.$SubscriptionsPayload<ExtArgs>
        fields: Prisma.SubscriptionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          findMany: {
            args: Prisma.SubscriptionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>[]
          }
          create: {
            args: Prisma.SubscriptionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          createMany: {
            args: Prisma.SubscriptionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          update: {
            args: Prisma.SubscriptionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptions>
          }
          groupBy: {
            args: Prisma.SubscriptionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionsCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionsCountAggregateOutputType> | number
          }
        }
      }
      Roles: {
        payload: Prisma.$RolesPayload<ExtArgs>
        fields: Prisma.RolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          findFirst: {
            args: Prisma.RolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          findMany: {
            args: Prisma.RolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>[]
          }
          create: {
            args: Prisma.RolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          createMany: {
            args: Prisma.RolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>[]
          }
          delete: {
            args: Prisma.RolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          update: {
            args: Prisma.RolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          deleteMany: {
            args: Prisma.RolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>[]
          }
          upsert: {
            args: Prisma.RolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.RolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      Language: {
        payload: Prisma.$LanguagePayload<ExtArgs>
        fields: Prisma.LanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findFirst: {
            args: Prisma.LanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findMany: {
            args: Prisma.LanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          create: {
            args: Prisma.LanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          createMany: {
            args: Prisma.LanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LanguageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          delete: {
            args: Prisma.LanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          update: {
            args: Prisma.LanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          deleteMany: {
            args: Prisma.LanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LanguageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          upsert: {
            args: Prisma.LanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          aggregate: {
            args: Prisma.LanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguage>
          }
          groupBy: {
            args: Prisma.LanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguageCountArgs<ExtArgs>
            result: $Utils.Optional<LanguageCountAggregateOutputType> | number
          }
        }
      }
      Currency: {
        payload: Prisma.$CurrencyPayload<ExtArgs>
        fields: Prisma.CurrencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CurrencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CurrencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findFirst: {
            args: Prisma.CurrencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CurrencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findMany: {
            args: Prisma.CurrencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          create: {
            args: Prisma.CurrencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          createMany: {
            args: Prisma.CurrencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CurrencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          delete: {
            args: Prisma.CurrencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          update: {
            args: Prisma.CurrencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          deleteMany: {
            args: Prisma.CurrencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CurrencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CurrencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          upsert: {
            args: Prisma.CurrencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          aggregate: {
            args: Prisma.CurrencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurrency>
          }
          groupBy: {
            args: Prisma.CurrencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CurrencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CurrencyCountArgs<ExtArgs>
            result: $Utils.Optional<CurrencyCountAggregateOutputType> | number
          }
        }
      }
      Transactions: {
        payload: Prisma.$TransactionsPayload<ExtArgs>
        fields: Prisma.TransactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          findFirst: {
            args: Prisma.TransactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          findMany: {
            args: Prisma.TransactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>[]
          }
          create: {
            args: Prisma.TransactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          createMany: {
            args: Prisma.TransactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>[]
          }
          delete: {
            args: Prisma.TransactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          update: {
            args: Prisma.TransactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          deleteMany: {
            args: Prisma.TransactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>[]
          }
          upsert: {
            args: Prisma.TransactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          aggregate: {
            args: Prisma.TransactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactions>
          }
          groupBy: {
            args: Prisma.TransactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionsCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionsCountAggregateOutputType> | number
          }
        }
      }
      Withdrawals: {
        payload: Prisma.$WithdrawalsPayload<ExtArgs>
        fields: Prisma.WithdrawalsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WithdrawalsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WithdrawalsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalsPayload>
          }
          findFirst: {
            args: Prisma.WithdrawalsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WithdrawalsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalsPayload>
          }
          findMany: {
            args: Prisma.WithdrawalsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalsPayload>[]
          }
          create: {
            args: Prisma.WithdrawalsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalsPayload>
          }
          createMany: {
            args: Prisma.WithdrawalsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WithdrawalsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalsPayload>[]
          }
          delete: {
            args: Prisma.WithdrawalsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalsPayload>
          }
          update: {
            args: Prisma.WithdrawalsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalsPayload>
          }
          deleteMany: {
            args: Prisma.WithdrawalsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WithdrawalsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WithdrawalsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalsPayload>[]
          }
          upsert: {
            args: Prisma.WithdrawalsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalsPayload>
          }
          aggregate: {
            args: Prisma.WithdrawalsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWithdrawals>
          }
          groupBy: {
            args: Prisma.WithdrawalsGroupByArgs<ExtArgs>
            result: $Utils.Optional<WithdrawalsGroupByOutputType>[]
          }
          count: {
            args: Prisma.WithdrawalsCountArgs<ExtArgs>
            result: $Utils.Optional<WithdrawalsCountAggregateOutputType> | number
          }
        }
      }
      Payments: {
        payload: Prisma.$PaymentsPayload<ExtArgs>
        fields: Prisma.PaymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          findFirst: {
            args: Prisma.PaymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          findMany: {
            args: Prisma.PaymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>[]
          }
          create: {
            args: Prisma.PaymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          createMany: {
            args: Prisma.PaymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>[]
          }
          delete: {
            args: Prisma.PaymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          update: {
            args: Prisma.PaymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          deleteMany: {
            args: Prisma.PaymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>[]
          }
          upsert: {
            args: Prisma.PaymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.PaymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
      PaymentMethods: {
        payload: Prisma.$PaymentMethodsPayload<ExtArgs>
        fields: Prisma.PaymentMethodsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMethodsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMethodsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodsPayload>
          }
          findFirst: {
            args: Prisma.PaymentMethodsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMethodsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodsPayload>
          }
          findMany: {
            args: Prisma.PaymentMethodsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodsPayload>[]
          }
          create: {
            args: Prisma.PaymentMethodsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodsPayload>
          }
          createMany: {
            args: Prisma.PaymentMethodsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentMethodsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodsPayload>[]
          }
          delete: {
            args: Prisma.PaymentMethodsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodsPayload>
          }
          update: {
            args: Prisma.PaymentMethodsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodsPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMethodsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMethodsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentMethodsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodsPayload>[]
          }
          upsert: {
            args: Prisma.PaymentMethodsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodsPayload>
          }
          aggregate: {
            args: Prisma.PaymentMethodsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMethods>
          }
          groupBy: {
            args: Prisma.PaymentMethodsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentMethodsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    settings?: SettingsOmit
    userTelegramData?: UserTelegramDataOmit
    referrals?: ReferralsOmit
    users?: UsersOmit
    adsViews?: AdsViewsOmit
    adsNetworks?: AdsNetworksOmit
    userBalance?: UserBalanceOmit
    subscriptions?: SubscriptionsOmit
    roles?: RolesOmit
    language?: LanguageOmit
    currency?: CurrencyOmit
    transactions?: TransactionsOmit
    withdrawals?: WithdrawalsOmit
    payments?: PaymentsOmit
    paymentMethods?: PaymentMethodsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    payments: number
    referrals: number
    inviters: number
    subscriptions: number
    withdrawals: number
    adsViews: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | UsersCountOutputTypeCountPaymentsArgs
    referrals?: boolean | UsersCountOutputTypeCountReferralsArgs
    inviters?: boolean | UsersCountOutputTypeCountInvitersArgs
    subscriptions?: boolean | UsersCountOutputTypeCountSubscriptionsArgs
    withdrawals?: boolean | UsersCountOutputTypeCountWithdrawalsArgs
    adsViews?: boolean | UsersCountOutputTypeCountAdsViewsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountInvitersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountWithdrawalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WithdrawalsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAdsViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdsViewsWhereInput
  }


  /**
   * Count Type AdsNetworksCountOutputType
   */

  export type AdsNetworksCountOutputType = {
    adsViews: number
  }

  export type AdsNetworksCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adsViews?: boolean | AdsNetworksCountOutputTypeCountAdsViewsArgs
  }

  // Custom InputTypes
  /**
   * AdsNetworksCountOutputType without action
   */
  export type AdsNetworksCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsNetworksCountOutputType
     */
    select?: AdsNetworksCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdsNetworksCountOutputType without action
   */
  export type AdsNetworksCountOutputTypeCountAdsViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdsViewsWhereInput
  }


  /**
   * Count Type UserBalanceCountOutputType
   */

  export type UserBalanceCountOutputType = {
    transactions: number
  }

  export type UserBalanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | UserBalanceCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * UserBalanceCountOutputType without action
   */
  export type UserBalanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBalanceCountOutputType
     */
    select?: UserBalanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserBalanceCountOutputType without action
   */
  export type UserBalanceCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsWhereInput
  }


  /**
   * Count Type SubscriptionsCountOutputType
   */

  export type SubscriptionsCountOutputType = {
    payments: number
  }

  export type SubscriptionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | SubscriptionsCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionsCountOutputType without action
   */
  export type SubscriptionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionsCountOutputType
     */
    select?: SubscriptionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionsCountOutputType without action
   */
  export type SubscriptionsCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsWhereInput
  }


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    users: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RolesCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
  }


  /**
   * Count Type LanguageCountOutputType
   */

  export type LanguageCountOutputType = {
    users: number
  }

  export type LanguageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | LanguageCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageCountOutputType
     */
    select?: LanguageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
  }


  /**
   * Count Type CurrencyCountOutputType
   */

  export type CurrencyCountOutputType = {
    payments: number
    paymentMethods: number
  }

  export type CurrencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | CurrencyCountOutputTypeCountPaymentsArgs
    paymentMethods?: boolean | CurrencyCountOutputTypeCountPaymentMethodsArgs
  }

  // Custom InputTypes
  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyCountOutputType
     */
    select?: CurrencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsWhereInput
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountPaymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodsWhereInput
  }


  /**
   * Count Type PaymentMethodsCountOutputType
   */

  export type PaymentMethodsCountOutputType = {
    payments: number
  }

  export type PaymentMethodsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | PaymentMethodsCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * PaymentMethodsCountOutputType without action
   */
  export type PaymentMethodsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodsCountOutputType
     */
    select?: PaymentMethodsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentMethodsCountOutputType without action
   */
  export type PaymentMethodsCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsAvgAggregateOutputType = {
    tgStarsToUSD: number | null
    priceSubscriptionStars: number | null
    comissionStarsToTon: number | null
    adsRewardStars: number | null
    adsTaskRewardStars: number | null
    hourRatioPayment: number | null
    dayRatioPayment: number | null
    threeMouthesRatioPayment: number | null
    sixMouthesRatioPayment: number | null
    oneYearRatioPayment: number | null
    twoYearRatioPayment: number | null
    threeYearRatioPayment: number | null
    referralOneLevelPercent: number | null
    referralTwoLevelPercent: number | null
    referralThreeLevelPercent: number | null
    referralInviteRewardStars: number | null
    referralInvitePremiumRewardStars: number | null
    limitDevices: number | null
    freePlanDays: number | null
    freePlanDaysForReferrals: number | null
  }

  export type SettingsSumAggregateOutputType = {
    tgStarsToUSD: number | null
    priceSubscriptionStars: number | null
    comissionStarsToTon: number | null
    adsRewardStars: number | null
    adsTaskRewardStars: number | null
    hourRatioPayment: number | null
    dayRatioPayment: number | null
    threeMouthesRatioPayment: number | null
    sixMouthesRatioPayment: number | null
    oneYearRatioPayment: number | null
    twoYearRatioPayment: number | null
    threeYearRatioPayment: number | null
    referralOneLevelPercent: number | null
    referralTwoLevelPercent: number | null
    referralThreeLevelPercent: number | null
    referralInviteRewardStars: number | null
    referralInvitePremiumRewardStars: number | null
    limitDevices: number | null
    freePlanDays: number | null
    freePlanDaysForReferrals: number | null
  }

  export type SettingsMinAggregateOutputType = {
    key: $Enums.DefaultEnum | null
    tgStarsToUSD: number | null
    priceSubscriptionStars: number | null
    comissionStarsToTon: number | null
    adsRewardStars: number | null
    adsTaskRewardStars: number | null
    hourRatioPayment: number | null
    dayRatioPayment: number | null
    threeMouthesRatioPayment: number | null
    sixMouthesRatioPayment: number | null
    oneYearRatioPayment: number | null
    twoYearRatioPayment: number | null
    threeYearRatioPayment: number | null
    referralOneLevelPercent: number | null
    referralTwoLevelPercent: number | null
    referralThreeLevelPercent: number | null
    referralInviteRewardStars: number | null
    referralInvitePremiumRewardStars: number | null
    limitDevices: number | null
    freePlanDays: number | null
    freePlanDaysForReferrals: number | null
  }

  export type SettingsMaxAggregateOutputType = {
    key: $Enums.DefaultEnum | null
    tgStarsToUSD: number | null
    priceSubscriptionStars: number | null
    comissionStarsToTon: number | null
    adsRewardStars: number | null
    adsTaskRewardStars: number | null
    hourRatioPayment: number | null
    dayRatioPayment: number | null
    threeMouthesRatioPayment: number | null
    sixMouthesRatioPayment: number | null
    oneYearRatioPayment: number | null
    twoYearRatioPayment: number | null
    threeYearRatioPayment: number | null
    referralOneLevelPercent: number | null
    referralTwoLevelPercent: number | null
    referralThreeLevelPercent: number | null
    referralInviteRewardStars: number | null
    referralInvitePremiumRewardStars: number | null
    limitDevices: number | null
    freePlanDays: number | null
    freePlanDaysForReferrals: number | null
  }

  export type SettingsCountAggregateOutputType = {
    key: number
    tgStarsToUSD: number
    priceSubscriptionStars: number
    comissionStarsToTon: number
    adsRewardStars: number
    adsTaskRewardStars: number
    hourRatioPayment: number
    dayRatioPayment: number
    threeMouthesRatioPayment: number
    sixMouthesRatioPayment: number
    oneYearRatioPayment: number
    twoYearRatioPayment: number
    threeYearRatioPayment: number
    referralOneLevelPercent: number
    referralTwoLevelPercent: number
    referralThreeLevelPercent: number
    referralInviteRewardStars: number
    referralInvitePremiumRewardStars: number
    limitDevices: number
    freePlanDays: number
    freePlanDaysForReferrals: number
    _all: number
  }


  export type SettingsAvgAggregateInputType = {
    tgStarsToUSD?: true
    priceSubscriptionStars?: true
    comissionStarsToTon?: true
    adsRewardStars?: true
    adsTaskRewardStars?: true
    hourRatioPayment?: true
    dayRatioPayment?: true
    threeMouthesRatioPayment?: true
    sixMouthesRatioPayment?: true
    oneYearRatioPayment?: true
    twoYearRatioPayment?: true
    threeYearRatioPayment?: true
    referralOneLevelPercent?: true
    referralTwoLevelPercent?: true
    referralThreeLevelPercent?: true
    referralInviteRewardStars?: true
    referralInvitePremiumRewardStars?: true
    limitDevices?: true
    freePlanDays?: true
    freePlanDaysForReferrals?: true
  }

  export type SettingsSumAggregateInputType = {
    tgStarsToUSD?: true
    priceSubscriptionStars?: true
    comissionStarsToTon?: true
    adsRewardStars?: true
    adsTaskRewardStars?: true
    hourRatioPayment?: true
    dayRatioPayment?: true
    threeMouthesRatioPayment?: true
    sixMouthesRatioPayment?: true
    oneYearRatioPayment?: true
    twoYearRatioPayment?: true
    threeYearRatioPayment?: true
    referralOneLevelPercent?: true
    referralTwoLevelPercent?: true
    referralThreeLevelPercent?: true
    referralInviteRewardStars?: true
    referralInvitePremiumRewardStars?: true
    limitDevices?: true
    freePlanDays?: true
    freePlanDaysForReferrals?: true
  }

  export type SettingsMinAggregateInputType = {
    key?: true
    tgStarsToUSD?: true
    priceSubscriptionStars?: true
    comissionStarsToTon?: true
    adsRewardStars?: true
    adsTaskRewardStars?: true
    hourRatioPayment?: true
    dayRatioPayment?: true
    threeMouthesRatioPayment?: true
    sixMouthesRatioPayment?: true
    oneYearRatioPayment?: true
    twoYearRatioPayment?: true
    threeYearRatioPayment?: true
    referralOneLevelPercent?: true
    referralTwoLevelPercent?: true
    referralThreeLevelPercent?: true
    referralInviteRewardStars?: true
    referralInvitePremiumRewardStars?: true
    limitDevices?: true
    freePlanDays?: true
    freePlanDaysForReferrals?: true
  }

  export type SettingsMaxAggregateInputType = {
    key?: true
    tgStarsToUSD?: true
    priceSubscriptionStars?: true
    comissionStarsToTon?: true
    adsRewardStars?: true
    adsTaskRewardStars?: true
    hourRatioPayment?: true
    dayRatioPayment?: true
    threeMouthesRatioPayment?: true
    sixMouthesRatioPayment?: true
    oneYearRatioPayment?: true
    twoYearRatioPayment?: true
    threeYearRatioPayment?: true
    referralOneLevelPercent?: true
    referralTwoLevelPercent?: true
    referralThreeLevelPercent?: true
    referralInviteRewardStars?: true
    referralInvitePremiumRewardStars?: true
    limitDevices?: true
    freePlanDays?: true
    freePlanDaysForReferrals?: true
  }

  export type SettingsCountAggregateInputType = {
    key?: true
    tgStarsToUSD?: true
    priceSubscriptionStars?: true
    comissionStarsToTon?: true
    adsRewardStars?: true
    adsTaskRewardStars?: true
    hourRatioPayment?: true
    dayRatioPayment?: true
    threeMouthesRatioPayment?: true
    sixMouthesRatioPayment?: true
    oneYearRatioPayment?: true
    twoYearRatioPayment?: true
    threeYearRatioPayment?: true
    referralOneLevelPercent?: true
    referralTwoLevelPercent?: true
    referralThreeLevelPercent?: true
    referralInviteRewardStars?: true
    referralInvitePremiumRewardStars?: true
    limitDevices?: true
    freePlanDays?: true
    freePlanDaysForReferrals?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to aggregate.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type SettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsWhereInput
    orderBy?: SettingsOrderByWithAggregationInput | SettingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: SettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _avg?: SettingsAvgAggregateInputType
    _sum?: SettingsSumAggregateInputType
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    key: $Enums.DefaultEnum
    tgStarsToUSD: number
    priceSubscriptionStars: number
    comissionStarsToTon: number
    adsRewardStars: number
    adsTaskRewardStars: number
    hourRatioPayment: number
    dayRatioPayment: number
    threeMouthesRatioPayment: number
    sixMouthesRatioPayment: number
    oneYearRatioPayment: number
    twoYearRatioPayment: number
    threeYearRatioPayment: number
    referralOneLevelPercent: number
    referralTwoLevelPercent: number
    referralThreeLevelPercent: number
    referralInviteRewardStars: number
    referralInvitePremiumRewardStars: number
    limitDevices: number
    freePlanDays: number
    freePlanDaysForReferrals: number
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type SettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    tgStarsToUSD?: boolean
    priceSubscriptionStars?: boolean
    comissionStarsToTon?: boolean
    adsRewardStars?: boolean
    adsTaskRewardStars?: boolean
    hourRatioPayment?: boolean
    dayRatioPayment?: boolean
    threeMouthesRatioPayment?: boolean
    sixMouthesRatioPayment?: boolean
    oneYearRatioPayment?: boolean
    twoYearRatioPayment?: boolean
    threeYearRatioPayment?: boolean
    referralOneLevelPercent?: boolean
    referralTwoLevelPercent?: boolean
    referralThreeLevelPercent?: boolean
    referralInviteRewardStars?: boolean
    referralInvitePremiumRewardStars?: boolean
    limitDevices?: boolean
    freePlanDays?: boolean
    freePlanDaysForReferrals?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    tgStarsToUSD?: boolean
    priceSubscriptionStars?: boolean
    comissionStarsToTon?: boolean
    adsRewardStars?: boolean
    adsTaskRewardStars?: boolean
    hourRatioPayment?: boolean
    dayRatioPayment?: boolean
    threeMouthesRatioPayment?: boolean
    sixMouthesRatioPayment?: boolean
    oneYearRatioPayment?: boolean
    twoYearRatioPayment?: boolean
    threeYearRatioPayment?: boolean
    referralOneLevelPercent?: boolean
    referralTwoLevelPercent?: boolean
    referralThreeLevelPercent?: boolean
    referralInviteRewardStars?: boolean
    referralInvitePremiumRewardStars?: boolean
    limitDevices?: boolean
    freePlanDays?: boolean
    freePlanDaysForReferrals?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    tgStarsToUSD?: boolean
    priceSubscriptionStars?: boolean
    comissionStarsToTon?: boolean
    adsRewardStars?: boolean
    adsTaskRewardStars?: boolean
    hourRatioPayment?: boolean
    dayRatioPayment?: boolean
    threeMouthesRatioPayment?: boolean
    sixMouthesRatioPayment?: boolean
    oneYearRatioPayment?: boolean
    twoYearRatioPayment?: boolean
    threeYearRatioPayment?: boolean
    referralOneLevelPercent?: boolean
    referralTwoLevelPercent?: boolean
    referralThreeLevelPercent?: boolean
    referralInviteRewardStars?: boolean
    referralInvitePremiumRewardStars?: boolean
    limitDevices?: boolean
    freePlanDays?: boolean
    freePlanDaysForReferrals?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectScalar = {
    key?: boolean
    tgStarsToUSD?: boolean
    priceSubscriptionStars?: boolean
    comissionStarsToTon?: boolean
    adsRewardStars?: boolean
    adsTaskRewardStars?: boolean
    hourRatioPayment?: boolean
    dayRatioPayment?: boolean
    threeMouthesRatioPayment?: boolean
    sixMouthesRatioPayment?: boolean
    oneYearRatioPayment?: boolean
    twoYearRatioPayment?: boolean
    threeYearRatioPayment?: boolean
    referralOneLevelPercent?: boolean
    referralTwoLevelPercent?: boolean
    referralThreeLevelPercent?: boolean
    referralInviteRewardStars?: boolean
    referralInvitePremiumRewardStars?: boolean
    limitDevices?: boolean
    freePlanDays?: boolean
    freePlanDaysForReferrals?: boolean
  }

  export type SettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "tgStarsToUSD" | "priceSubscriptionStars" | "comissionStarsToTon" | "adsRewardStars" | "adsTaskRewardStars" | "hourRatioPayment" | "dayRatioPayment" | "threeMouthesRatioPayment" | "sixMouthesRatioPayment" | "oneYearRatioPayment" | "twoYearRatioPayment" | "threeYearRatioPayment" | "referralOneLevelPercent" | "referralTwoLevelPercent" | "referralThreeLevelPercent" | "referralInviteRewardStars" | "referralInvitePremiumRewardStars" | "limitDevices" | "freePlanDays" | "freePlanDaysForReferrals", ExtArgs["result"]["settings"]>

  export type $SettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Settings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: $Enums.DefaultEnum
      tgStarsToUSD: number
      priceSubscriptionStars: number
      comissionStarsToTon: number
      adsRewardStars: number
      adsTaskRewardStars: number
      hourRatioPayment: number
      dayRatioPayment: number
      threeMouthesRatioPayment: number
      sixMouthesRatioPayment: number
      oneYearRatioPayment: number
      twoYearRatioPayment: number
      threeYearRatioPayment: number
      referralOneLevelPercent: number
      referralTwoLevelPercent: number
      referralThreeLevelPercent: number
      referralInviteRewardStars: number
      referralInvitePremiumRewardStars: number
      limitDevices: number
      freePlanDays: number
      freePlanDaysForReferrals: number
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type SettingsGetPayload<S extends boolean | null | undefined | SettingsDefaultArgs> = $Result.GetResult<Prisma.$SettingsPayload, S>

  type SettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface SettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Settings'], meta: { name: 'Settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {SettingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingsFindUniqueArgs>(args: SelectSubset<T, SettingsFindUniqueArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingsFindFirstArgs>(args?: SelectSubset<T, SettingsFindFirstArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `tgStarsToUSD`
     * const settingsWithTgStarsToUSDOnly = await prisma.settings.findMany({ select: { tgStarsToUSD: true } })
     * 
     */
    findMany<T extends SettingsFindManyArgs>(args?: SelectSubset<T, SettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settings.
     * @param {SettingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends SettingsCreateArgs>(args: SelectSubset<T, SettingsCreateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingsCreateManyArgs>(args?: SelectSubset<T, SettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingsCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `tgStarsToUSD`
     * const settingsWithTgStarsToUSDOnly = await prisma.settings.createManyAndReturn({
     *   select: { tgStarsToUSD: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Settings.
     * @param {SettingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends SettingsDeleteArgs>(args: SelectSubset<T, SettingsDeleteArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settings.
     * @param {SettingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingsUpdateArgs>(args: SelectSubset<T, SettingsUpdateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingsDeleteManyArgs>(args?: SelectSubset<T, SettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingsUpdateManyArgs>(args: SelectSubset<T, SettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingsUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `tgStarsToUSD`
     * const settingsWithTgStarsToUSDOnly = await prisma.settings.updateManyAndReturn({
     *   select: { tgStarsToUSD: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Settings.
     * @param {SettingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends SettingsUpsertArgs>(args: SelectSubset<T, SettingsUpsertArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingsCountArgs>(
      args?: Subset<T, SettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsGroupByArgs['orderBy'] }
        : { orderBy?: SettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Settings model
   */
  readonly fields: SettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Settings model
   */ 
  interface SettingsFieldRefs {
    readonly key: FieldRef<"Settings", 'DefaultEnum'>
    readonly tgStarsToUSD: FieldRef<"Settings", 'Float'>
    readonly priceSubscriptionStars: FieldRef<"Settings", 'Int'>
    readonly comissionStarsToTon: FieldRef<"Settings", 'Float'>
    readonly adsRewardStars: FieldRef<"Settings", 'Float'>
    readonly adsTaskRewardStars: FieldRef<"Settings", 'Float'>
    readonly hourRatioPayment: FieldRef<"Settings", 'Float'>
    readonly dayRatioPayment: FieldRef<"Settings", 'Float'>
    readonly threeMouthesRatioPayment: FieldRef<"Settings", 'Float'>
    readonly sixMouthesRatioPayment: FieldRef<"Settings", 'Float'>
    readonly oneYearRatioPayment: FieldRef<"Settings", 'Float'>
    readonly twoYearRatioPayment: FieldRef<"Settings", 'Float'>
    readonly threeYearRatioPayment: FieldRef<"Settings", 'Float'>
    readonly referralOneLevelPercent: FieldRef<"Settings", 'Float'>
    readonly referralTwoLevelPercent: FieldRef<"Settings", 'Float'>
    readonly referralThreeLevelPercent: FieldRef<"Settings", 'Float'>
    readonly referralInviteRewardStars: FieldRef<"Settings", 'Float'>
    readonly referralInvitePremiumRewardStars: FieldRef<"Settings", 'Float'>
    readonly limitDevices: FieldRef<"Settings", 'Int'>
    readonly freePlanDays: FieldRef<"Settings", 'Int'>
    readonly freePlanDaysForReferrals: FieldRef<"Settings", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Settings findUnique
   */
  export type SettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findUniqueOrThrow
   */
  export type SettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findFirst
   */
  export type SettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findFirstOrThrow
   */
  export type SettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findMany
   */
  export type SettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings create
   */
  export type SettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a Settings.
     */
    data?: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
  }

  /**
   * Settings createMany
   */
  export type SettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Settings createManyAndReturn
   */
  export type SettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Settings update
   */
  export type SettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a Settings.
     */
    data: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
    /**
     * Choose, which Settings to update.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings updateMany
   */
  export type SettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings updateManyAndReturn
   */
  export type SettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings upsert
   */
  export type SettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the Settings to update in case it exists.
     */
    where: SettingsWhereUniqueInput
    /**
     * In case the Settings found by the `where` argument doesn't exist, create a new Settings with this data.
     */
    create: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
    /**
     * In case the Settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
  }

  /**
   * Settings delete
   */
  export type SettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter which Settings to delete.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings deleteMany
   */
  export type SettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Settings without action
   */
  export type SettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
  }


  /**
   * Model UserTelegramData
   */

  export type AggregateUserTelegramData = {
    _count: UserTelegramDataCountAggregateOutputType | null
    _min: UserTelegramDataMinAggregateOutputType | null
    _max: UserTelegramDataMaxAggregateOutputType | null
  }

  export type UserTelegramDataMinAggregateOutputType = {
    id: string | null
    isLive: boolean | null
    isRtl: boolean | null
    isPremium: boolean | null
    isBot: boolean | null
    firstName: string | null
    lastName: string | null
    username: string | null
    languageCode: string | null
    photoUrl: string | null
    addedToAttachmentMenu: boolean | null
    allowsWriteToPm: boolean | null
    updatedAt: Date | null
  }

  export type UserTelegramDataMaxAggregateOutputType = {
    id: string | null
    isLive: boolean | null
    isRtl: boolean | null
    isPremium: boolean | null
    isBot: boolean | null
    firstName: string | null
    lastName: string | null
    username: string | null
    languageCode: string | null
    photoUrl: string | null
    addedToAttachmentMenu: boolean | null
    allowsWriteToPm: boolean | null
    updatedAt: Date | null
  }

  export type UserTelegramDataCountAggregateOutputType = {
    id: number
    isLive: number
    isRtl: number
    isPremium: number
    isBot: number
    firstName: number
    lastName: number
    username: number
    languageCode: number
    photoUrl: number
    addedToAttachmentMenu: number
    allowsWriteToPm: number
    updatedAt: number
    _all: number
  }


  export type UserTelegramDataMinAggregateInputType = {
    id?: true
    isLive?: true
    isRtl?: true
    isPremium?: true
    isBot?: true
    firstName?: true
    lastName?: true
    username?: true
    languageCode?: true
    photoUrl?: true
    addedToAttachmentMenu?: true
    allowsWriteToPm?: true
    updatedAt?: true
  }

  export type UserTelegramDataMaxAggregateInputType = {
    id?: true
    isLive?: true
    isRtl?: true
    isPremium?: true
    isBot?: true
    firstName?: true
    lastName?: true
    username?: true
    languageCode?: true
    photoUrl?: true
    addedToAttachmentMenu?: true
    allowsWriteToPm?: true
    updatedAt?: true
  }

  export type UserTelegramDataCountAggregateInputType = {
    id?: true
    isLive?: true
    isRtl?: true
    isPremium?: true
    isBot?: true
    firstName?: true
    lastName?: true
    username?: true
    languageCode?: true
    photoUrl?: true
    addedToAttachmentMenu?: true
    allowsWriteToPm?: true
    updatedAt?: true
    _all?: true
  }

  export type UserTelegramDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTelegramData to aggregate.
     */
    where?: UserTelegramDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTelegramData to fetch.
     */
    orderBy?: UserTelegramDataOrderByWithRelationInput | UserTelegramDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTelegramDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTelegramData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTelegramData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTelegramData
    **/
    _count?: true | UserTelegramDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTelegramDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTelegramDataMaxAggregateInputType
  }

  export type GetUserTelegramDataAggregateType<T extends UserTelegramDataAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTelegramData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTelegramData[P]>
      : GetScalarType<T[P], AggregateUserTelegramData[P]>
  }




  export type UserTelegramDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTelegramDataWhereInput
    orderBy?: UserTelegramDataOrderByWithAggregationInput | UserTelegramDataOrderByWithAggregationInput[]
    by: UserTelegramDataScalarFieldEnum[] | UserTelegramDataScalarFieldEnum
    having?: UserTelegramDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTelegramDataCountAggregateInputType | true
    _min?: UserTelegramDataMinAggregateInputType
    _max?: UserTelegramDataMaxAggregateInputType
  }

  export type UserTelegramDataGroupByOutputType = {
    id: string
    isLive: boolean
    isRtl: boolean
    isPremium: boolean
    isBot: boolean
    firstName: string
    lastName: string | null
    username: string | null
    languageCode: string
    photoUrl: string | null
    addedToAttachmentMenu: boolean
    allowsWriteToPm: boolean
    updatedAt: Date
    _count: UserTelegramDataCountAggregateOutputType | null
    _min: UserTelegramDataMinAggregateOutputType | null
    _max: UserTelegramDataMaxAggregateOutputType | null
  }

  type GetUserTelegramDataGroupByPayload<T extends UserTelegramDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTelegramDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTelegramDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTelegramDataGroupByOutputType[P]>
            : GetScalarType<T[P], UserTelegramDataGroupByOutputType[P]>
        }
      >
    >


  export type UserTelegramDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isLive?: boolean
    isRtl?: boolean
    isPremium?: boolean
    isBot?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    languageCode?: boolean
    photoUrl?: boolean
    addedToAttachmentMenu?: boolean
    allowsWriteToPm?: boolean
    updatedAt?: boolean
    user?: boolean | UserTelegramData$userArgs<ExtArgs>
  }, ExtArgs["result"]["userTelegramData"]>

  export type UserTelegramDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isLive?: boolean
    isRtl?: boolean
    isPremium?: boolean
    isBot?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    languageCode?: boolean
    photoUrl?: boolean
    addedToAttachmentMenu?: boolean
    allowsWriteToPm?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userTelegramData"]>

  export type UserTelegramDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isLive?: boolean
    isRtl?: boolean
    isPremium?: boolean
    isBot?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    languageCode?: boolean
    photoUrl?: boolean
    addedToAttachmentMenu?: boolean
    allowsWriteToPm?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userTelegramData"]>

  export type UserTelegramDataSelectScalar = {
    id?: boolean
    isLive?: boolean
    isRtl?: boolean
    isPremium?: boolean
    isBot?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    languageCode?: boolean
    photoUrl?: boolean
    addedToAttachmentMenu?: boolean
    allowsWriteToPm?: boolean
    updatedAt?: boolean
  }

  export type UserTelegramDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isLive" | "isRtl" | "isPremium" | "isBot" | "firstName" | "lastName" | "username" | "languageCode" | "photoUrl" | "addedToAttachmentMenu" | "allowsWriteToPm" | "updatedAt", ExtArgs["result"]["userTelegramData"]>
  export type UserTelegramDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserTelegramData$userArgs<ExtArgs>
  }
  export type UserTelegramDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserTelegramDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserTelegramDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTelegramData"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isLive: boolean
      isRtl: boolean
      isPremium: boolean
      isBot: boolean
      firstName: string
      lastName: string | null
      username: string | null
      languageCode: string
      photoUrl: string | null
      addedToAttachmentMenu: boolean
      allowsWriteToPm: boolean
      updatedAt: Date
    }, ExtArgs["result"]["userTelegramData"]>
    composites: {}
  }

  type UserTelegramDataGetPayload<S extends boolean | null | undefined | UserTelegramDataDefaultArgs> = $Result.GetResult<Prisma.$UserTelegramDataPayload, S>

  type UserTelegramDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserTelegramDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserTelegramDataCountAggregateInputType | true
    }

  export interface UserTelegramDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTelegramData'], meta: { name: 'UserTelegramData' } }
    /**
     * Find zero or one UserTelegramData that matches the filter.
     * @param {UserTelegramDataFindUniqueArgs} args - Arguments to find a UserTelegramData
     * @example
     * // Get one UserTelegramData
     * const userTelegramData = await prisma.userTelegramData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTelegramDataFindUniqueArgs>(args: SelectSubset<T, UserTelegramDataFindUniqueArgs<ExtArgs>>): Prisma__UserTelegramDataClient<$Result.GetResult<Prisma.$UserTelegramDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserTelegramData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserTelegramDataFindUniqueOrThrowArgs} args - Arguments to find a UserTelegramData
     * @example
     * // Get one UserTelegramData
     * const userTelegramData = await prisma.userTelegramData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTelegramDataFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTelegramDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTelegramDataClient<$Result.GetResult<Prisma.$UserTelegramDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTelegramData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTelegramDataFindFirstArgs} args - Arguments to find a UserTelegramData
     * @example
     * // Get one UserTelegramData
     * const userTelegramData = await prisma.userTelegramData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTelegramDataFindFirstArgs>(args?: SelectSubset<T, UserTelegramDataFindFirstArgs<ExtArgs>>): Prisma__UserTelegramDataClient<$Result.GetResult<Prisma.$UserTelegramDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTelegramData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTelegramDataFindFirstOrThrowArgs} args - Arguments to find a UserTelegramData
     * @example
     * // Get one UserTelegramData
     * const userTelegramData = await prisma.userTelegramData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTelegramDataFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTelegramDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTelegramDataClient<$Result.GetResult<Prisma.$UserTelegramDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserTelegramData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTelegramDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTelegramData
     * const userTelegramData = await prisma.userTelegramData.findMany()
     * 
     * // Get first 10 UserTelegramData
     * const userTelegramData = await prisma.userTelegramData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTelegramDataWithIdOnly = await prisma.userTelegramData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserTelegramDataFindManyArgs>(args?: SelectSubset<T, UserTelegramDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTelegramDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserTelegramData.
     * @param {UserTelegramDataCreateArgs} args - Arguments to create a UserTelegramData.
     * @example
     * // Create one UserTelegramData
     * const UserTelegramData = await prisma.userTelegramData.create({
     *   data: {
     *     // ... data to create a UserTelegramData
     *   }
     * })
     * 
     */
    create<T extends UserTelegramDataCreateArgs>(args: SelectSubset<T, UserTelegramDataCreateArgs<ExtArgs>>): Prisma__UserTelegramDataClient<$Result.GetResult<Prisma.$UserTelegramDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserTelegramData.
     * @param {UserTelegramDataCreateManyArgs} args - Arguments to create many UserTelegramData.
     * @example
     * // Create many UserTelegramData
     * const userTelegramData = await prisma.userTelegramData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTelegramDataCreateManyArgs>(args?: SelectSubset<T, UserTelegramDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserTelegramData and returns the data saved in the database.
     * @param {UserTelegramDataCreateManyAndReturnArgs} args - Arguments to create many UserTelegramData.
     * @example
     * // Create many UserTelegramData
     * const userTelegramData = await prisma.userTelegramData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserTelegramData and only return the `id`
     * const userTelegramDataWithIdOnly = await prisma.userTelegramData.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserTelegramDataCreateManyAndReturnArgs>(args?: SelectSubset<T, UserTelegramDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTelegramDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserTelegramData.
     * @param {UserTelegramDataDeleteArgs} args - Arguments to delete one UserTelegramData.
     * @example
     * // Delete one UserTelegramData
     * const UserTelegramData = await prisma.userTelegramData.delete({
     *   where: {
     *     // ... filter to delete one UserTelegramData
     *   }
     * })
     * 
     */
    delete<T extends UserTelegramDataDeleteArgs>(args: SelectSubset<T, UserTelegramDataDeleteArgs<ExtArgs>>): Prisma__UserTelegramDataClient<$Result.GetResult<Prisma.$UserTelegramDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserTelegramData.
     * @param {UserTelegramDataUpdateArgs} args - Arguments to update one UserTelegramData.
     * @example
     * // Update one UserTelegramData
     * const userTelegramData = await prisma.userTelegramData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTelegramDataUpdateArgs>(args: SelectSubset<T, UserTelegramDataUpdateArgs<ExtArgs>>): Prisma__UserTelegramDataClient<$Result.GetResult<Prisma.$UserTelegramDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserTelegramData.
     * @param {UserTelegramDataDeleteManyArgs} args - Arguments to filter UserTelegramData to delete.
     * @example
     * // Delete a few UserTelegramData
     * const { count } = await prisma.userTelegramData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTelegramDataDeleteManyArgs>(args?: SelectSubset<T, UserTelegramDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTelegramData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTelegramDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTelegramData
     * const userTelegramData = await prisma.userTelegramData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTelegramDataUpdateManyArgs>(args: SelectSubset<T, UserTelegramDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTelegramData and returns the data updated in the database.
     * @param {UserTelegramDataUpdateManyAndReturnArgs} args - Arguments to update many UserTelegramData.
     * @example
     * // Update many UserTelegramData
     * const userTelegramData = await prisma.userTelegramData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserTelegramData and only return the `id`
     * const userTelegramDataWithIdOnly = await prisma.userTelegramData.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserTelegramDataUpdateManyAndReturnArgs>(args: SelectSubset<T, UserTelegramDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTelegramDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserTelegramData.
     * @param {UserTelegramDataUpsertArgs} args - Arguments to update or create a UserTelegramData.
     * @example
     * // Update or create a UserTelegramData
     * const userTelegramData = await prisma.userTelegramData.upsert({
     *   create: {
     *     // ... data to create a UserTelegramData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTelegramData we want to update
     *   }
     * })
     */
    upsert<T extends UserTelegramDataUpsertArgs>(args: SelectSubset<T, UserTelegramDataUpsertArgs<ExtArgs>>): Prisma__UserTelegramDataClient<$Result.GetResult<Prisma.$UserTelegramDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserTelegramData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTelegramDataCountArgs} args - Arguments to filter UserTelegramData to count.
     * @example
     * // Count the number of UserTelegramData
     * const count = await prisma.userTelegramData.count({
     *   where: {
     *     // ... the filter for the UserTelegramData we want to count
     *   }
     * })
    **/
    count<T extends UserTelegramDataCountArgs>(
      args?: Subset<T, UserTelegramDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTelegramDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTelegramData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTelegramDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTelegramDataAggregateArgs>(args: Subset<T, UserTelegramDataAggregateArgs>): Prisma.PrismaPromise<GetUserTelegramDataAggregateType<T>>

    /**
     * Group by UserTelegramData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTelegramDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTelegramDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTelegramDataGroupByArgs['orderBy'] }
        : { orderBy?: UserTelegramDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTelegramDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTelegramDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTelegramData model
   */
  readonly fields: UserTelegramDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTelegramData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTelegramDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserTelegramData$userArgs<ExtArgs> = {}>(args?: Subset<T, UserTelegramData$userArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTelegramData model
   */ 
  interface UserTelegramDataFieldRefs {
    readonly id: FieldRef<"UserTelegramData", 'String'>
    readonly isLive: FieldRef<"UserTelegramData", 'Boolean'>
    readonly isRtl: FieldRef<"UserTelegramData", 'Boolean'>
    readonly isPremium: FieldRef<"UserTelegramData", 'Boolean'>
    readonly isBot: FieldRef<"UserTelegramData", 'Boolean'>
    readonly firstName: FieldRef<"UserTelegramData", 'String'>
    readonly lastName: FieldRef<"UserTelegramData", 'String'>
    readonly username: FieldRef<"UserTelegramData", 'String'>
    readonly languageCode: FieldRef<"UserTelegramData", 'String'>
    readonly photoUrl: FieldRef<"UserTelegramData", 'String'>
    readonly addedToAttachmentMenu: FieldRef<"UserTelegramData", 'Boolean'>
    readonly allowsWriteToPm: FieldRef<"UserTelegramData", 'Boolean'>
    readonly updatedAt: FieldRef<"UserTelegramData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserTelegramData findUnique
   */
  export type UserTelegramDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTelegramData
     */
    select?: UserTelegramDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTelegramData
     */
    omit?: UserTelegramDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTelegramDataInclude<ExtArgs> | null
    /**
     * Filter, which UserTelegramData to fetch.
     */
    where: UserTelegramDataWhereUniqueInput
  }

  /**
   * UserTelegramData findUniqueOrThrow
   */
  export type UserTelegramDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTelegramData
     */
    select?: UserTelegramDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTelegramData
     */
    omit?: UserTelegramDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTelegramDataInclude<ExtArgs> | null
    /**
     * Filter, which UserTelegramData to fetch.
     */
    where: UserTelegramDataWhereUniqueInput
  }

  /**
   * UserTelegramData findFirst
   */
  export type UserTelegramDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTelegramData
     */
    select?: UserTelegramDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTelegramData
     */
    omit?: UserTelegramDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTelegramDataInclude<ExtArgs> | null
    /**
     * Filter, which UserTelegramData to fetch.
     */
    where?: UserTelegramDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTelegramData to fetch.
     */
    orderBy?: UserTelegramDataOrderByWithRelationInput | UserTelegramDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTelegramData.
     */
    cursor?: UserTelegramDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTelegramData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTelegramData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTelegramData.
     */
    distinct?: UserTelegramDataScalarFieldEnum | UserTelegramDataScalarFieldEnum[]
  }

  /**
   * UserTelegramData findFirstOrThrow
   */
  export type UserTelegramDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTelegramData
     */
    select?: UserTelegramDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTelegramData
     */
    omit?: UserTelegramDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTelegramDataInclude<ExtArgs> | null
    /**
     * Filter, which UserTelegramData to fetch.
     */
    where?: UserTelegramDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTelegramData to fetch.
     */
    orderBy?: UserTelegramDataOrderByWithRelationInput | UserTelegramDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTelegramData.
     */
    cursor?: UserTelegramDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTelegramData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTelegramData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTelegramData.
     */
    distinct?: UserTelegramDataScalarFieldEnum | UserTelegramDataScalarFieldEnum[]
  }

  /**
   * UserTelegramData findMany
   */
  export type UserTelegramDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTelegramData
     */
    select?: UserTelegramDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTelegramData
     */
    omit?: UserTelegramDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTelegramDataInclude<ExtArgs> | null
    /**
     * Filter, which UserTelegramData to fetch.
     */
    where?: UserTelegramDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTelegramData to fetch.
     */
    orderBy?: UserTelegramDataOrderByWithRelationInput | UserTelegramDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTelegramData.
     */
    cursor?: UserTelegramDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTelegramData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTelegramData.
     */
    skip?: number
    distinct?: UserTelegramDataScalarFieldEnum | UserTelegramDataScalarFieldEnum[]
  }

  /**
   * UserTelegramData create
   */
  export type UserTelegramDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTelegramData
     */
    select?: UserTelegramDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTelegramData
     */
    omit?: UserTelegramDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTelegramDataInclude<ExtArgs> | null
    /**
     * The data needed to create a UserTelegramData.
     */
    data: XOR<UserTelegramDataCreateInput, UserTelegramDataUncheckedCreateInput>
  }

  /**
   * UserTelegramData createMany
   */
  export type UserTelegramDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTelegramData.
     */
    data: UserTelegramDataCreateManyInput | UserTelegramDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserTelegramData createManyAndReturn
   */
  export type UserTelegramDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTelegramData
     */
    select?: UserTelegramDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTelegramData
     */
    omit?: UserTelegramDataOmit<ExtArgs> | null
    /**
     * The data used to create many UserTelegramData.
     */
    data: UserTelegramDataCreateManyInput | UserTelegramDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserTelegramData update
   */
  export type UserTelegramDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTelegramData
     */
    select?: UserTelegramDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTelegramData
     */
    omit?: UserTelegramDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTelegramDataInclude<ExtArgs> | null
    /**
     * The data needed to update a UserTelegramData.
     */
    data: XOR<UserTelegramDataUpdateInput, UserTelegramDataUncheckedUpdateInput>
    /**
     * Choose, which UserTelegramData to update.
     */
    where: UserTelegramDataWhereUniqueInput
  }

  /**
   * UserTelegramData updateMany
   */
  export type UserTelegramDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTelegramData.
     */
    data: XOR<UserTelegramDataUpdateManyMutationInput, UserTelegramDataUncheckedUpdateManyInput>
    /**
     * Filter which UserTelegramData to update
     */
    where?: UserTelegramDataWhereInput
    /**
     * Limit how many UserTelegramData to update.
     */
    limit?: number
  }

  /**
   * UserTelegramData updateManyAndReturn
   */
  export type UserTelegramDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTelegramData
     */
    select?: UserTelegramDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTelegramData
     */
    omit?: UserTelegramDataOmit<ExtArgs> | null
    /**
     * The data used to update UserTelegramData.
     */
    data: XOR<UserTelegramDataUpdateManyMutationInput, UserTelegramDataUncheckedUpdateManyInput>
    /**
     * Filter which UserTelegramData to update
     */
    where?: UserTelegramDataWhereInput
    /**
     * Limit how many UserTelegramData to update.
     */
    limit?: number
  }

  /**
   * UserTelegramData upsert
   */
  export type UserTelegramDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTelegramData
     */
    select?: UserTelegramDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTelegramData
     */
    omit?: UserTelegramDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTelegramDataInclude<ExtArgs> | null
    /**
     * The filter to search for the UserTelegramData to update in case it exists.
     */
    where: UserTelegramDataWhereUniqueInput
    /**
     * In case the UserTelegramData found by the `where` argument doesn't exist, create a new UserTelegramData with this data.
     */
    create: XOR<UserTelegramDataCreateInput, UserTelegramDataUncheckedCreateInput>
    /**
     * In case the UserTelegramData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTelegramDataUpdateInput, UserTelegramDataUncheckedUpdateInput>
  }

  /**
   * UserTelegramData delete
   */
  export type UserTelegramDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTelegramData
     */
    select?: UserTelegramDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTelegramData
     */
    omit?: UserTelegramDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTelegramDataInclude<ExtArgs> | null
    /**
     * Filter which UserTelegramData to delete.
     */
    where: UserTelegramDataWhereUniqueInput
  }

  /**
   * UserTelegramData deleteMany
   */
  export type UserTelegramDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTelegramData to delete
     */
    where?: UserTelegramDataWhereInput
    /**
     * Limit how many UserTelegramData to delete.
     */
    limit?: number
  }

  /**
   * UserTelegramData.user
   */
  export type UserTelegramData$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
  }

  /**
   * UserTelegramData without action
   */
  export type UserTelegramDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTelegramData
     */
    select?: UserTelegramDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTelegramData
     */
    omit?: UserTelegramDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTelegramDataInclude<ExtArgs> | null
  }


  /**
   * Model Referrals
   */

  export type AggregateReferrals = {
    _count: ReferralsCountAggregateOutputType | null
    _avg: ReferralsAvgAggregateOutputType | null
    _sum: ReferralsSumAggregateOutputType | null
    _min: ReferralsMinAggregateOutputType | null
    _max: ReferralsMaxAggregateOutputType | null
  }

  export type ReferralsAvgAggregateOutputType = {
    level: number | null
  }

  export type ReferralsSumAggregateOutputType = {
    level: number | null
  }

  export type ReferralsMinAggregateOutputType = {
    id: string | null
    level: number | null
    inviterId: string | null
    referralId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferralsMaxAggregateOutputType = {
    id: string | null
    level: number | null
    inviterId: string | null
    referralId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferralsCountAggregateOutputType = {
    id: number
    level: number
    inviterId: number
    referralId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReferralsAvgAggregateInputType = {
    level?: true
  }

  export type ReferralsSumAggregateInputType = {
    level?: true
  }

  export type ReferralsMinAggregateInputType = {
    id?: true
    level?: true
    inviterId?: true
    referralId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferralsMaxAggregateInputType = {
    id?: true
    level?: true
    inviterId?: true
    referralId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferralsCountAggregateInputType = {
    id?: true
    level?: true
    inviterId?: true
    referralId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReferralsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referrals to aggregate.
     */
    where?: ReferralsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralsOrderByWithRelationInput | ReferralsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Referrals
    **/
    _count?: true | ReferralsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralsMaxAggregateInputType
  }

  export type GetReferralsAggregateType<T extends ReferralsAggregateArgs> = {
        [P in keyof T & keyof AggregateReferrals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferrals[P]>
      : GetScalarType<T[P], AggregateReferrals[P]>
  }




  export type ReferralsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralsWhereInput
    orderBy?: ReferralsOrderByWithAggregationInput | ReferralsOrderByWithAggregationInput[]
    by: ReferralsScalarFieldEnum[] | ReferralsScalarFieldEnum
    having?: ReferralsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralsCountAggregateInputType | true
    _avg?: ReferralsAvgAggregateInputType
    _sum?: ReferralsSumAggregateInputType
    _min?: ReferralsMinAggregateInputType
    _max?: ReferralsMaxAggregateInputType
  }

  export type ReferralsGroupByOutputType = {
    id: string
    level: number
    inviterId: string
    referralId: string
    createdAt: Date
    updatedAt: Date
    _count: ReferralsCountAggregateOutputType | null
    _avg: ReferralsAvgAggregateOutputType | null
    _sum: ReferralsSumAggregateOutputType | null
    _min: ReferralsMinAggregateOutputType | null
    _max: ReferralsMaxAggregateOutputType | null
  }

  type GetReferralsGroupByPayload<T extends ReferralsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralsGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralsGroupByOutputType[P]>
        }
      >
    >


  export type ReferralsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    inviterId?: boolean
    referralId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inviter?: boolean | UsersDefaultArgs<ExtArgs>
    referral?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referrals"]>

  export type ReferralsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    inviterId?: boolean
    referralId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inviter?: boolean | UsersDefaultArgs<ExtArgs>
    referral?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referrals"]>

  export type ReferralsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    inviterId?: boolean
    referralId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inviter?: boolean | UsersDefaultArgs<ExtArgs>
    referral?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referrals"]>

  export type ReferralsSelectScalar = {
    id?: boolean
    level?: boolean
    inviterId?: boolean
    referralId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReferralsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "level" | "inviterId" | "referralId" | "createdAt" | "updatedAt", ExtArgs["result"]["referrals"]>
  export type ReferralsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviter?: boolean | UsersDefaultArgs<ExtArgs>
    referral?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ReferralsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviter?: boolean | UsersDefaultArgs<ExtArgs>
    referral?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ReferralsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviter?: boolean | UsersDefaultArgs<ExtArgs>
    referral?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $ReferralsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Referrals"
    objects: {
      inviter: Prisma.$UsersPayload<ExtArgs>
      referral: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      level: number
      inviterId: string
      referralId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["referrals"]>
    composites: {}
  }

  type ReferralsGetPayload<S extends boolean | null | undefined | ReferralsDefaultArgs> = $Result.GetResult<Prisma.$ReferralsPayload, S>

  type ReferralsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferralsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferralsCountAggregateInputType | true
    }

  export interface ReferralsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Referrals'], meta: { name: 'Referrals' } }
    /**
     * Find zero or one Referrals that matches the filter.
     * @param {ReferralsFindUniqueArgs} args - Arguments to find a Referrals
     * @example
     * // Get one Referrals
     * const referrals = await prisma.referrals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralsFindUniqueArgs>(args: SelectSubset<T, ReferralsFindUniqueArgs<ExtArgs>>): Prisma__ReferralsClient<$Result.GetResult<Prisma.$ReferralsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Referrals that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferralsFindUniqueOrThrowArgs} args - Arguments to find a Referrals
     * @example
     * // Get one Referrals
     * const referrals = await prisma.referrals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralsFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralsClient<$Result.GetResult<Prisma.$ReferralsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralsFindFirstArgs} args - Arguments to find a Referrals
     * @example
     * // Get one Referrals
     * const referrals = await prisma.referrals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralsFindFirstArgs>(args?: SelectSubset<T, ReferralsFindFirstArgs<ExtArgs>>): Prisma__ReferralsClient<$Result.GetResult<Prisma.$ReferralsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referrals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralsFindFirstOrThrowArgs} args - Arguments to find a Referrals
     * @example
     * // Get one Referrals
     * const referrals = await prisma.referrals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralsFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralsClient<$Result.GetResult<Prisma.$ReferralsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referrals
     * const referrals = await prisma.referrals.findMany()
     * 
     * // Get first 10 Referrals
     * const referrals = await prisma.referrals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralsWithIdOnly = await prisma.referrals.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralsFindManyArgs>(args?: SelectSubset<T, ReferralsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Referrals.
     * @param {ReferralsCreateArgs} args - Arguments to create a Referrals.
     * @example
     * // Create one Referrals
     * const Referrals = await prisma.referrals.create({
     *   data: {
     *     // ... data to create a Referrals
     *   }
     * })
     * 
     */
    create<T extends ReferralsCreateArgs>(args: SelectSubset<T, ReferralsCreateArgs<ExtArgs>>): Prisma__ReferralsClient<$Result.GetResult<Prisma.$ReferralsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Referrals.
     * @param {ReferralsCreateManyArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referrals = await prisma.referrals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralsCreateManyArgs>(args?: SelectSubset<T, ReferralsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Referrals and returns the data saved in the database.
     * @param {ReferralsCreateManyAndReturnArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referrals = await prisma.referrals.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Referrals and only return the `id`
     * const referralsWithIdOnly = await prisma.referrals.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralsCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Referrals.
     * @param {ReferralsDeleteArgs} args - Arguments to delete one Referrals.
     * @example
     * // Delete one Referrals
     * const Referrals = await prisma.referrals.delete({
     *   where: {
     *     // ... filter to delete one Referrals
     *   }
     * })
     * 
     */
    delete<T extends ReferralsDeleteArgs>(args: SelectSubset<T, ReferralsDeleteArgs<ExtArgs>>): Prisma__ReferralsClient<$Result.GetResult<Prisma.$ReferralsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Referrals.
     * @param {ReferralsUpdateArgs} args - Arguments to update one Referrals.
     * @example
     * // Update one Referrals
     * const referrals = await prisma.referrals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralsUpdateArgs>(args: SelectSubset<T, ReferralsUpdateArgs<ExtArgs>>): Prisma__ReferralsClient<$Result.GetResult<Prisma.$ReferralsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Referrals.
     * @param {ReferralsDeleteManyArgs} args - Arguments to filter Referrals to delete.
     * @example
     * // Delete a few Referrals
     * const { count } = await prisma.referrals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralsDeleteManyArgs>(args?: SelectSubset<T, ReferralsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referrals
     * const referrals = await prisma.referrals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralsUpdateManyArgs>(args: SelectSubset<T, ReferralsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals and returns the data updated in the database.
     * @param {ReferralsUpdateManyAndReturnArgs} args - Arguments to update many Referrals.
     * @example
     * // Update many Referrals
     * const referrals = await prisma.referrals.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Referrals and only return the `id`
     * const referralsWithIdOnly = await prisma.referrals.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReferralsUpdateManyAndReturnArgs>(args: SelectSubset<T, ReferralsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Referrals.
     * @param {ReferralsUpsertArgs} args - Arguments to update or create a Referrals.
     * @example
     * // Update or create a Referrals
     * const referrals = await prisma.referrals.upsert({
     *   create: {
     *     // ... data to create a Referrals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referrals we want to update
     *   }
     * })
     */
    upsert<T extends ReferralsUpsertArgs>(args: SelectSubset<T, ReferralsUpsertArgs<ExtArgs>>): Prisma__ReferralsClient<$Result.GetResult<Prisma.$ReferralsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralsCountArgs} args - Arguments to filter Referrals to count.
     * @example
     * // Count the number of Referrals
     * const count = await prisma.referrals.count({
     *   where: {
     *     // ... the filter for the Referrals we want to count
     *   }
     * })
    **/
    count<T extends ReferralsCountArgs>(
      args?: Subset<T, ReferralsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralsAggregateArgs>(args: Subset<T, ReferralsAggregateArgs>): Prisma.PrismaPromise<GetReferralsAggregateType<T>>

    /**
     * Group by Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralsGroupByArgs['orderBy'] }
        : { orderBy?: ReferralsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Referrals model
   */
  readonly fields: ReferralsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Referrals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inviter<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    referral<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Referrals model
   */ 
  interface ReferralsFieldRefs {
    readonly id: FieldRef<"Referrals", 'String'>
    readonly level: FieldRef<"Referrals", 'Int'>
    readonly inviterId: FieldRef<"Referrals", 'String'>
    readonly referralId: FieldRef<"Referrals", 'String'>
    readonly createdAt: FieldRef<"Referrals", 'DateTime'>
    readonly updatedAt: FieldRef<"Referrals", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Referrals findUnique
   */
  export type ReferralsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referrals
     */
    omit?: ReferralsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralsInclude<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where: ReferralsWhereUniqueInput
  }

  /**
   * Referrals findUniqueOrThrow
   */
  export type ReferralsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referrals
     */
    omit?: ReferralsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralsInclude<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where: ReferralsWhereUniqueInput
  }

  /**
   * Referrals findFirst
   */
  export type ReferralsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referrals
     */
    omit?: ReferralsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralsInclude<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralsOrderByWithRelationInput | ReferralsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralsScalarFieldEnum | ReferralsScalarFieldEnum[]
  }

  /**
   * Referrals findFirstOrThrow
   */
  export type ReferralsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referrals
     */
    omit?: ReferralsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralsInclude<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralsOrderByWithRelationInput | ReferralsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralsScalarFieldEnum | ReferralsScalarFieldEnum[]
  }

  /**
   * Referrals findMany
   */
  export type ReferralsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referrals
     */
    omit?: ReferralsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralsInclude<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralsOrderByWithRelationInput | ReferralsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Referrals.
     */
    cursor?: ReferralsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    distinct?: ReferralsScalarFieldEnum | ReferralsScalarFieldEnum[]
  }

  /**
   * Referrals create
   */
  export type ReferralsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referrals
     */
    omit?: ReferralsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralsInclude<ExtArgs> | null
    /**
     * The data needed to create a Referrals.
     */
    data: XOR<ReferralsCreateInput, ReferralsUncheckedCreateInput>
  }

  /**
   * Referrals createMany
   */
  export type ReferralsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Referrals.
     */
    data: ReferralsCreateManyInput | ReferralsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Referrals createManyAndReturn
   */
  export type ReferralsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Referrals
     */
    omit?: ReferralsOmit<ExtArgs> | null
    /**
     * The data used to create many Referrals.
     */
    data: ReferralsCreateManyInput | ReferralsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referrals update
   */
  export type ReferralsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referrals
     */
    omit?: ReferralsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralsInclude<ExtArgs> | null
    /**
     * The data needed to update a Referrals.
     */
    data: XOR<ReferralsUpdateInput, ReferralsUncheckedUpdateInput>
    /**
     * Choose, which Referrals to update.
     */
    where: ReferralsWhereUniqueInput
  }

  /**
   * Referrals updateMany
   */
  export type ReferralsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralsUpdateManyMutationInput, ReferralsUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralsWhereInput
    /**
     * Limit how many Referrals to update.
     */
    limit?: number
  }

  /**
   * Referrals updateManyAndReturn
   */
  export type ReferralsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Referrals
     */
    omit?: ReferralsOmit<ExtArgs> | null
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralsUpdateManyMutationInput, ReferralsUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralsWhereInput
    /**
     * Limit how many Referrals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referrals upsert
   */
  export type ReferralsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referrals
     */
    omit?: ReferralsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralsInclude<ExtArgs> | null
    /**
     * The filter to search for the Referrals to update in case it exists.
     */
    where: ReferralsWhereUniqueInput
    /**
     * In case the Referrals found by the `where` argument doesn't exist, create a new Referrals with this data.
     */
    create: XOR<ReferralsCreateInput, ReferralsUncheckedCreateInput>
    /**
     * In case the Referrals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralsUpdateInput, ReferralsUncheckedUpdateInput>
  }

  /**
   * Referrals delete
   */
  export type ReferralsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referrals
     */
    omit?: ReferralsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralsInclude<ExtArgs> | null
    /**
     * Filter which Referrals to delete.
     */
    where: ReferralsWhereUniqueInput
  }

  /**
   * Referrals deleteMany
   */
  export type ReferralsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referrals to delete
     */
    where?: ReferralsWhereInput
    /**
     * Limit how many Referrals to delete.
     */
    limit?: number
  }

  /**
   * Referrals without action
   */
  export type ReferralsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referrals
     */
    omit?: ReferralsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralsInclude<ExtArgs> | null
  }


  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    telegramId: string | null
    tonWallet: string | null
    isFreePlanAvailable: boolean | null
    isBanned: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastStartedAt: Date | null
    banExpiredAt: Date | null
    deletedAt: Date | null
    roleId: $Enums.UserRoleEnum | null
    telegramDataId: string | null
    balanceId: string | null
    languageId: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    telegramId: string | null
    tonWallet: string | null
    isFreePlanAvailable: boolean | null
    isBanned: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastStartedAt: Date | null
    banExpiredAt: Date | null
    deletedAt: Date | null
    roleId: $Enums.UserRoleEnum | null
    telegramDataId: string | null
    balanceId: string | null
    languageId: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    telegramId: number
    tonWallet: number
    isFreePlanAvailable: number
    isBanned: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    lastStartedAt: number
    banExpiredAt: number
    deletedAt: number
    roleId: number
    telegramDataId: number
    balanceId: number
    languageId: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    telegramId?: true
    tonWallet?: true
    isFreePlanAvailable?: true
    isBanned?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    lastStartedAt?: true
    banExpiredAt?: true
    deletedAt?: true
    roleId?: true
    telegramDataId?: true
    balanceId?: true
    languageId?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    telegramId?: true
    tonWallet?: true
    isFreePlanAvailable?: true
    isBanned?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    lastStartedAt?: true
    banExpiredAt?: true
    deletedAt?: true
    roleId?: true
    telegramDataId?: true
    balanceId?: true
    languageId?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    telegramId?: true
    tonWallet?: true
    isFreePlanAvailable?: true
    isBanned?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    lastStartedAt?: true
    banExpiredAt?: true
    deletedAt?: true
    roleId?: true
    telegramDataId?: true
    balanceId?: true
    languageId?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    telegramId: string
    tonWallet: string | null
    isFreePlanAvailable: boolean
    isBanned: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    lastStartedAt: Date | null
    banExpiredAt: Date | null
    deletedAt: Date | null
    roleId: $Enums.UserRoleEnum
    telegramDataId: string | null
    balanceId: string | null
    languageId: string
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telegramId?: boolean
    tonWallet?: boolean
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastStartedAt?: boolean
    banExpiredAt?: boolean
    deletedAt?: boolean
    roleId?: boolean
    telegramDataId?: boolean
    balanceId?: boolean
    languageId?: boolean
    role?: boolean | RolesDefaultArgs<ExtArgs>
    payments?: boolean | Users$paymentsArgs<ExtArgs>
    referrals?: boolean | Users$referralsArgs<ExtArgs>
    inviters?: boolean | Users$invitersArgs<ExtArgs>
    telegramData?: boolean | Users$telegramDataArgs<ExtArgs>
    balance?: boolean | Users$balanceArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    subscriptions?: boolean | Users$subscriptionsArgs<ExtArgs>
    withdrawals?: boolean | Users$withdrawalsArgs<ExtArgs>
    adsViews?: boolean | Users$adsViewsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telegramId?: boolean
    tonWallet?: boolean
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastStartedAt?: boolean
    banExpiredAt?: boolean
    deletedAt?: boolean
    roleId?: boolean
    telegramDataId?: boolean
    balanceId?: boolean
    languageId?: boolean
    role?: boolean | RolesDefaultArgs<ExtArgs>
    telegramData?: boolean | Users$telegramDataArgs<ExtArgs>
    balance?: boolean | Users$balanceArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telegramId?: boolean
    tonWallet?: boolean
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastStartedAt?: boolean
    banExpiredAt?: boolean
    deletedAt?: boolean
    roleId?: boolean
    telegramDataId?: boolean
    balanceId?: boolean
    languageId?: boolean
    role?: boolean | RolesDefaultArgs<ExtArgs>
    telegramData?: boolean | Users$telegramDataArgs<ExtArgs>
    balance?: boolean | Users$balanceArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectScalar = {
    id?: boolean
    telegramId?: boolean
    tonWallet?: boolean
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastStartedAt?: boolean
    banExpiredAt?: boolean
    deletedAt?: boolean
    roleId?: boolean
    telegramDataId?: boolean
    balanceId?: boolean
    languageId?: boolean
  }

  export type UsersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "telegramId" | "tonWallet" | "isFreePlanAvailable" | "isBanned" | "isDeleted" | "createdAt" | "updatedAt" | "lastStartedAt" | "banExpiredAt" | "deletedAt" | "roleId" | "telegramDataId" | "balanceId" | "languageId", ExtArgs["result"]["users"]>
  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RolesDefaultArgs<ExtArgs>
    payments?: boolean | Users$paymentsArgs<ExtArgs>
    referrals?: boolean | Users$referralsArgs<ExtArgs>
    inviters?: boolean | Users$invitersArgs<ExtArgs>
    telegramData?: boolean | Users$telegramDataArgs<ExtArgs>
    balance?: boolean | Users$balanceArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    subscriptions?: boolean | Users$subscriptionsArgs<ExtArgs>
    withdrawals?: boolean | Users$withdrawalsArgs<ExtArgs>
    adsViews?: boolean | Users$adsViewsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RolesDefaultArgs<ExtArgs>
    telegramData?: boolean | Users$telegramDataArgs<ExtArgs>
    balance?: boolean | Users$balanceArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }
  export type UsersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RolesDefaultArgs<ExtArgs>
    telegramData?: boolean | Users$telegramDataArgs<ExtArgs>
    balance?: boolean | Users$balanceArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      role: Prisma.$RolesPayload<ExtArgs>
      payments: Prisma.$PaymentsPayload<ExtArgs>[]
      referrals: Prisma.$ReferralsPayload<ExtArgs>[]
      inviters: Prisma.$ReferralsPayload<ExtArgs>[]
      telegramData: Prisma.$UserTelegramDataPayload<ExtArgs> | null
      balance: Prisma.$UserBalancePayload<ExtArgs> | null
      language: Prisma.$LanguagePayload<ExtArgs>
      subscriptions: Prisma.$SubscriptionsPayload<ExtArgs>[]
      withdrawals: Prisma.$WithdrawalsPayload<ExtArgs>[]
      adsViews: Prisma.$AdsViewsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      telegramId: string
      tonWallet: string | null
      isFreePlanAvailable: boolean
      isBanned: boolean
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      lastStartedAt: Date | null
      banExpiredAt: Date | null
      deletedAt: Date | null
      roleId: $Enums.UserRoleEnum
      telegramDataId: string | null
      balanceId: string | null
      languageId: string
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UsersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsersCreateManyAndReturnArgs>(args?: SelectSubset<T, UsersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UsersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsersUpdateManyAndReturnArgs>(args: SelectSubset<T, UsersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RolesDefaultArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends Users$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Users$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referrals<T extends Users$referralsArgs<ExtArgs> = {}>(args?: Subset<T, Users$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inviters<T extends Users$invitersArgs<ExtArgs> = {}>(args?: Subset<T, Users$invitersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    telegramData<T extends Users$telegramDataArgs<ExtArgs> = {}>(args?: Subset<T, Users$telegramDataArgs<ExtArgs>>): Prisma__UserTelegramDataClient<$Result.GetResult<Prisma.$UserTelegramDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    balance<T extends Users$balanceArgs<ExtArgs> = {}>(args?: Subset<T, Users$balanceArgs<ExtArgs>>): Prisma__UserBalanceClient<$Result.GetResult<Prisma.$UserBalancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subscriptions<T extends Users$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Users$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    withdrawals<T extends Users$withdrawalsArgs<ExtArgs> = {}>(args?: Subset<T, Users$withdrawalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adsViews<T extends Users$adsViewsArgs<ExtArgs> = {}>(args?: Subset<T, Users$adsViewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdsViewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */ 
  interface UsersFieldRefs {
    readonly id: FieldRef<"Users", 'String'>
    readonly telegramId: FieldRef<"Users", 'String'>
    readonly tonWallet: FieldRef<"Users", 'String'>
    readonly isFreePlanAvailable: FieldRef<"Users", 'Boolean'>
    readonly isBanned: FieldRef<"Users", 'Boolean'>
    readonly isDeleted: FieldRef<"Users", 'Boolean'>
    readonly createdAt: FieldRef<"Users", 'DateTime'>
    readonly updatedAt: FieldRef<"Users", 'DateTime'>
    readonly lastStartedAt: FieldRef<"Users", 'DateTime'>
    readonly banExpiredAt: FieldRef<"Users", 'DateTime'>
    readonly deletedAt: FieldRef<"Users", 'DateTime'>
    readonly roleId: FieldRef<"Users", 'UserRoleEnum'>
    readonly telegramDataId: FieldRef<"Users", 'String'>
    readonly balanceId: FieldRef<"Users", 'String'>
    readonly languageId: FieldRef<"Users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users createManyAndReturn
   */
  export type UsersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users updateManyAndReturn
   */
  export type UsersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * Users.payments
   */
  export type Users$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    where?: PaymentsWhereInput
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    cursor?: PaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Users.referrals
   */
  export type Users$referralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referrals
     */
    omit?: ReferralsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralsInclude<ExtArgs> | null
    where?: ReferralsWhereInput
    orderBy?: ReferralsOrderByWithRelationInput | ReferralsOrderByWithRelationInput[]
    cursor?: ReferralsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralsScalarFieldEnum | ReferralsScalarFieldEnum[]
  }

  /**
   * Users.inviters
   */
  export type Users$invitersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referrals
     */
    select?: ReferralsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referrals
     */
    omit?: ReferralsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralsInclude<ExtArgs> | null
    where?: ReferralsWhereInput
    orderBy?: ReferralsOrderByWithRelationInput | ReferralsOrderByWithRelationInput[]
    cursor?: ReferralsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralsScalarFieldEnum | ReferralsScalarFieldEnum[]
  }

  /**
   * Users.telegramData
   */
  export type Users$telegramDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTelegramData
     */
    select?: UserTelegramDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTelegramData
     */
    omit?: UserTelegramDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTelegramDataInclude<ExtArgs> | null
    where?: UserTelegramDataWhereInput
  }

  /**
   * Users.balance
   */
  export type Users$balanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBalance
     */
    select?: UserBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBalance
     */
    omit?: UserBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBalanceInclude<ExtArgs> | null
    where?: UserBalanceWhereInput
  }

  /**
   * Users.subscriptions
   */
  export type Users$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    where?: SubscriptionsWhereInput
    orderBy?: SubscriptionsOrderByWithRelationInput | SubscriptionsOrderByWithRelationInput[]
    cursor?: SubscriptionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * Users.withdrawals
   */
  export type Users$withdrawalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawals
     */
    select?: WithdrawalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawals
     */
    omit?: WithdrawalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalsInclude<ExtArgs> | null
    where?: WithdrawalsWhereInput
    orderBy?: WithdrawalsOrderByWithRelationInput | WithdrawalsOrderByWithRelationInput[]
    cursor?: WithdrawalsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WithdrawalsScalarFieldEnum | WithdrawalsScalarFieldEnum[]
  }

  /**
   * Users.adsViews
   */
  export type Users$adsViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsViews
     */
    select?: AdsViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsViews
     */
    omit?: AdsViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsViewsInclude<ExtArgs> | null
    where?: AdsViewsWhereInput
    orderBy?: AdsViewsOrderByWithRelationInput | AdsViewsOrderByWithRelationInput[]
    cursor?: AdsViewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdsViewsScalarFieldEnum | AdsViewsScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model AdsViews
   */

  export type AggregateAdsViews = {
    _count: AdsViewsCountAggregateOutputType | null
    _min: AdsViewsMinAggregateOutputType | null
    _max: AdsViewsMaxAggregateOutputType | null
  }

  export type AdsViewsMinAggregateOutputType = {
    id: string | null
    networkKey: $Enums.AdsNetworkEnum | null
    type: $Enums.AdsViewTypeEnum | null
    createdAt: Date | null
    userId: string | null
  }

  export type AdsViewsMaxAggregateOutputType = {
    id: string | null
    networkKey: $Enums.AdsNetworkEnum | null
    type: $Enums.AdsViewTypeEnum | null
    createdAt: Date | null
    userId: string | null
  }

  export type AdsViewsCountAggregateOutputType = {
    id: number
    networkKey: number
    type: number
    createdAt: number
    userId: number
    _all: number
  }


  export type AdsViewsMinAggregateInputType = {
    id?: true
    networkKey?: true
    type?: true
    createdAt?: true
    userId?: true
  }

  export type AdsViewsMaxAggregateInputType = {
    id?: true
    networkKey?: true
    type?: true
    createdAt?: true
    userId?: true
  }

  export type AdsViewsCountAggregateInputType = {
    id?: true
    networkKey?: true
    type?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type AdsViewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdsViews to aggregate.
     */
    where?: AdsViewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdsViews to fetch.
     */
    orderBy?: AdsViewsOrderByWithRelationInput | AdsViewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdsViewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdsViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdsViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdsViews
    **/
    _count?: true | AdsViewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdsViewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdsViewsMaxAggregateInputType
  }

  export type GetAdsViewsAggregateType<T extends AdsViewsAggregateArgs> = {
        [P in keyof T & keyof AggregateAdsViews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdsViews[P]>
      : GetScalarType<T[P], AggregateAdsViews[P]>
  }




  export type AdsViewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdsViewsWhereInput
    orderBy?: AdsViewsOrderByWithAggregationInput | AdsViewsOrderByWithAggregationInput[]
    by: AdsViewsScalarFieldEnum[] | AdsViewsScalarFieldEnum
    having?: AdsViewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdsViewsCountAggregateInputType | true
    _min?: AdsViewsMinAggregateInputType
    _max?: AdsViewsMaxAggregateInputType
  }

  export type AdsViewsGroupByOutputType = {
    id: string
    networkKey: $Enums.AdsNetworkEnum
    type: $Enums.AdsViewTypeEnum
    createdAt: Date
    userId: string
    _count: AdsViewsCountAggregateOutputType | null
    _min: AdsViewsMinAggregateOutputType | null
    _max: AdsViewsMaxAggregateOutputType | null
  }

  type GetAdsViewsGroupByPayload<T extends AdsViewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdsViewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdsViewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdsViewsGroupByOutputType[P]>
            : GetScalarType<T[P], AdsViewsGroupByOutputType[P]>
        }
      >
    >


  export type AdsViewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    networkKey?: boolean
    type?: boolean
    createdAt?: boolean
    userId?: boolean
    network?: boolean | AdsNetworksDefaultArgs<ExtArgs>
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adsViews"]>

  export type AdsViewsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    networkKey?: boolean
    type?: boolean
    createdAt?: boolean
    userId?: boolean
    network?: boolean | AdsNetworksDefaultArgs<ExtArgs>
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adsViews"]>

  export type AdsViewsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    networkKey?: boolean
    type?: boolean
    createdAt?: boolean
    userId?: boolean
    network?: boolean | AdsNetworksDefaultArgs<ExtArgs>
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adsViews"]>

  export type AdsViewsSelectScalar = {
    id?: boolean
    networkKey?: boolean
    type?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type AdsViewsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "networkKey" | "type" | "createdAt" | "userId", ExtArgs["result"]["adsViews"]>
  export type AdsViewsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    network?: boolean | AdsNetworksDefaultArgs<ExtArgs>
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type AdsViewsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    network?: boolean | AdsNetworksDefaultArgs<ExtArgs>
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type AdsViewsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    network?: boolean | AdsNetworksDefaultArgs<ExtArgs>
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $AdsViewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdsViews"
    objects: {
      network: Prisma.$AdsNetworksPayload<ExtArgs>
      user: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      networkKey: $Enums.AdsNetworkEnum
      type: $Enums.AdsViewTypeEnum
      createdAt: Date
      userId: string
    }, ExtArgs["result"]["adsViews"]>
    composites: {}
  }

  type AdsViewsGetPayload<S extends boolean | null | undefined | AdsViewsDefaultArgs> = $Result.GetResult<Prisma.$AdsViewsPayload, S>

  type AdsViewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdsViewsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdsViewsCountAggregateInputType | true
    }

  export interface AdsViewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdsViews'], meta: { name: 'AdsViews' } }
    /**
     * Find zero or one AdsViews that matches the filter.
     * @param {AdsViewsFindUniqueArgs} args - Arguments to find a AdsViews
     * @example
     * // Get one AdsViews
     * const adsViews = await prisma.adsViews.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdsViewsFindUniqueArgs>(args: SelectSubset<T, AdsViewsFindUniqueArgs<ExtArgs>>): Prisma__AdsViewsClient<$Result.GetResult<Prisma.$AdsViewsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdsViews that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdsViewsFindUniqueOrThrowArgs} args - Arguments to find a AdsViews
     * @example
     * // Get one AdsViews
     * const adsViews = await prisma.adsViews.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdsViewsFindUniqueOrThrowArgs>(args: SelectSubset<T, AdsViewsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdsViewsClient<$Result.GetResult<Prisma.$AdsViewsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdsViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsViewsFindFirstArgs} args - Arguments to find a AdsViews
     * @example
     * // Get one AdsViews
     * const adsViews = await prisma.adsViews.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdsViewsFindFirstArgs>(args?: SelectSubset<T, AdsViewsFindFirstArgs<ExtArgs>>): Prisma__AdsViewsClient<$Result.GetResult<Prisma.$AdsViewsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdsViews that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsViewsFindFirstOrThrowArgs} args - Arguments to find a AdsViews
     * @example
     * // Get one AdsViews
     * const adsViews = await prisma.adsViews.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdsViewsFindFirstOrThrowArgs>(args?: SelectSubset<T, AdsViewsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdsViewsClient<$Result.GetResult<Prisma.$AdsViewsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdsViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsViewsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdsViews
     * const adsViews = await prisma.adsViews.findMany()
     * 
     * // Get first 10 AdsViews
     * const adsViews = await prisma.adsViews.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adsViewsWithIdOnly = await prisma.adsViews.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdsViewsFindManyArgs>(args?: SelectSubset<T, AdsViewsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdsViewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdsViews.
     * @param {AdsViewsCreateArgs} args - Arguments to create a AdsViews.
     * @example
     * // Create one AdsViews
     * const AdsViews = await prisma.adsViews.create({
     *   data: {
     *     // ... data to create a AdsViews
     *   }
     * })
     * 
     */
    create<T extends AdsViewsCreateArgs>(args: SelectSubset<T, AdsViewsCreateArgs<ExtArgs>>): Prisma__AdsViewsClient<$Result.GetResult<Prisma.$AdsViewsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdsViews.
     * @param {AdsViewsCreateManyArgs} args - Arguments to create many AdsViews.
     * @example
     * // Create many AdsViews
     * const adsViews = await prisma.adsViews.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdsViewsCreateManyArgs>(args?: SelectSubset<T, AdsViewsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdsViews and returns the data saved in the database.
     * @param {AdsViewsCreateManyAndReturnArgs} args - Arguments to create many AdsViews.
     * @example
     * // Create many AdsViews
     * const adsViews = await prisma.adsViews.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdsViews and only return the `id`
     * const adsViewsWithIdOnly = await prisma.adsViews.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdsViewsCreateManyAndReturnArgs>(args?: SelectSubset<T, AdsViewsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdsViewsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdsViews.
     * @param {AdsViewsDeleteArgs} args - Arguments to delete one AdsViews.
     * @example
     * // Delete one AdsViews
     * const AdsViews = await prisma.adsViews.delete({
     *   where: {
     *     // ... filter to delete one AdsViews
     *   }
     * })
     * 
     */
    delete<T extends AdsViewsDeleteArgs>(args: SelectSubset<T, AdsViewsDeleteArgs<ExtArgs>>): Prisma__AdsViewsClient<$Result.GetResult<Prisma.$AdsViewsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdsViews.
     * @param {AdsViewsUpdateArgs} args - Arguments to update one AdsViews.
     * @example
     * // Update one AdsViews
     * const adsViews = await prisma.adsViews.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdsViewsUpdateArgs>(args: SelectSubset<T, AdsViewsUpdateArgs<ExtArgs>>): Prisma__AdsViewsClient<$Result.GetResult<Prisma.$AdsViewsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdsViews.
     * @param {AdsViewsDeleteManyArgs} args - Arguments to filter AdsViews to delete.
     * @example
     * // Delete a few AdsViews
     * const { count } = await prisma.adsViews.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdsViewsDeleteManyArgs>(args?: SelectSubset<T, AdsViewsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdsViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsViewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdsViews
     * const adsViews = await prisma.adsViews.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdsViewsUpdateManyArgs>(args: SelectSubset<T, AdsViewsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdsViews and returns the data updated in the database.
     * @param {AdsViewsUpdateManyAndReturnArgs} args - Arguments to update many AdsViews.
     * @example
     * // Update many AdsViews
     * const adsViews = await prisma.adsViews.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdsViews and only return the `id`
     * const adsViewsWithIdOnly = await prisma.adsViews.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdsViewsUpdateManyAndReturnArgs>(args: SelectSubset<T, AdsViewsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdsViewsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdsViews.
     * @param {AdsViewsUpsertArgs} args - Arguments to update or create a AdsViews.
     * @example
     * // Update or create a AdsViews
     * const adsViews = await prisma.adsViews.upsert({
     *   create: {
     *     // ... data to create a AdsViews
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdsViews we want to update
     *   }
     * })
     */
    upsert<T extends AdsViewsUpsertArgs>(args: SelectSubset<T, AdsViewsUpsertArgs<ExtArgs>>): Prisma__AdsViewsClient<$Result.GetResult<Prisma.$AdsViewsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdsViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsViewsCountArgs} args - Arguments to filter AdsViews to count.
     * @example
     * // Count the number of AdsViews
     * const count = await prisma.adsViews.count({
     *   where: {
     *     // ... the filter for the AdsViews we want to count
     *   }
     * })
    **/
    count<T extends AdsViewsCountArgs>(
      args?: Subset<T, AdsViewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdsViewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdsViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsViewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdsViewsAggregateArgs>(args: Subset<T, AdsViewsAggregateArgs>): Prisma.PrismaPromise<GetAdsViewsAggregateType<T>>

    /**
     * Group by AdsViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsViewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdsViewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdsViewsGroupByArgs['orderBy'] }
        : { orderBy?: AdsViewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdsViewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdsViewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdsViews model
   */
  readonly fields: AdsViewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdsViews.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdsViewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    network<T extends AdsNetworksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdsNetworksDefaultArgs<ExtArgs>>): Prisma__AdsNetworksClient<$Result.GetResult<Prisma.$AdsNetworksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdsViews model
   */ 
  interface AdsViewsFieldRefs {
    readonly id: FieldRef<"AdsViews", 'String'>
    readonly networkKey: FieldRef<"AdsViews", 'AdsNetworkEnum'>
    readonly type: FieldRef<"AdsViews", 'AdsViewTypeEnum'>
    readonly createdAt: FieldRef<"AdsViews", 'DateTime'>
    readonly userId: FieldRef<"AdsViews", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdsViews findUnique
   */
  export type AdsViewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsViews
     */
    select?: AdsViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsViews
     */
    omit?: AdsViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsViewsInclude<ExtArgs> | null
    /**
     * Filter, which AdsViews to fetch.
     */
    where: AdsViewsWhereUniqueInput
  }

  /**
   * AdsViews findUniqueOrThrow
   */
  export type AdsViewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsViews
     */
    select?: AdsViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsViews
     */
    omit?: AdsViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsViewsInclude<ExtArgs> | null
    /**
     * Filter, which AdsViews to fetch.
     */
    where: AdsViewsWhereUniqueInput
  }

  /**
   * AdsViews findFirst
   */
  export type AdsViewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsViews
     */
    select?: AdsViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsViews
     */
    omit?: AdsViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsViewsInclude<ExtArgs> | null
    /**
     * Filter, which AdsViews to fetch.
     */
    where?: AdsViewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdsViews to fetch.
     */
    orderBy?: AdsViewsOrderByWithRelationInput | AdsViewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdsViews.
     */
    cursor?: AdsViewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdsViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdsViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdsViews.
     */
    distinct?: AdsViewsScalarFieldEnum | AdsViewsScalarFieldEnum[]
  }

  /**
   * AdsViews findFirstOrThrow
   */
  export type AdsViewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsViews
     */
    select?: AdsViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsViews
     */
    omit?: AdsViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsViewsInclude<ExtArgs> | null
    /**
     * Filter, which AdsViews to fetch.
     */
    where?: AdsViewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdsViews to fetch.
     */
    orderBy?: AdsViewsOrderByWithRelationInput | AdsViewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdsViews.
     */
    cursor?: AdsViewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdsViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdsViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdsViews.
     */
    distinct?: AdsViewsScalarFieldEnum | AdsViewsScalarFieldEnum[]
  }

  /**
   * AdsViews findMany
   */
  export type AdsViewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsViews
     */
    select?: AdsViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsViews
     */
    omit?: AdsViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsViewsInclude<ExtArgs> | null
    /**
     * Filter, which AdsViews to fetch.
     */
    where?: AdsViewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdsViews to fetch.
     */
    orderBy?: AdsViewsOrderByWithRelationInput | AdsViewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdsViews.
     */
    cursor?: AdsViewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdsViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdsViews.
     */
    skip?: number
    distinct?: AdsViewsScalarFieldEnum | AdsViewsScalarFieldEnum[]
  }

  /**
   * AdsViews create
   */
  export type AdsViewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsViews
     */
    select?: AdsViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsViews
     */
    omit?: AdsViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsViewsInclude<ExtArgs> | null
    /**
     * The data needed to create a AdsViews.
     */
    data: XOR<AdsViewsCreateInput, AdsViewsUncheckedCreateInput>
  }

  /**
   * AdsViews createMany
   */
  export type AdsViewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdsViews.
     */
    data: AdsViewsCreateManyInput | AdsViewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdsViews createManyAndReturn
   */
  export type AdsViewsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsViews
     */
    select?: AdsViewsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdsViews
     */
    omit?: AdsViewsOmit<ExtArgs> | null
    /**
     * The data used to create many AdsViews.
     */
    data: AdsViewsCreateManyInput | AdsViewsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsViewsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdsViews update
   */
  export type AdsViewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsViews
     */
    select?: AdsViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsViews
     */
    omit?: AdsViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsViewsInclude<ExtArgs> | null
    /**
     * The data needed to update a AdsViews.
     */
    data: XOR<AdsViewsUpdateInput, AdsViewsUncheckedUpdateInput>
    /**
     * Choose, which AdsViews to update.
     */
    where: AdsViewsWhereUniqueInput
  }

  /**
   * AdsViews updateMany
   */
  export type AdsViewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdsViews.
     */
    data: XOR<AdsViewsUpdateManyMutationInput, AdsViewsUncheckedUpdateManyInput>
    /**
     * Filter which AdsViews to update
     */
    where?: AdsViewsWhereInput
    /**
     * Limit how many AdsViews to update.
     */
    limit?: number
  }

  /**
   * AdsViews updateManyAndReturn
   */
  export type AdsViewsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsViews
     */
    select?: AdsViewsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdsViews
     */
    omit?: AdsViewsOmit<ExtArgs> | null
    /**
     * The data used to update AdsViews.
     */
    data: XOR<AdsViewsUpdateManyMutationInput, AdsViewsUncheckedUpdateManyInput>
    /**
     * Filter which AdsViews to update
     */
    where?: AdsViewsWhereInput
    /**
     * Limit how many AdsViews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsViewsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdsViews upsert
   */
  export type AdsViewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsViews
     */
    select?: AdsViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsViews
     */
    omit?: AdsViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsViewsInclude<ExtArgs> | null
    /**
     * The filter to search for the AdsViews to update in case it exists.
     */
    where: AdsViewsWhereUniqueInput
    /**
     * In case the AdsViews found by the `where` argument doesn't exist, create a new AdsViews with this data.
     */
    create: XOR<AdsViewsCreateInput, AdsViewsUncheckedCreateInput>
    /**
     * In case the AdsViews was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdsViewsUpdateInput, AdsViewsUncheckedUpdateInput>
  }

  /**
   * AdsViews delete
   */
  export type AdsViewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsViews
     */
    select?: AdsViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsViews
     */
    omit?: AdsViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsViewsInclude<ExtArgs> | null
    /**
     * Filter which AdsViews to delete.
     */
    where: AdsViewsWhereUniqueInput
  }

  /**
   * AdsViews deleteMany
   */
  export type AdsViewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdsViews to delete
     */
    where?: AdsViewsWhereInput
    /**
     * Limit how many AdsViews to delete.
     */
    limit?: number
  }

  /**
   * AdsViews without action
   */
  export type AdsViewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsViews
     */
    select?: AdsViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsViews
     */
    omit?: AdsViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsViewsInclude<ExtArgs> | null
  }


  /**
   * Model AdsNetworks
   */

  export type AggregateAdsNetworks = {
    _count: AdsNetworksCountAggregateOutputType | null
    _min: AdsNetworksMinAggregateOutputType | null
    _max: AdsNetworksMaxAggregateOutputType | null
  }

  export type AdsNetworksMinAggregateOutputType = {
    key: $Enums.AdsNetworkEnum | null
    isActive: boolean | null
    name: string | null
  }

  export type AdsNetworksMaxAggregateOutputType = {
    key: $Enums.AdsNetworkEnum | null
    isActive: boolean | null
    name: string | null
  }

  export type AdsNetworksCountAggregateOutputType = {
    key: number
    isActive: number
    name: number
    _all: number
  }


  export type AdsNetworksMinAggregateInputType = {
    key?: true
    isActive?: true
    name?: true
  }

  export type AdsNetworksMaxAggregateInputType = {
    key?: true
    isActive?: true
    name?: true
  }

  export type AdsNetworksCountAggregateInputType = {
    key?: true
    isActive?: true
    name?: true
    _all?: true
  }

  export type AdsNetworksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdsNetworks to aggregate.
     */
    where?: AdsNetworksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdsNetworks to fetch.
     */
    orderBy?: AdsNetworksOrderByWithRelationInput | AdsNetworksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdsNetworksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdsNetworks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdsNetworks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdsNetworks
    **/
    _count?: true | AdsNetworksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdsNetworksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdsNetworksMaxAggregateInputType
  }

  export type GetAdsNetworksAggregateType<T extends AdsNetworksAggregateArgs> = {
        [P in keyof T & keyof AggregateAdsNetworks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdsNetworks[P]>
      : GetScalarType<T[P], AggregateAdsNetworks[P]>
  }




  export type AdsNetworksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdsNetworksWhereInput
    orderBy?: AdsNetworksOrderByWithAggregationInput | AdsNetworksOrderByWithAggregationInput[]
    by: AdsNetworksScalarFieldEnum[] | AdsNetworksScalarFieldEnum
    having?: AdsNetworksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdsNetworksCountAggregateInputType | true
    _min?: AdsNetworksMinAggregateInputType
    _max?: AdsNetworksMaxAggregateInputType
  }

  export type AdsNetworksGroupByOutputType = {
    key: $Enums.AdsNetworkEnum
    isActive: boolean
    name: string
    _count: AdsNetworksCountAggregateOutputType | null
    _min: AdsNetworksMinAggregateOutputType | null
    _max: AdsNetworksMaxAggregateOutputType | null
  }

  type GetAdsNetworksGroupByPayload<T extends AdsNetworksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdsNetworksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdsNetworksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdsNetworksGroupByOutputType[P]>
            : GetScalarType<T[P], AdsNetworksGroupByOutputType[P]>
        }
      >
    >


  export type AdsNetworksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    isActive?: boolean
    name?: boolean
    adsViews?: boolean | AdsNetworks$adsViewsArgs<ExtArgs>
    _count?: boolean | AdsNetworksCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adsNetworks"]>

  export type AdsNetworksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    isActive?: boolean
    name?: boolean
  }, ExtArgs["result"]["adsNetworks"]>

  export type AdsNetworksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    isActive?: boolean
    name?: boolean
  }, ExtArgs["result"]["adsNetworks"]>

  export type AdsNetworksSelectScalar = {
    key?: boolean
    isActive?: boolean
    name?: boolean
  }

  export type AdsNetworksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "isActive" | "name", ExtArgs["result"]["adsNetworks"]>
  export type AdsNetworksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adsViews?: boolean | AdsNetworks$adsViewsArgs<ExtArgs>
    _count?: boolean | AdsNetworksCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdsNetworksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AdsNetworksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdsNetworksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdsNetworks"
    objects: {
      adsViews: Prisma.$AdsViewsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      key: $Enums.AdsNetworkEnum
      isActive: boolean
      name: string
    }, ExtArgs["result"]["adsNetworks"]>
    composites: {}
  }

  type AdsNetworksGetPayload<S extends boolean | null | undefined | AdsNetworksDefaultArgs> = $Result.GetResult<Prisma.$AdsNetworksPayload, S>

  type AdsNetworksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdsNetworksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdsNetworksCountAggregateInputType | true
    }

  export interface AdsNetworksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdsNetworks'], meta: { name: 'AdsNetworks' } }
    /**
     * Find zero or one AdsNetworks that matches the filter.
     * @param {AdsNetworksFindUniqueArgs} args - Arguments to find a AdsNetworks
     * @example
     * // Get one AdsNetworks
     * const adsNetworks = await prisma.adsNetworks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdsNetworksFindUniqueArgs>(args: SelectSubset<T, AdsNetworksFindUniqueArgs<ExtArgs>>): Prisma__AdsNetworksClient<$Result.GetResult<Prisma.$AdsNetworksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdsNetworks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdsNetworksFindUniqueOrThrowArgs} args - Arguments to find a AdsNetworks
     * @example
     * // Get one AdsNetworks
     * const adsNetworks = await prisma.adsNetworks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdsNetworksFindUniqueOrThrowArgs>(args: SelectSubset<T, AdsNetworksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdsNetworksClient<$Result.GetResult<Prisma.$AdsNetworksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdsNetworks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsNetworksFindFirstArgs} args - Arguments to find a AdsNetworks
     * @example
     * // Get one AdsNetworks
     * const adsNetworks = await prisma.adsNetworks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdsNetworksFindFirstArgs>(args?: SelectSubset<T, AdsNetworksFindFirstArgs<ExtArgs>>): Prisma__AdsNetworksClient<$Result.GetResult<Prisma.$AdsNetworksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdsNetworks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsNetworksFindFirstOrThrowArgs} args - Arguments to find a AdsNetworks
     * @example
     * // Get one AdsNetworks
     * const adsNetworks = await prisma.adsNetworks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdsNetworksFindFirstOrThrowArgs>(args?: SelectSubset<T, AdsNetworksFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdsNetworksClient<$Result.GetResult<Prisma.$AdsNetworksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdsNetworks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsNetworksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdsNetworks
     * const adsNetworks = await prisma.adsNetworks.findMany()
     * 
     * // Get first 10 AdsNetworks
     * const adsNetworks = await prisma.adsNetworks.findMany({ take: 10 })
     * 
     * // Only select the `isActive`
     * const adsNetworksWithIsActiveOnly = await prisma.adsNetworks.findMany({ select: { isActive: true } })
     * 
     */
    findMany<T extends AdsNetworksFindManyArgs>(args?: SelectSubset<T, AdsNetworksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdsNetworksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdsNetworks.
     * @param {AdsNetworksCreateArgs} args - Arguments to create a AdsNetworks.
     * @example
     * // Create one AdsNetworks
     * const AdsNetworks = await prisma.adsNetworks.create({
     *   data: {
     *     // ... data to create a AdsNetworks
     *   }
     * })
     * 
     */
    create<T extends AdsNetworksCreateArgs>(args: SelectSubset<T, AdsNetworksCreateArgs<ExtArgs>>): Prisma__AdsNetworksClient<$Result.GetResult<Prisma.$AdsNetworksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdsNetworks.
     * @param {AdsNetworksCreateManyArgs} args - Arguments to create many AdsNetworks.
     * @example
     * // Create many AdsNetworks
     * const adsNetworks = await prisma.adsNetworks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdsNetworksCreateManyArgs>(args?: SelectSubset<T, AdsNetworksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdsNetworks and returns the data saved in the database.
     * @param {AdsNetworksCreateManyAndReturnArgs} args - Arguments to create many AdsNetworks.
     * @example
     * // Create many AdsNetworks
     * const adsNetworks = await prisma.adsNetworks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdsNetworks and only return the `isActive`
     * const adsNetworksWithIsActiveOnly = await prisma.adsNetworks.createManyAndReturn({
     *   select: { isActive: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdsNetworksCreateManyAndReturnArgs>(args?: SelectSubset<T, AdsNetworksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdsNetworksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdsNetworks.
     * @param {AdsNetworksDeleteArgs} args - Arguments to delete one AdsNetworks.
     * @example
     * // Delete one AdsNetworks
     * const AdsNetworks = await prisma.adsNetworks.delete({
     *   where: {
     *     // ... filter to delete one AdsNetworks
     *   }
     * })
     * 
     */
    delete<T extends AdsNetworksDeleteArgs>(args: SelectSubset<T, AdsNetworksDeleteArgs<ExtArgs>>): Prisma__AdsNetworksClient<$Result.GetResult<Prisma.$AdsNetworksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdsNetworks.
     * @param {AdsNetworksUpdateArgs} args - Arguments to update one AdsNetworks.
     * @example
     * // Update one AdsNetworks
     * const adsNetworks = await prisma.adsNetworks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdsNetworksUpdateArgs>(args: SelectSubset<T, AdsNetworksUpdateArgs<ExtArgs>>): Prisma__AdsNetworksClient<$Result.GetResult<Prisma.$AdsNetworksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdsNetworks.
     * @param {AdsNetworksDeleteManyArgs} args - Arguments to filter AdsNetworks to delete.
     * @example
     * // Delete a few AdsNetworks
     * const { count } = await prisma.adsNetworks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdsNetworksDeleteManyArgs>(args?: SelectSubset<T, AdsNetworksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdsNetworks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsNetworksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdsNetworks
     * const adsNetworks = await prisma.adsNetworks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdsNetworksUpdateManyArgs>(args: SelectSubset<T, AdsNetworksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdsNetworks and returns the data updated in the database.
     * @param {AdsNetworksUpdateManyAndReturnArgs} args - Arguments to update many AdsNetworks.
     * @example
     * // Update many AdsNetworks
     * const adsNetworks = await prisma.adsNetworks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdsNetworks and only return the `isActive`
     * const adsNetworksWithIsActiveOnly = await prisma.adsNetworks.updateManyAndReturn({
     *   select: { isActive: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdsNetworksUpdateManyAndReturnArgs>(args: SelectSubset<T, AdsNetworksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdsNetworksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdsNetworks.
     * @param {AdsNetworksUpsertArgs} args - Arguments to update or create a AdsNetworks.
     * @example
     * // Update or create a AdsNetworks
     * const adsNetworks = await prisma.adsNetworks.upsert({
     *   create: {
     *     // ... data to create a AdsNetworks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdsNetworks we want to update
     *   }
     * })
     */
    upsert<T extends AdsNetworksUpsertArgs>(args: SelectSubset<T, AdsNetworksUpsertArgs<ExtArgs>>): Prisma__AdsNetworksClient<$Result.GetResult<Prisma.$AdsNetworksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdsNetworks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsNetworksCountArgs} args - Arguments to filter AdsNetworks to count.
     * @example
     * // Count the number of AdsNetworks
     * const count = await prisma.adsNetworks.count({
     *   where: {
     *     // ... the filter for the AdsNetworks we want to count
     *   }
     * })
    **/
    count<T extends AdsNetworksCountArgs>(
      args?: Subset<T, AdsNetworksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdsNetworksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdsNetworks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsNetworksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdsNetworksAggregateArgs>(args: Subset<T, AdsNetworksAggregateArgs>): Prisma.PrismaPromise<GetAdsNetworksAggregateType<T>>

    /**
     * Group by AdsNetworks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsNetworksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdsNetworksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdsNetworksGroupByArgs['orderBy'] }
        : { orderBy?: AdsNetworksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdsNetworksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdsNetworksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdsNetworks model
   */
  readonly fields: AdsNetworksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdsNetworks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdsNetworksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adsViews<T extends AdsNetworks$adsViewsArgs<ExtArgs> = {}>(args?: Subset<T, AdsNetworks$adsViewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdsViewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdsNetworks model
   */ 
  interface AdsNetworksFieldRefs {
    readonly key: FieldRef<"AdsNetworks", 'AdsNetworkEnum'>
    readonly isActive: FieldRef<"AdsNetworks", 'Boolean'>
    readonly name: FieldRef<"AdsNetworks", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdsNetworks findUnique
   */
  export type AdsNetworksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsNetworks
     */
    select?: AdsNetworksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsNetworks
     */
    omit?: AdsNetworksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsNetworksInclude<ExtArgs> | null
    /**
     * Filter, which AdsNetworks to fetch.
     */
    where: AdsNetworksWhereUniqueInput
  }

  /**
   * AdsNetworks findUniqueOrThrow
   */
  export type AdsNetworksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsNetworks
     */
    select?: AdsNetworksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsNetworks
     */
    omit?: AdsNetworksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsNetworksInclude<ExtArgs> | null
    /**
     * Filter, which AdsNetworks to fetch.
     */
    where: AdsNetworksWhereUniqueInput
  }

  /**
   * AdsNetworks findFirst
   */
  export type AdsNetworksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsNetworks
     */
    select?: AdsNetworksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsNetworks
     */
    omit?: AdsNetworksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsNetworksInclude<ExtArgs> | null
    /**
     * Filter, which AdsNetworks to fetch.
     */
    where?: AdsNetworksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdsNetworks to fetch.
     */
    orderBy?: AdsNetworksOrderByWithRelationInput | AdsNetworksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdsNetworks.
     */
    cursor?: AdsNetworksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdsNetworks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdsNetworks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdsNetworks.
     */
    distinct?: AdsNetworksScalarFieldEnum | AdsNetworksScalarFieldEnum[]
  }

  /**
   * AdsNetworks findFirstOrThrow
   */
  export type AdsNetworksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsNetworks
     */
    select?: AdsNetworksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsNetworks
     */
    omit?: AdsNetworksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsNetworksInclude<ExtArgs> | null
    /**
     * Filter, which AdsNetworks to fetch.
     */
    where?: AdsNetworksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdsNetworks to fetch.
     */
    orderBy?: AdsNetworksOrderByWithRelationInput | AdsNetworksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdsNetworks.
     */
    cursor?: AdsNetworksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdsNetworks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdsNetworks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdsNetworks.
     */
    distinct?: AdsNetworksScalarFieldEnum | AdsNetworksScalarFieldEnum[]
  }

  /**
   * AdsNetworks findMany
   */
  export type AdsNetworksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsNetworks
     */
    select?: AdsNetworksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsNetworks
     */
    omit?: AdsNetworksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsNetworksInclude<ExtArgs> | null
    /**
     * Filter, which AdsNetworks to fetch.
     */
    where?: AdsNetworksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdsNetworks to fetch.
     */
    orderBy?: AdsNetworksOrderByWithRelationInput | AdsNetworksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdsNetworks.
     */
    cursor?: AdsNetworksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdsNetworks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdsNetworks.
     */
    skip?: number
    distinct?: AdsNetworksScalarFieldEnum | AdsNetworksScalarFieldEnum[]
  }

  /**
   * AdsNetworks create
   */
  export type AdsNetworksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsNetworks
     */
    select?: AdsNetworksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsNetworks
     */
    omit?: AdsNetworksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsNetworksInclude<ExtArgs> | null
    /**
     * The data needed to create a AdsNetworks.
     */
    data: XOR<AdsNetworksCreateInput, AdsNetworksUncheckedCreateInput>
  }

  /**
   * AdsNetworks createMany
   */
  export type AdsNetworksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdsNetworks.
     */
    data: AdsNetworksCreateManyInput | AdsNetworksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdsNetworks createManyAndReturn
   */
  export type AdsNetworksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsNetworks
     */
    select?: AdsNetworksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdsNetworks
     */
    omit?: AdsNetworksOmit<ExtArgs> | null
    /**
     * The data used to create many AdsNetworks.
     */
    data: AdsNetworksCreateManyInput | AdsNetworksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdsNetworks update
   */
  export type AdsNetworksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsNetworks
     */
    select?: AdsNetworksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsNetworks
     */
    omit?: AdsNetworksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsNetworksInclude<ExtArgs> | null
    /**
     * The data needed to update a AdsNetworks.
     */
    data: XOR<AdsNetworksUpdateInput, AdsNetworksUncheckedUpdateInput>
    /**
     * Choose, which AdsNetworks to update.
     */
    where: AdsNetworksWhereUniqueInput
  }

  /**
   * AdsNetworks updateMany
   */
  export type AdsNetworksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdsNetworks.
     */
    data: XOR<AdsNetworksUpdateManyMutationInput, AdsNetworksUncheckedUpdateManyInput>
    /**
     * Filter which AdsNetworks to update
     */
    where?: AdsNetworksWhereInput
    /**
     * Limit how many AdsNetworks to update.
     */
    limit?: number
  }

  /**
   * AdsNetworks updateManyAndReturn
   */
  export type AdsNetworksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsNetworks
     */
    select?: AdsNetworksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdsNetworks
     */
    omit?: AdsNetworksOmit<ExtArgs> | null
    /**
     * The data used to update AdsNetworks.
     */
    data: XOR<AdsNetworksUpdateManyMutationInput, AdsNetworksUncheckedUpdateManyInput>
    /**
     * Filter which AdsNetworks to update
     */
    where?: AdsNetworksWhereInput
    /**
     * Limit how many AdsNetworks to update.
     */
    limit?: number
  }

  /**
   * AdsNetworks upsert
   */
  export type AdsNetworksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsNetworks
     */
    select?: AdsNetworksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsNetworks
     */
    omit?: AdsNetworksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsNetworksInclude<ExtArgs> | null
    /**
     * The filter to search for the AdsNetworks to update in case it exists.
     */
    where: AdsNetworksWhereUniqueInput
    /**
     * In case the AdsNetworks found by the `where` argument doesn't exist, create a new AdsNetworks with this data.
     */
    create: XOR<AdsNetworksCreateInput, AdsNetworksUncheckedCreateInput>
    /**
     * In case the AdsNetworks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdsNetworksUpdateInput, AdsNetworksUncheckedUpdateInput>
  }

  /**
   * AdsNetworks delete
   */
  export type AdsNetworksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsNetworks
     */
    select?: AdsNetworksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsNetworks
     */
    omit?: AdsNetworksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsNetworksInclude<ExtArgs> | null
    /**
     * Filter which AdsNetworks to delete.
     */
    where: AdsNetworksWhereUniqueInput
  }

  /**
   * AdsNetworks deleteMany
   */
  export type AdsNetworksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdsNetworks to delete
     */
    where?: AdsNetworksWhereInput
    /**
     * Limit how many AdsNetworks to delete.
     */
    limit?: number
  }

  /**
   * AdsNetworks.adsViews
   */
  export type AdsNetworks$adsViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsViews
     */
    select?: AdsViewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsViews
     */
    omit?: AdsViewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsViewsInclude<ExtArgs> | null
    where?: AdsViewsWhereInput
    orderBy?: AdsViewsOrderByWithRelationInput | AdsViewsOrderByWithRelationInput[]
    cursor?: AdsViewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdsViewsScalarFieldEnum | AdsViewsScalarFieldEnum[]
  }

  /**
   * AdsNetworks without action
   */
  export type AdsNetworksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsNetworks
     */
    select?: AdsNetworksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsNetworks
     */
    omit?: AdsNetworksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsNetworksInclude<ExtArgs> | null
  }


  /**
   * Model UserBalance
   */

  export type AggregateUserBalance = {
    _count: UserBalanceCountAggregateOutputType | null
    _avg: UserBalanceAvgAggregateOutputType | null
    _sum: UserBalanceSumAggregateOutputType | null
    _min: UserBalanceMinAggregateOutputType | null
    _max: UserBalanceMaxAggregateOutputType | null
  }

  export type UserBalanceAvgAggregateOutputType = {
    paymentBalance: number | null
    holdBalance: number | null
    totalEarnedWithdrawalBalance: number | null
    withdrawalBalance: number | null
  }

  export type UserBalanceSumAggregateOutputType = {
    paymentBalance: number | null
    holdBalance: number | null
    totalEarnedWithdrawalBalance: number | null
    withdrawalBalance: number | null
  }

  export type UserBalanceMinAggregateOutputType = {
    id: string | null
    paymentBalance: number | null
    holdBalance: number | null
    totalEarnedWithdrawalBalance: number | null
    withdrawalBalance: number | null
    isUseWithdrawalBalance: boolean | null
    updatedAt: Date | null
  }

  export type UserBalanceMaxAggregateOutputType = {
    id: string | null
    paymentBalance: number | null
    holdBalance: number | null
    totalEarnedWithdrawalBalance: number | null
    withdrawalBalance: number | null
    isUseWithdrawalBalance: boolean | null
    updatedAt: Date | null
  }

  export type UserBalanceCountAggregateOutputType = {
    id: number
    paymentBalance: number
    holdBalance: number
    totalEarnedWithdrawalBalance: number
    withdrawalBalance: number
    isUseWithdrawalBalance: number
    updatedAt: number
    _all: number
  }


  export type UserBalanceAvgAggregateInputType = {
    paymentBalance?: true
    holdBalance?: true
    totalEarnedWithdrawalBalance?: true
    withdrawalBalance?: true
  }

  export type UserBalanceSumAggregateInputType = {
    paymentBalance?: true
    holdBalance?: true
    totalEarnedWithdrawalBalance?: true
    withdrawalBalance?: true
  }

  export type UserBalanceMinAggregateInputType = {
    id?: true
    paymentBalance?: true
    holdBalance?: true
    totalEarnedWithdrawalBalance?: true
    withdrawalBalance?: true
    isUseWithdrawalBalance?: true
    updatedAt?: true
  }

  export type UserBalanceMaxAggregateInputType = {
    id?: true
    paymentBalance?: true
    holdBalance?: true
    totalEarnedWithdrawalBalance?: true
    withdrawalBalance?: true
    isUseWithdrawalBalance?: true
    updatedAt?: true
  }

  export type UserBalanceCountAggregateInputType = {
    id?: true
    paymentBalance?: true
    holdBalance?: true
    totalEarnedWithdrawalBalance?: true
    withdrawalBalance?: true
    isUseWithdrawalBalance?: true
    updatedAt?: true
    _all?: true
  }

  export type UserBalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBalance to aggregate.
     */
    where?: UserBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBalances to fetch.
     */
    orderBy?: UserBalanceOrderByWithRelationInput | UserBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBalances
    **/
    _count?: true | UserBalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserBalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserBalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBalanceMaxAggregateInputType
  }

  export type GetUserBalanceAggregateType<T extends UserBalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBalance[P]>
      : GetScalarType<T[P], AggregateUserBalance[P]>
  }




  export type UserBalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBalanceWhereInput
    orderBy?: UserBalanceOrderByWithAggregationInput | UserBalanceOrderByWithAggregationInput[]
    by: UserBalanceScalarFieldEnum[] | UserBalanceScalarFieldEnum
    having?: UserBalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBalanceCountAggregateInputType | true
    _avg?: UserBalanceAvgAggregateInputType
    _sum?: UserBalanceSumAggregateInputType
    _min?: UserBalanceMinAggregateInputType
    _max?: UserBalanceMaxAggregateInputType
  }

  export type UserBalanceGroupByOutputType = {
    id: string
    paymentBalance: number
    holdBalance: number
    totalEarnedWithdrawalBalance: number
    withdrawalBalance: number
    isUseWithdrawalBalance: boolean
    updatedAt: Date
    _count: UserBalanceCountAggregateOutputType | null
    _avg: UserBalanceAvgAggregateOutputType | null
    _sum: UserBalanceSumAggregateOutputType | null
    _min: UserBalanceMinAggregateOutputType | null
    _max: UserBalanceMaxAggregateOutputType | null
  }

  type GetUserBalanceGroupByPayload<T extends UserBalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBalanceGroupByOutputType[P]>
            : GetScalarType<T[P], UserBalanceGroupByOutputType[P]>
        }
      >
    >


  export type UserBalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentBalance?: boolean
    holdBalance?: boolean
    totalEarnedWithdrawalBalance?: boolean
    withdrawalBalance?: boolean
    isUseWithdrawalBalance?: boolean
    updatedAt?: boolean
    user?: boolean | UserBalance$userArgs<ExtArgs>
    transactions?: boolean | UserBalance$transactionsArgs<ExtArgs>
    _count?: boolean | UserBalanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBalance"]>

  export type UserBalanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentBalance?: boolean
    holdBalance?: boolean
    totalEarnedWithdrawalBalance?: boolean
    withdrawalBalance?: boolean
    isUseWithdrawalBalance?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userBalance"]>

  export type UserBalanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentBalance?: boolean
    holdBalance?: boolean
    totalEarnedWithdrawalBalance?: boolean
    withdrawalBalance?: boolean
    isUseWithdrawalBalance?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userBalance"]>

  export type UserBalanceSelectScalar = {
    id?: boolean
    paymentBalance?: boolean
    holdBalance?: boolean
    totalEarnedWithdrawalBalance?: boolean
    withdrawalBalance?: boolean
    isUseWithdrawalBalance?: boolean
    updatedAt?: boolean
  }

  export type UserBalanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentBalance" | "holdBalance" | "totalEarnedWithdrawalBalance" | "withdrawalBalance" | "isUseWithdrawalBalance" | "updatedAt", ExtArgs["result"]["userBalance"]>
  export type UserBalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserBalance$userArgs<ExtArgs>
    transactions?: boolean | UserBalance$transactionsArgs<ExtArgs>
    _count?: boolean | UserBalanceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserBalanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserBalanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserBalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBalance"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs> | null
      transactions: Prisma.$TransactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentBalance: number
      holdBalance: number
      totalEarnedWithdrawalBalance: number
      withdrawalBalance: number
      isUseWithdrawalBalance: boolean
      updatedAt: Date
    }, ExtArgs["result"]["userBalance"]>
    composites: {}
  }

  type UserBalanceGetPayload<S extends boolean | null | undefined | UserBalanceDefaultArgs> = $Result.GetResult<Prisma.$UserBalancePayload, S>

  type UserBalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserBalanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserBalanceCountAggregateInputType | true
    }

  export interface UserBalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBalance'], meta: { name: 'UserBalance' } }
    /**
     * Find zero or one UserBalance that matches the filter.
     * @param {UserBalanceFindUniqueArgs} args - Arguments to find a UserBalance
     * @example
     * // Get one UserBalance
     * const userBalance = await prisma.userBalance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBalanceFindUniqueArgs>(args: SelectSubset<T, UserBalanceFindUniqueArgs<ExtArgs>>): Prisma__UserBalanceClient<$Result.GetResult<Prisma.$UserBalancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserBalance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserBalanceFindUniqueOrThrowArgs} args - Arguments to find a UserBalance
     * @example
     * // Get one UserBalance
     * const userBalance = await prisma.userBalance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBalanceFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBalanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBalanceClient<$Result.GetResult<Prisma.$UserBalancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBalance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBalanceFindFirstArgs} args - Arguments to find a UserBalance
     * @example
     * // Get one UserBalance
     * const userBalance = await prisma.userBalance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBalanceFindFirstArgs>(args?: SelectSubset<T, UserBalanceFindFirstArgs<ExtArgs>>): Prisma__UserBalanceClient<$Result.GetResult<Prisma.$UserBalancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBalance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBalanceFindFirstOrThrowArgs} args - Arguments to find a UserBalance
     * @example
     * // Get one UserBalance
     * const userBalance = await prisma.userBalance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBalanceFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBalanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBalanceClient<$Result.GetResult<Prisma.$UserBalancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserBalances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBalanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBalances
     * const userBalances = await prisma.userBalance.findMany()
     * 
     * // Get first 10 UserBalances
     * const userBalances = await prisma.userBalance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBalanceWithIdOnly = await prisma.userBalance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserBalanceFindManyArgs>(args?: SelectSubset<T, UserBalanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserBalance.
     * @param {UserBalanceCreateArgs} args - Arguments to create a UserBalance.
     * @example
     * // Create one UserBalance
     * const UserBalance = await prisma.userBalance.create({
     *   data: {
     *     // ... data to create a UserBalance
     *   }
     * })
     * 
     */
    create<T extends UserBalanceCreateArgs>(args: SelectSubset<T, UserBalanceCreateArgs<ExtArgs>>): Prisma__UserBalanceClient<$Result.GetResult<Prisma.$UserBalancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserBalances.
     * @param {UserBalanceCreateManyArgs} args - Arguments to create many UserBalances.
     * @example
     * // Create many UserBalances
     * const userBalance = await prisma.userBalance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBalanceCreateManyArgs>(args?: SelectSubset<T, UserBalanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserBalances and returns the data saved in the database.
     * @param {UserBalanceCreateManyAndReturnArgs} args - Arguments to create many UserBalances.
     * @example
     * // Create many UserBalances
     * const userBalance = await prisma.userBalance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserBalances and only return the `id`
     * const userBalanceWithIdOnly = await prisma.userBalance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserBalanceCreateManyAndReturnArgs>(args?: SelectSubset<T, UserBalanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBalancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserBalance.
     * @param {UserBalanceDeleteArgs} args - Arguments to delete one UserBalance.
     * @example
     * // Delete one UserBalance
     * const UserBalance = await prisma.userBalance.delete({
     *   where: {
     *     // ... filter to delete one UserBalance
     *   }
     * })
     * 
     */
    delete<T extends UserBalanceDeleteArgs>(args: SelectSubset<T, UserBalanceDeleteArgs<ExtArgs>>): Prisma__UserBalanceClient<$Result.GetResult<Prisma.$UserBalancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserBalance.
     * @param {UserBalanceUpdateArgs} args - Arguments to update one UserBalance.
     * @example
     * // Update one UserBalance
     * const userBalance = await prisma.userBalance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBalanceUpdateArgs>(args: SelectSubset<T, UserBalanceUpdateArgs<ExtArgs>>): Prisma__UserBalanceClient<$Result.GetResult<Prisma.$UserBalancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserBalances.
     * @param {UserBalanceDeleteManyArgs} args - Arguments to filter UserBalances to delete.
     * @example
     * // Delete a few UserBalances
     * const { count } = await prisma.userBalance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBalanceDeleteManyArgs>(args?: SelectSubset<T, UserBalanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBalances
     * const userBalance = await prisma.userBalance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBalanceUpdateManyArgs>(args: SelectSubset<T, UserBalanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBalances and returns the data updated in the database.
     * @param {UserBalanceUpdateManyAndReturnArgs} args - Arguments to update many UserBalances.
     * @example
     * // Update many UserBalances
     * const userBalance = await prisma.userBalance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserBalances and only return the `id`
     * const userBalanceWithIdOnly = await prisma.userBalance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserBalanceUpdateManyAndReturnArgs>(args: SelectSubset<T, UserBalanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBalancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserBalance.
     * @param {UserBalanceUpsertArgs} args - Arguments to update or create a UserBalance.
     * @example
     * // Update or create a UserBalance
     * const userBalance = await prisma.userBalance.upsert({
     *   create: {
     *     // ... data to create a UserBalance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBalance we want to update
     *   }
     * })
     */
    upsert<T extends UserBalanceUpsertArgs>(args: SelectSubset<T, UserBalanceUpsertArgs<ExtArgs>>): Prisma__UserBalanceClient<$Result.GetResult<Prisma.$UserBalancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBalanceCountArgs} args - Arguments to filter UserBalances to count.
     * @example
     * // Count the number of UserBalances
     * const count = await prisma.userBalance.count({
     *   where: {
     *     // ... the filter for the UserBalances we want to count
     *   }
     * })
    **/
    count<T extends UserBalanceCountArgs>(
      args?: Subset<T, UserBalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBalanceAggregateArgs>(args: Subset<T, UserBalanceAggregateArgs>): Prisma.PrismaPromise<GetUserBalanceAggregateType<T>>

    /**
     * Group by UserBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBalanceGroupByArgs['orderBy'] }
        : { orderBy?: UserBalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBalance model
   */
  readonly fields: UserBalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBalance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserBalance$userArgs<ExtArgs> = {}>(args?: Subset<T, UserBalance$userArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transactions<T extends UserBalance$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, UserBalance$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBalance model
   */ 
  interface UserBalanceFieldRefs {
    readonly id: FieldRef<"UserBalance", 'String'>
    readonly paymentBalance: FieldRef<"UserBalance", 'Float'>
    readonly holdBalance: FieldRef<"UserBalance", 'Float'>
    readonly totalEarnedWithdrawalBalance: FieldRef<"UserBalance", 'Float'>
    readonly withdrawalBalance: FieldRef<"UserBalance", 'Float'>
    readonly isUseWithdrawalBalance: FieldRef<"UserBalance", 'Boolean'>
    readonly updatedAt: FieldRef<"UserBalance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserBalance findUnique
   */
  export type UserBalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBalance
     */
    select?: UserBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBalance
     */
    omit?: UserBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBalanceInclude<ExtArgs> | null
    /**
     * Filter, which UserBalance to fetch.
     */
    where: UserBalanceWhereUniqueInput
  }

  /**
   * UserBalance findUniqueOrThrow
   */
  export type UserBalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBalance
     */
    select?: UserBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBalance
     */
    omit?: UserBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBalanceInclude<ExtArgs> | null
    /**
     * Filter, which UserBalance to fetch.
     */
    where: UserBalanceWhereUniqueInput
  }

  /**
   * UserBalance findFirst
   */
  export type UserBalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBalance
     */
    select?: UserBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBalance
     */
    omit?: UserBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBalanceInclude<ExtArgs> | null
    /**
     * Filter, which UserBalance to fetch.
     */
    where?: UserBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBalances to fetch.
     */
    orderBy?: UserBalanceOrderByWithRelationInput | UserBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBalances.
     */
    cursor?: UserBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBalances.
     */
    distinct?: UserBalanceScalarFieldEnum | UserBalanceScalarFieldEnum[]
  }

  /**
   * UserBalance findFirstOrThrow
   */
  export type UserBalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBalance
     */
    select?: UserBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBalance
     */
    omit?: UserBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBalanceInclude<ExtArgs> | null
    /**
     * Filter, which UserBalance to fetch.
     */
    where?: UserBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBalances to fetch.
     */
    orderBy?: UserBalanceOrderByWithRelationInput | UserBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBalances.
     */
    cursor?: UserBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBalances.
     */
    distinct?: UserBalanceScalarFieldEnum | UserBalanceScalarFieldEnum[]
  }

  /**
   * UserBalance findMany
   */
  export type UserBalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBalance
     */
    select?: UserBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBalance
     */
    omit?: UserBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBalanceInclude<ExtArgs> | null
    /**
     * Filter, which UserBalances to fetch.
     */
    where?: UserBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBalances to fetch.
     */
    orderBy?: UserBalanceOrderByWithRelationInput | UserBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBalances.
     */
    cursor?: UserBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBalances.
     */
    skip?: number
    distinct?: UserBalanceScalarFieldEnum | UserBalanceScalarFieldEnum[]
  }

  /**
   * UserBalance create
   */
  export type UserBalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBalance
     */
    select?: UserBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBalance
     */
    omit?: UserBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBalance.
     */
    data: XOR<UserBalanceCreateInput, UserBalanceUncheckedCreateInput>
  }

  /**
   * UserBalance createMany
   */
  export type UserBalanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBalances.
     */
    data: UserBalanceCreateManyInput | UserBalanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserBalance createManyAndReturn
   */
  export type UserBalanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBalance
     */
    select?: UserBalanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBalance
     */
    omit?: UserBalanceOmit<ExtArgs> | null
    /**
     * The data used to create many UserBalances.
     */
    data: UserBalanceCreateManyInput | UserBalanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserBalance update
   */
  export type UserBalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBalance
     */
    select?: UserBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBalance
     */
    omit?: UserBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBalance.
     */
    data: XOR<UserBalanceUpdateInput, UserBalanceUncheckedUpdateInput>
    /**
     * Choose, which UserBalance to update.
     */
    where: UserBalanceWhereUniqueInput
  }

  /**
   * UserBalance updateMany
   */
  export type UserBalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBalances.
     */
    data: XOR<UserBalanceUpdateManyMutationInput, UserBalanceUncheckedUpdateManyInput>
    /**
     * Filter which UserBalances to update
     */
    where?: UserBalanceWhereInput
    /**
     * Limit how many UserBalances to update.
     */
    limit?: number
  }

  /**
   * UserBalance updateManyAndReturn
   */
  export type UserBalanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBalance
     */
    select?: UserBalanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBalance
     */
    omit?: UserBalanceOmit<ExtArgs> | null
    /**
     * The data used to update UserBalances.
     */
    data: XOR<UserBalanceUpdateManyMutationInput, UserBalanceUncheckedUpdateManyInput>
    /**
     * Filter which UserBalances to update
     */
    where?: UserBalanceWhereInput
    /**
     * Limit how many UserBalances to update.
     */
    limit?: number
  }

  /**
   * UserBalance upsert
   */
  export type UserBalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBalance
     */
    select?: UserBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBalance
     */
    omit?: UserBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBalance to update in case it exists.
     */
    where: UserBalanceWhereUniqueInput
    /**
     * In case the UserBalance found by the `where` argument doesn't exist, create a new UserBalance with this data.
     */
    create: XOR<UserBalanceCreateInput, UserBalanceUncheckedCreateInput>
    /**
     * In case the UserBalance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBalanceUpdateInput, UserBalanceUncheckedUpdateInput>
  }

  /**
   * UserBalance delete
   */
  export type UserBalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBalance
     */
    select?: UserBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBalance
     */
    omit?: UserBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBalanceInclude<ExtArgs> | null
    /**
     * Filter which UserBalance to delete.
     */
    where: UserBalanceWhereUniqueInput
  }

  /**
   * UserBalance deleteMany
   */
  export type UserBalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBalances to delete
     */
    where?: UserBalanceWhereInput
    /**
     * Limit how many UserBalances to delete.
     */
    limit?: number
  }

  /**
   * UserBalance.user
   */
  export type UserBalance$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
  }

  /**
   * UserBalance.transactions
   */
  export type UserBalance$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    where?: TransactionsWhereInput
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    cursor?: TransactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * UserBalance without action
   */
  export type UserBalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBalance
     */
    select?: UserBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBalance
     */
    omit?: UserBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBalanceInclude<ExtArgs> | null
  }


  /**
   * Model Subscriptions
   */

  export type AggregateSubscriptions = {
    _count: SubscriptionsCountAggregateOutputType | null
    _min: SubscriptionsMinAggregateOutputType | null
    _max: SubscriptionsMaxAggregateOutputType | null
  }

  export type SubscriptionsMinAggregateOutputType = {
    id: string | null
    username: string | null
    isActive: boolean | null
    isAutoRenewal: boolean | null
    token: string | null
    period: $Enums.SubscriptionPeriodEnum | null
    createdAt: Date | null
    updatedAt: Date | null
    expiredAt: Date | null
    userId: string | null
  }

  export type SubscriptionsMaxAggregateOutputType = {
    id: string | null
    username: string | null
    isActive: boolean | null
    isAutoRenewal: boolean | null
    token: string | null
    period: $Enums.SubscriptionPeriodEnum | null
    createdAt: Date | null
    updatedAt: Date | null
    expiredAt: Date | null
    userId: string | null
  }

  export type SubscriptionsCountAggregateOutputType = {
    id: number
    username: number
    isActive: number
    isAutoRenewal: number
    token: number
    period: number
    createdAt: number
    updatedAt: number
    expiredAt: number
    userId: number
    _all: number
  }


  export type SubscriptionsMinAggregateInputType = {
    id?: true
    username?: true
    isActive?: true
    isAutoRenewal?: true
    token?: true
    period?: true
    createdAt?: true
    updatedAt?: true
    expiredAt?: true
    userId?: true
  }

  export type SubscriptionsMaxAggregateInputType = {
    id?: true
    username?: true
    isActive?: true
    isAutoRenewal?: true
    token?: true
    period?: true
    createdAt?: true
    updatedAt?: true
    expiredAt?: true
    userId?: true
  }

  export type SubscriptionsCountAggregateInputType = {
    id?: true
    username?: true
    isActive?: true
    isAutoRenewal?: true
    token?: true
    period?: true
    createdAt?: true
    updatedAt?: true
    expiredAt?: true
    userId?: true
    _all?: true
  }

  export type SubscriptionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to aggregate.
     */
    where?: SubscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionsOrderByWithRelationInput | SubscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionsMaxAggregateInputType
  }

  export type GetSubscriptionsAggregateType<T extends SubscriptionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptions[P]>
      : GetScalarType<T[P], AggregateSubscriptions[P]>
  }




  export type SubscriptionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionsWhereInput
    orderBy?: SubscriptionsOrderByWithAggregationInput | SubscriptionsOrderByWithAggregationInput[]
    by: SubscriptionsScalarFieldEnum[] | SubscriptionsScalarFieldEnum
    having?: SubscriptionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionsCountAggregateInputType | true
    _min?: SubscriptionsMinAggregateInputType
    _max?: SubscriptionsMaxAggregateInputType
  }

  export type SubscriptionsGroupByOutputType = {
    id: string
    username: string
    isActive: boolean
    isAutoRenewal: boolean
    token: string
    period: $Enums.SubscriptionPeriodEnum
    createdAt: Date
    updatedAt: Date
    expiredAt: Date | null
    userId: string
    _count: SubscriptionsCountAggregateOutputType | null
    _min: SubscriptionsMinAggregateOutputType | null
    _max: SubscriptionsMaxAggregateOutputType | null
  }

  type GetSubscriptionsGroupByPayload<T extends SubscriptionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    isActive?: boolean
    isAutoRenewal?: boolean
    token?: boolean
    period?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiredAt?: boolean
    userId?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    payments?: boolean | Subscriptions$paymentsArgs<ExtArgs>
    _count?: boolean | SubscriptionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptions"]>

  export type SubscriptionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    isActive?: boolean
    isAutoRenewal?: boolean
    token?: boolean
    period?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiredAt?: boolean
    userId?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptions"]>

  export type SubscriptionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    isActive?: boolean
    isAutoRenewal?: boolean
    token?: boolean
    period?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiredAt?: boolean
    userId?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptions"]>

  export type SubscriptionsSelectScalar = {
    id?: boolean
    username?: boolean
    isActive?: boolean
    isAutoRenewal?: boolean
    token?: boolean
    period?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiredAt?: boolean
    userId?: boolean
  }

  export type SubscriptionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "isActive" | "isAutoRenewal" | "token" | "period" | "createdAt" | "updatedAt" | "expiredAt" | "userId", ExtArgs["result"]["subscriptions"]>
  export type SubscriptionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    payments?: boolean | Subscriptions$paymentsArgs<ExtArgs>
    _count?: boolean | SubscriptionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type SubscriptionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $SubscriptionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscriptions"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      payments: Prisma.$PaymentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      isActive: boolean
      isAutoRenewal: boolean
      token: string
      period: $Enums.SubscriptionPeriodEnum
      createdAt: Date
      updatedAt: Date
      expiredAt: Date | null
      userId: string
    }, ExtArgs["result"]["subscriptions"]>
    composites: {}
  }

  type SubscriptionsGetPayload<S extends boolean | null | undefined | SubscriptionsDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionsPayload, S>

  type SubscriptionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionsCountAggregateInputType | true
    }

  export interface SubscriptionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscriptions'], meta: { name: 'Subscriptions' } }
    /**
     * Find zero or one Subscriptions that matches the filter.
     * @param {SubscriptionsFindUniqueArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionsFindUniqueArgs>(args: SelectSubset<T, SubscriptionsFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscriptions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionsFindUniqueOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionsFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsFindFirstArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionsFindFirstArgs>(args?: SelectSubset<T, SubscriptionsFindFirstArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscriptions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsFindFirstOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionsFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionsWithIdOnly = await prisma.subscriptions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionsFindManyArgs>(args?: SelectSubset<T, SubscriptionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscriptions.
     * @param {SubscriptionsCreateArgs} args - Arguments to create a Subscriptions.
     * @example
     * // Create one Subscriptions
     * const Subscriptions = await prisma.subscriptions.create({
     *   data: {
     *     // ... data to create a Subscriptions
     *   }
     * })
     * 
     */
    create<T extends SubscriptionsCreateArgs>(args: SelectSubset<T, SubscriptionsCreateArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionsCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscriptions = await prisma.subscriptions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionsCreateManyArgs>(args?: SelectSubset<T, SubscriptionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionsCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscriptions = await prisma.subscriptions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionsWithIdOnly = await prisma.subscriptions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionsCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscriptions.
     * @param {SubscriptionsDeleteArgs} args - Arguments to delete one Subscriptions.
     * @example
     * // Delete one Subscriptions
     * const Subscriptions = await prisma.subscriptions.delete({
     *   where: {
     *     // ... filter to delete one Subscriptions
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionsDeleteArgs>(args: SelectSubset<T, SubscriptionsDeleteArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscriptions.
     * @param {SubscriptionsUpdateArgs} args - Arguments to update one Subscriptions.
     * @example
     * // Update one Subscriptions
     * const subscriptions = await prisma.subscriptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionsUpdateArgs>(args: SelectSubset<T, SubscriptionsUpdateArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionsDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscriptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionsDeleteManyArgs>(args?: SelectSubset<T, SubscriptionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscriptions = await prisma.subscriptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionsUpdateManyArgs>(args: SelectSubset<T, SubscriptionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionsUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscriptions = await prisma.subscriptions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionsWithIdOnly = await prisma.subscriptions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionsUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscriptions.
     * @param {SubscriptionsUpsertArgs} args - Arguments to update or create a Subscriptions.
     * @example
     * // Update or create a Subscriptions
     * const subscriptions = await prisma.subscriptions.upsert({
     *   create: {
     *     // ... data to create a Subscriptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscriptions we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionsUpsertArgs>(args: SelectSubset<T, SubscriptionsUpsertArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscriptions.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionsCountArgs>(
      args?: Subset<T, SubscriptionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionsAggregateArgs>(args: Subset<T, SubscriptionsAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionsAggregateType<T>>

    /**
     * Group by Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionsGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscriptions model
   */
  readonly fields: SubscriptionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscriptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends Subscriptions$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Subscriptions$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscriptions model
   */ 
  interface SubscriptionsFieldRefs {
    readonly id: FieldRef<"Subscriptions", 'String'>
    readonly username: FieldRef<"Subscriptions", 'String'>
    readonly isActive: FieldRef<"Subscriptions", 'Boolean'>
    readonly isAutoRenewal: FieldRef<"Subscriptions", 'Boolean'>
    readonly token: FieldRef<"Subscriptions", 'String'>
    readonly period: FieldRef<"Subscriptions", 'SubscriptionPeriodEnum'>
    readonly createdAt: FieldRef<"Subscriptions", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscriptions", 'DateTime'>
    readonly expiredAt: FieldRef<"Subscriptions", 'DateTime'>
    readonly userId: FieldRef<"Subscriptions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Subscriptions findUnique
   */
  export type SubscriptionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where: SubscriptionsWhereUniqueInput
  }

  /**
   * Subscriptions findUniqueOrThrow
   */
  export type SubscriptionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where: SubscriptionsWhereUniqueInput
  }

  /**
   * Subscriptions findFirst
   */
  export type SubscriptionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionsOrderByWithRelationInput | SubscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * Subscriptions findFirstOrThrow
   */
  export type SubscriptionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionsOrderByWithRelationInput | SubscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * Subscriptions findMany
   */
  export type SubscriptionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionsOrderByWithRelationInput | SubscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * Subscriptions create
   */
  export type SubscriptionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscriptions.
     */
    data: XOR<SubscriptionsCreateInput, SubscriptionsUncheckedCreateInput>
  }

  /**
   * Subscriptions createMany
   */
  export type SubscriptionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionsCreateManyInput | SubscriptionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscriptions createManyAndReturn
   */
  export type SubscriptionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionsCreateManyInput | SubscriptionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscriptions update
   */
  export type SubscriptionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscriptions.
     */
    data: XOR<SubscriptionsUpdateInput, SubscriptionsUncheckedUpdateInput>
    /**
     * Choose, which Subscriptions to update.
     */
    where: SubscriptionsWhereUniqueInput
  }

  /**
   * Subscriptions updateMany
   */
  export type SubscriptionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionsUpdateManyMutationInput, SubscriptionsUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionsWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscriptions updateManyAndReturn
   */
  export type SubscriptionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionsUpdateManyMutationInput, SubscriptionsUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionsWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscriptions upsert
   */
  export type SubscriptionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscriptions to update in case it exists.
     */
    where: SubscriptionsWhereUniqueInput
    /**
     * In case the Subscriptions found by the `where` argument doesn't exist, create a new Subscriptions with this data.
     */
    create: XOR<SubscriptionsCreateInput, SubscriptionsUncheckedCreateInput>
    /**
     * In case the Subscriptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionsUpdateInput, SubscriptionsUncheckedUpdateInput>
  }

  /**
   * Subscriptions delete
   */
  export type SubscriptionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter which Subscriptions to delete.
     */
    where: SubscriptionsWhereUniqueInput
  }

  /**
   * Subscriptions deleteMany
   */
  export type SubscriptionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionsWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscriptions.payments
   */
  export type Subscriptions$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    where?: PaymentsWhereInput
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    cursor?: PaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Subscriptions without action
   */
  export type SubscriptionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
  }


  /**
   * Model Roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    discount: number | null
    limitSubscriptions: number | null
  }

  export type RolesSumAggregateOutputType = {
    discount: number | null
    limitSubscriptions: number | null
  }

  export type RolesMinAggregateOutputType = {
    key: $Enums.UserRoleEnum | null
    name: string | null
    discount: number | null
    limitSubscriptions: number | null
  }

  export type RolesMaxAggregateOutputType = {
    key: $Enums.UserRoleEnum | null
    name: string | null
    discount: number | null
    limitSubscriptions: number | null
  }

  export type RolesCountAggregateOutputType = {
    key: number
    name: number
    discount: number
    limitSubscriptions: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    discount?: true
    limitSubscriptions?: true
  }

  export type RolesSumAggregateInputType = {
    discount?: true
    limitSubscriptions?: true
  }

  export type RolesMinAggregateInputType = {
    key?: true
    name?: true
    discount?: true
    limitSubscriptions?: true
  }

  export type RolesMaxAggregateInputType = {
    key?: true
    name?: true
    discount?: true
    limitSubscriptions?: true
  }

  export type RolesCountAggregateInputType = {
    key?: true
    name?: true
    discount?: true
    limitSubscriptions?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to aggregate.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type RolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolesWhereInput
    orderBy?: RolesOrderByWithAggregationInput | RolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: RolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    key: $Enums.UserRoleEnum
    name: string
    discount: number
    limitSubscriptions: number
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends RolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type RolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    name?: boolean
    discount?: boolean
    limitSubscriptions?: boolean
    users?: boolean | Roles$usersArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>

  export type RolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    name?: boolean
    discount?: boolean
    limitSubscriptions?: boolean
  }, ExtArgs["result"]["roles"]>

  export type RolesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    name?: boolean
    discount?: boolean
    limitSubscriptions?: boolean
  }, ExtArgs["result"]["roles"]>

  export type RolesSelectScalar = {
    key?: boolean
    name?: boolean
    discount?: boolean
    limitSubscriptions?: boolean
  }

  export type RolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "name" | "discount" | "limitSubscriptions", ExtArgs["result"]["roles"]>
  export type RolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Roles$usersArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RolesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Roles"
    objects: {
      users: Prisma.$UsersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      key: $Enums.UserRoleEnum
      name: string
      discount: number
      limitSubscriptions: number
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type RolesGetPayload<S extends boolean | null | undefined | RolesDefaultArgs> = $Result.GetResult<Prisma.$RolesPayload, S>

  type RolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface RolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Roles'], meta: { name: 'Roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {RolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolesFindUniqueArgs>(args: SelectSubset<T, RolesFindUniqueArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolesFindUniqueOrThrowArgs>(args: SelectSubset<T, RolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolesFindFirstArgs>(args?: SelectSubset<T, RolesFindFirstArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolesFindFirstOrThrowArgs>(args?: SelectSubset<T, RolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const rolesWithNameOnly = await prisma.roles.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends RolesFindManyArgs>(args?: SelectSubset<T, RolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Roles.
     * @param {RolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends RolesCreateArgs>(args: SelectSubset<T, RolesCreateArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolesCreateManyArgs>(args?: SelectSubset<T, RolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RolesCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `name`
     * const rolesWithNameOnly = await prisma.roles.createManyAndReturn({
     *   select: { name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolesCreateManyAndReturnArgs>(args?: SelectSubset<T, RolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Roles.
     * @param {RolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends RolesDeleteArgs>(args: SelectSubset<T, RolesDeleteArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Roles.
     * @param {RolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolesUpdateArgs>(args: SelectSubset<T, RolesUpdateArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolesDeleteManyArgs>(args?: SelectSubset<T, RolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolesUpdateManyArgs>(args: SelectSubset<T, RolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RolesUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `name`
     * const rolesWithNameOnly = await prisma.roles.updateManyAndReturn({
     *   select: { name: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolesUpdateManyAndReturnArgs>(args: SelectSubset<T, RolesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Roles.
     * @param {RolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends RolesUpsertArgs>(args: SelectSubset<T, RolesUpsertArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RolesCountArgs>(
      args?: Subset<T, RolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolesGroupByArgs['orderBy'] }
        : { orderBy?: RolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Roles model
   */
  readonly fields: RolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Roles$usersArgs<ExtArgs> = {}>(args?: Subset<T, Roles$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Roles model
   */ 
  interface RolesFieldRefs {
    readonly key: FieldRef<"Roles", 'UserRoleEnum'>
    readonly name: FieldRef<"Roles", 'String'>
    readonly discount: FieldRef<"Roles", 'Float'>
    readonly limitSubscriptions: FieldRef<"Roles", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Roles findUnique
   */
  export type RolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles findUniqueOrThrow
   */
  export type RolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles findFirst
   */
  export type RolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles findFirstOrThrow
   */
  export type RolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles findMany
   */
  export type RolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles create
   */
  export type RolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The data needed to create a Roles.
     */
    data: XOR<RolesCreateInput, RolesUncheckedCreateInput>
  }

  /**
   * Roles createMany
   */
  export type RolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RolesCreateManyInput | RolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Roles createManyAndReturn
   */
  export type RolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RolesCreateManyInput | RolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Roles update
   */
  export type RolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The data needed to update a Roles.
     */
    data: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
    /**
     * Choose, which Roles to update.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles updateMany
   */
  export type RolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RolesUpdateManyMutationInput, RolesUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RolesWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Roles updateManyAndReturn
   */
  export type RolesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RolesUpdateManyMutationInput, RolesUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RolesWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Roles upsert
   */
  export type RolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The filter to search for the Roles to update in case it exists.
     */
    where: RolesWhereUniqueInput
    /**
     * In case the Roles found by the `where` argument doesn't exist, create a new Roles with this data.
     */
    create: XOR<RolesCreateInput, RolesUncheckedCreateInput>
    /**
     * In case the Roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
  }

  /**
   * Roles delete
   */
  export type RolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter which Roles to delete.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles deleteMany
   */
  export type RolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RolesWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Roles.users
   */
  export type Roles$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    cursor?: UsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Roles without action
   */
  export type RolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
  }


  /**
   * Model Language
   */

  export type AggregateLanguage = {
    _count: LanguageCountAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  export type LanguageMinAggregateOutputType = {
    id: string | null
    name: string | null
    nativeName: string | null
    iso6391: string | null
    iso6392: string | null
    iso6393: string | null
  }

  export type LanguageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    nativeName: string | null
    iso6391: string | null
    iso6392: string | null
    iso6393: string | null
  }

  export type LanguageCountAggregateOutputType = {
    id: number
    name: number
    nativeName: number
    iso6391: number
    iso6392: number
    iso6393: number
    _all: number
  }


  export type LanguageMinAggregateInputType = {
    id?: true
    name?: true
    nativeName?: true
    iso6391?: true
    iso6392?: true
    iso6393?: true
  }

  export type LanguageMaxAggregateInputType = {
    id?: true
    name?: true
    nativeName?: true
    iso6391?: true
    iso6392?: true
    iso6393?: true
  }

  export type LanguageCountAggregateInputType = {
    id?: true
    name?: true
    nativeName?: true
    iso6391?: true
    iso6392?: true
    iso6393?: true
    _all?: true
  }

  export type LanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Language to aggregate.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Languages
    **/
    _count?: true | LanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageMaxAggregateInputType
  }

  export type GetLanguageAggregateType<T extends LanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage[P]>
      : GetScalarType<T[P], AggregateLanguage[P]>
  }




  export type LanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageWhereInput
    orderBy?: LanguageOrderByWithAggregationInput | LanguageOrderByWithAggregationInput[]
    by: LanguageScalarFieldEnum[] | LanguageScalarFieldEnum
    having?: LanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageCountAggregateInputType | true
    _min?: LanguageMinAggregateInputType
    _max?: LanguageMaxAggregateInputType
  }

  export type LanguageGroupByOutputType = {
    id: string
    name: string
    nativeName: string
    iso6391: string
    iso6392: string
    iso6393: string
    _count: LanguageCountAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  type GetLanguageGroupByPayload<T extends LanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageGroupByOutputType[P]>
        }
      >
    >


  export type LanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nativeName?: boolean
    iso6391?: boolean
    iso6392?: boolean
    iso6393?: boolean
    users?: boolean | Language$usersArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nativeName?: boolean
    iso6391?: boolean
    iso6392?: boolean
    iso6393?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nativeName?: boolean
    iso6391?: boolean
    iso6392?: boolean
    iso6393?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectScalar = {
    id?: boolean
    name?: boolean
    nativeName?: boolean
    iso6391?: boolean
    iso6392?: boolean
    iso6393?: boolean
  }

  export type LanguageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "nativeName" | "iso6391" | "iso6392" | "iso6393", ExtArgs["result"]["language"]>
  export type LanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Language$usersArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LanguageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LanguageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Language"
    objects: {
      users: Prisma.$UsersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      nativeName: string
      iso6391: string
      iso6392: string
      iso6393: string
    }, ExtArgs["result"]["language"]>
    composites: {}
  }

  type LanguageGetPayload<S extends boolean | null | undefined | LanguageDefaultArgs> = $Result.GetResult<Prisma.$LanguagePayload, S>

  type LanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LanguageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LanguageCountAggregateInputType | true
    }

  export interface LanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Language'], meta: { name: 'Language' } }
    /**
     * Find zero or one Language that matches the filter.
     * @param {LanguageFindUniqueArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LanguageFindUniqueArgs>(args: SelectSubset<T, LanguageFindUniqueArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Language that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LanguageFindUniqueOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, LanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LanguageFindFirstArgs>(args?: SelectSubset<T, LanguageFindFirstArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Language that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, LanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.language.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.language.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const languageWithIdOnly = await prisma.language.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LanguageFindManyArgs>(args?: SelectSubset<T, LanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Language.
     * @param {LanguageCreateArgs} args - Arguments to create a Language.
     * @example
     * // Create one Language
     * const Language = await prisma.language.create({
     *   data: {
     *     // ... data to create a Language
     *   }
     * })
     * 
     */
    create<T extends LanguageCreateArgs>(args: SelectSubset<T, LanguageCreateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Languages.
     * @param {LanguageCreateManyArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LanguageCreateManyArgs>(args?: SelectSubset<T, LanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Languages and returns the data saved in the database.
     * @param {LanguageCreateManyAndReturnArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Languages and only return the `id`
     * const languageWithIdOnly = await prisma.language.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LanguageCreateManyAndReturnArgs>(args?: SelectSubset<T, LanguageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Language.
     * @param {LanguageDeleteArgs} args - Arguments to delete one Language.
     * @example
     * // Delete one Language
     * const Language = await prisma.language.delete({
     *   where: {
     *     // ... filter to delete one Language
     *   }
     * })
     * 
     */
    delete<T extends LanguageDeleteArgs>(args: SelectSubset<T, LanguageDeleteArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Language.
     * @param {LanguageUpdateArgs} args - Arguments to update one Language.
     * @example
     * // Update one Language
     * const language = await prisma.language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LanguageUpdateArgs>(args: SelectSubset<T, LanguageUpdateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Languages.
     * @param {LanguageDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LanguageDeleteManyArgs>(args?: SelectSubset<T, LanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LanguageUpdateManyArgs>(args: SelectSubset<T, LanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages and returns the data updated in the database.
     * @param {LanguageUpdateManyAndReturnArgs} args - Arguments to update many Languages.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Languages and only return the `id`
     * const languageWithIdOnly = await prisma.language.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LanguageUpdateManyAndReturnArgs>(args: SelectSubset<T, LanguageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Language.
     * @param {LanguageUpsertArgs} args - Arguments to update or create a Language.
     * @example
     * // Update or create a Language
     * const language = await prisma.language.upsert({
     *   create: {
     *     // ... data to create a Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language we want to update
     *   }
     * })
     */
    upsert<T extends LanguageUpsertArgs>(args: SelectSubset<T, LanguageUpsertArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.language.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends LanguageCountArgs>(
      args?: Subset<T, LanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageAggregateArgs>(args: Subset<T, LanguageAggregateArgs>): Prisma.PrismaPromise<GetLanguageAggregateType<T>>

    /**
     * Group by Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageGroupByArgs['orderBy'] }
        : { orderBy?: LanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Language model
   */
  readonly fields: LanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Language$usersArgs<ExtArgs> = {}>(args?: Subset<T, Language$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Language model
   */ 
  interface LanguageFieldRefs {
    readonly id: FieldRef<"Language", 'String'>
    readonly name: FieldRef<"Language", 'String'>
    readonly nativeName: FieldRef<"Language", 'String'>
    readonly iso6391: FieldRef<"Language", 'String'>
    readonly iso6392: FieldRef<"Language", 'String'>
    readonly iso6393: FieldRef<"Language", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Language findUnique
   */
  export type LanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findUniqueOrThrow
   */
  export type LanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findFirst
   */
  export type LanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findFirstOrThrow
   */
  export type LanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findMany
   */
  export type LanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Languages to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language create
   */
  export type LanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a Language.
     */
    data: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
  }

  /**
   * Language createMany
   */
  export type LanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language createManyAndReturn
   */
  export type LanguageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language update
   */
  export type LanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a Language.
     */
    data: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
    /**
     * Choose, which Language to update.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language updateMany
   */
  export type LanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to update.
     */
    limit?: number
  }

  /**
   * Language updateManyAndReturn
   */
  export type LanguageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to update.
     */
    limit?: number
  }

  /**
   * Language upsert
   */
  export type LanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the Language to update in case it exists.
     */
    where: LanguageWhereUniqueInput
    /**
     * In case the Language found by the `where` argument doesn't exist, create a new Language with this data.
     */
    create: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
    /**
     * In case the Language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
  }

  /**
   * Language delete
   */
  export type LanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter which Language to delete.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language deleteMany
   */
  export type LanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Languages to delete
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to delete.
     */
    limit?: number
  }

  /**
   * Language.users
   */
  export type Language$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    cursor?: UsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Language without action
   */
  export type LanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
  }


  /**
   * Model Currency
   */

  export type AggregateCurrency = {
    _count: CurrencyCountAggregateOutputType | null
    _avg: CurrencyAvgAggregateOutputType | null
    _sum: CurrencySumAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  export type CurrencyAvgAggregateOutputType = {
    rate: number | null
  }

  export type CurrencySumAggregateOutputType = {
    rate: number | null
  }

  export type CurrencyMinAggregateOutputType = {
    key: $Enums.CurrencyEnum | null
    name: string | null
    symbol: string | null
    rate: number | null
    coinmarketcapUCID: string | null
    updatedAt: Date | null
  }

  export type CurrencyMaxAggregateOutputType = {
    key: $Enums.CurrencyEnum | null
    name: string | null
    symbol: string | null
    rate: number | null
    coinmarketcapUCID: string | null
    updatedAt: Date | null
  }

  export type CurrencyCountAggregateOutputType = {
    key: number
    name: number
    symbol: number
    rate: number
    coinmarketcapUCID: number
    updatedAt: number
    _all: number
  }


  export type CurrencyAvgAggregateInputType = {
    rate?: true
  }

  export type CurrencySumAggregateInputType = {
    rate?: true
  }

  export type CurrencyMinAggregateInputType = {
    key?: true
    name?: true
    symbol?: true
    rate?: true
    coinmarketcapUCID?: true
    updatedAt?: true
  }

  export type CurrencyMaxAggregateInputType = {
    key?: true
    name?: true
    symbol?: true
    rate?: true
    coinmarketcapUCID?: true
    updatedAt?: true
  }

  export type CurrencyCountAggregateInputType = {
    key?: true
    name?: true
    symbol?: true
    rate?: true
    coinmarketcapUCID?: true
    updatedAt?: true
    _all?: true
  }

  export type CurrencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currency to aggregate.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Currencies
    **/
    _count?: true | CurrencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CurrencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CurrencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurrencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurrencyMaxAggregateInputType
  }

  export type GetCurrencyAggregateType<T extends CurrencyAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrency[P]>
      : GetScalarType<T[P], AggregateCurrency[P]>
  }




  export type CurrencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrencyWhereInput
    orderBy?: CurrencyOrderByWithAggregationInput | CurrencyOrderByWithAggregationInput[]
    by: CurrencyScalarFieldEnum[] | CurrencyScalarFieldEnum
    having?: CurrencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurrencyCountAggregateInputType | true
    _avg?: CurrencyAvgAggregateInputType
    _sum?: CurrencySumAggregateInputType
    _min?: CurrencyMinAggregateInputType
    _max?: CurrencyMaxAggregateInputType
  }

  export type CurrencyGroupByOutputType = {
    key: $Enums.CurrencyEnum
    name: string
    symbol: string
    rate: number
    coinmarketcapUCID: string | null
    updatedAt: Date
    _count: CurrencyCountAggregateOutputType | null
    _avg: CurrencyAvgAggregateOutputType | null
    _sum: CurrencySumAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  type GetCurrencyGroupByPayload<T extends CurrencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CurrencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurrencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
            : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
        }
      >
    >


  export type CurrencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    name?: boolean
    symbol?: boolean
    rate?: boolean
    coinmarketcapUCID?: boolean
    updatedAt?: boolean
    payments?: boolean | Currency$paymentsArgs<ExtArgs>
    paymentMethods?: boolean | Currency$paymentMethodsArgs<ExtArgs>
    _count?: boolean | CurrencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    name?: boolean
    symbol?: boolean
    rate?: boolean
    coinmarketcapUCID?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    name?: boolean
    symbol?: boolean
    rate?: boolean
    coinmarketcapUCID?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectScalar = {
    key?: boolean
    name?: boolean
    symbol?: boolean
    rate?: boolean
    coinmarketcapUCID?: boolean
    updatedAt?: boolean
  }

  export type CurrencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "name" | "symbol" | "rate" | "coinmarketcapUCID" | "updatedAt", ExtArgs["result"]["currency"]>
  export type CurrencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | Currency$paymentsArgs<ExtArgs>
    paymentMethods?: boolean | Currency$paymentMethodsArgs<ExtArgs>
    _count?: boolean | CurrencyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CurrencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CurrencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CurrencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Currency"
    objects: {
      payments: Prisma.$PaymentsPayload<ExtArgs>[]
      paymentMethods: Prisma.$PaymentMethodsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      key: $Enums.CurrencyEnum
      name: string
      symbol: string
      rate: number
      coinmarketcapUCID: string | null
      updatedAt: Date
    }, ExtArgs["result"]["currency"]>
    composites: {}
  }

  type CurrencyGetPayload<S extends boolean | null | undefined | CurrencyDefaultArgs> = $Result.GetResult<Prisma.$CurrencyPayload, S>

  type CurrencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CurrencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CurrencyCountAggregateInputType | true
    }

  export interface CurrencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Currency'], meta: { name: 'Currency' } }
    /**
     * Find zero or one Currency that matches the filter.
     * @param {CurrencyFindUniqueArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CurrencyFindUniqueArgs>(args: SelectSubset<T, CurrencyFindUniqueArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Currency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CurrencyFindUniqueOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CurrencyFindUniqueOrThrowArgs>(args: SelectSubset<T, CurrencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CurrencyFindFirstArgs>(args?: SelectSubset<T, CurrencyFindFirstArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CurrencyFindFirstOrThrowArgs>(args?: SelectSubset<T, CurrencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Currencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Currencies
     * const currencies = await prisma.currency.findMany()
     * 
     * // Get first 10 Currencies
     * const currencies = await prisma.currency.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const currencyWithNameOnly = await prisma.currency.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends CurrencyFindManyArgs>(args?: SelectSubset<T, CurrencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Currency.
     * @param {CurrencyCreateArgs} args - Arguments to create a Currency.
     * @example
     * // Create one Currency
     * const Currency = await prisma.currency.create({
     *   data: {
     *     // ... data to create a Currency
     *   }
     * })
     * 
     */
    create<T extends CurrencyCreateArgs>(args: SelectSubset<T, CurrencyCreateArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Currencies.
     * @param {CurrencyCreateManyArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currency = await prisma.currency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CurrencyCreateManyArgs>(args?: SelectSubset<T, CurrencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Currencies and returns the data saved in the database.
     * @param {CurrencyCreateManyAndReturnArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currency = await prisma.currency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Currencies and only return the `name`
     * const currencyWithNameOnly = await prisma.currency.createManyAndReturn({
     *   select: { name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CurrencyCreateManyAndReturnArgs>(args?: SelectSubset<T, CurrencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Currency.
     * @param {CurrencyDeleteArgs} args - Arguments to delete one Currency.
     * @example
     * // Delete one Currency
     * const Currency = await prisma.currency.delete({
     *   where: {
     *     // ... filter to delete one Currency
     *   }
     * })
     * 
     */
    delete<T extends CurrencyDeleteArgs>(args: SelectSubset<T, CurrencyDeleteArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Currency.
     * @param {CurrencyUpdateArgs} args - Arguments to update one Currency.
     * @example
     * // Update one Currency
     * const currency = await prisma.currency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CurrencyUpdateArgs>(args: SelectSubset<T, CurrencyUpdateArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Currencies.
     * @param {CurrencyDeleteManyArgs} args - Arguments to filter Currencies to delete.
     * @example
     * // Delete a few Currencies
     * const { count } = await prisma.currency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CurrencyDeleteManyArgs>(args?: SelectSubset<T, CurrencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CurrencyUpdateManyArgs>(args: SelectSubset<T, CurrencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies and returns the data updated in the database.
     * @param {CurrencyUpdateManyAndReturnArgs} args - Arguments to update many Currencies.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Currencies and only return the `name`
     * const currencyWithNameOnly = await prisma.currency.updateManyAndReturn({
     *   select: { name: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CurrencyUpdateManyAndReturnArgs>(args: SelectSubset<T, CurrencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Currency.
     * @param {CurrencyUpsertArgs} args - Arguments to update or create a Currency.
     * @example
     * // Update or create a Currency
     * const currency = await prisma.currency.upsert({
     *   create: {
     *     // ... data to create a Currency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Currency we want to update
     *   }
     * })
     */
    upsert<T extends CurrencyUpsertArgs>(args: SelectSubset<T, CurrencyUpsertArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyCountArgs} args - Arguments to filter Currencies to count.
     * @example
     * // Count the number of Currencies
     * const count = await prisma.currency.count({
     *   where: {
     *     // ... the filter for the Currencies we want to count
     *   }
     * })
    **/
    count<T extends CurrencyCountArgs>(
      args?: Subset<T, CurrencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurrencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurrencyAggregateArgs>(args: Subset<T, CurrencyAggregateArgs>): Prisma.PrismaPromise<GetCurrencyAggregateType<T>>

    /**
     * Group by Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurrencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurrencyGroupByArgs['orderBy'] }
        : { orderBy?: CurrencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurrencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Currency model
   */
  readonly fields: CurrencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Currency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CurrencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payments<T extends Currency$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Currency$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentMethods<T extends Currency$paymentMethodsArgs<ExtArgs> = {}>(args?: Subset<T, Currency$paymentMethodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Currency model
   */ 
  interface CurrencyFieldRefs {
    readonly key: FieldRef<"Currency", 'CurrencyEnum'>
    readonly name: FieldRef<"Currency", 'String'>
    readonly symbol: FieldRef<"Currency", 'String'>
    readonly rate: FieldRef<"Currency", 'Float'>
    readonly coinmarketcapUCID: FieldRef<"Currency", 'String'>
    readonly updatedAt: FieldRef<"Currency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Currency findUnique
   */
  export type CurrencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findUniqueOrThrow
   */
  export type CurrencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findFirst
   */
  export type CurrencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findFirstOrThrow
   */
  export type CurrencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findMany
   */
  export type CurrencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currencies to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency create
   */
  export type CurrencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Currency.
     */
    data: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
  }

  /**
   * Currency createMany
   */
  export type CurrencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Currencies.
     */
    data: CurrencyCreateManyInput | CurrencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Currency createManyAndReturn
   */
  export type CurrencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * The data used to create many Currencies.
     */
    data: CurrencyCreateManyInput | CurrencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Currency update
   */
  export type CurrencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Currency.
     */
    data: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
    /**
     * Choose, which Currency to update.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency updateMany
   */
  export type CurrencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Currencies.
     */
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyInput>
    /**
     * Filter which Currencies to update
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to update.
     */
    limit?: number
  }

  /**
   * Currency updateManyAndReturn
   */
  export type CurrencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * The data used to update Currencies.
     */
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyInput>
    /**
     * Filter which Currencies to update
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to update.
     */
    limit?: number
  }

  /**
   * Currency upsert
   */
  export type CurrencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Currency to update in case it exists.
     */
    where: CurrencyWhereUniqueInput
    /**
     * In case the Currency found by the `where` argument doesn't exist, create a new Currency with this data.
     */
    create: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
    /**
     * In case the Currency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
  }

  /**
   * Currency delete
   */
  export type CurrencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter which Currency to delete.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency deleteMany
   */
  export type CurrencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currencies to delete
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to delete.
     */
    limit?: number
  }

  /**
   * Currency.payments
   */
  export type Currency$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    where?: PaymentsWhereInput
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    cursor?: PaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Currency.paymentMethods
   */
  export type Currency$paymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethods
     */
    select?: PaymentMethodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethods
     */
    omit?: PaymentMethodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodsInclude<ExtArgs> | null
    where?: PaymentMethodsWhereInput
    orderBy?: PaymentMethodsOrderByWithRelationInput | PaymentMethodsOrderByWithRelationInput[]
    cursor?: PaymentMethodsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentMethodsScalarFieldEnum | PaymentMethodsScalarFieldEnum[]
  }

  /**
   * Currency without action
   */
  export type CurrencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
  }


  /**
   * Model Transactions
   */

  export type AggregateTransactions = {
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  export type TransactionsAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionsSumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionsMinAggregateOutputType = {
    id: string | null
    amount: number | null
    isHold: boolean | null
    type: $Enums.TransactionTypeEnum | null
    reason: $Enums.TransactionReasonEnum | null
    balanceType: $Enums.BalanceTypeEnum | null
    createdAt: Date | null
    updatedAt: Date | null
    holdExpiredAt: Date | null
    balanceId: string | null
  }

  export type TransactionsMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    isHold: boolean | null
    type: $Enums.TransactionTypeEnum | null
    reason: $Enums.TransactionReasonEnum | null
    balanceType: $Enums.BalanceTypeEnum | null
    createdAt: Date | null
    updatedAt: Date | null
    holdExpiredAt: Date | null
    balanceId: string | null
  }

  export type TransactionsCountAggregateOutputType = {
    id: number
    amount: number
    isHold: number
    type: number
    reason: number
    balanceType: number
    createdAt: number
    updatedAt: number
    holdExpiredAt: number
    balanceId: number
    _all: number
  }


  export type TransactionsAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionsSumAggregateInputType = {
    amount?: true
  }

  export type TransactionsMinAggregateInputType = {
    id?: true
    amount?: true
    isHold?: true
    type?: true
    reason?: true
    balanceType?: true
    createdAt?: true
    updatedAt?: true
    holdExpiredAt?: true
    balanceId?: true
  }

  export type TransactionsMaxAggregateInputType = {
    id?: true
    amount?: true
    isHold?: true
    type?: true
    reason?: true
    balanceType?: true
    createdAt?: true
    updatedAt?: true
    holdExpiredAt?: true
    balanceId?: true
  }

  export type TransactionsCountAggregateInputType = {
    id?: true
    amount?: true
    isHold?: true
    type?: true
    reason?: true
    balanceType?: true
    createdAt?: true
    updatedAt?: true
    holdExpiredAt?: true
    balanceId?: true
    _all?: true
  }

  export type TransactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to aggregate.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionsMaxAggregateInputType
  }

  export type GetTransactionsAggregateType<T extends TransactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactions[P]>
      : GetScalarType<T[P], AggregateTransactions[P]>
  }




  export type TransactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsWhereInput
    orderBy?: TransactionsOrderByWithAggregationInput | TransactionsOrderByWithAggregationInput[]
    by: TransactionsScalarFieldEnum[] | TransactionsScalarFieldEnum
    having?: TransactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionsCountAggregateInputType | true
    _avg?: TransactionsAvgAggregateInputType
    _sum?: TransactionsSumAggregateInputType
    _min?: TransactionsMinAggregateInputType
    _max?: TransactionsMaxAggregateInputType
  }

  export type TransactionsGroupByOutputType = {
    id: string
    amount: number
    isHold: boolean
    type: $Enums.TransactionTypeEnum
    reason: $Enums.TransactionReasonEnum
    balanceType: $Enums.BalanceTypeEnum
    createdAt: Date
    updatedAt: Date
    holdExpiredAt: Date | null
    balanceId: string
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  type GetTransactionsGroupByPayload<T extends TransactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
        }
      >
    >


  export type TransactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    isHold?: boolean
    type?: boolean
    reason?: boolean
    balanceType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    holdExpiredAt?: boolean
    balanceId?: boolean
    balance?: boolean | UserBalanceDefaultArgs<ExtArgs>
    withdrawal?: boolean | Transactions$withdrawalArgs<ExtArgs>
    payment?: boolean | Transactions$paymentArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>

  export type TransactionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    isHold?: boolean
    type?: boolean
    reason?: boolean
    balanceType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    holdExpiredAt?: boolean
    balanceId?: boolean
    balance?: boolean | UserBalanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>

  export type TransactionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    isHold?: boolean
    type?: boolean
    reason?: boolean
    balanceType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    holdExpiredAt?: boolean
    balanceId?: boolean
    balance?: boolean | UserBalanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>

  export type TransactionsSelectScalar = {
    id?: boolean
    amount?: boolean
    isHold?: boolean
    type?: boolean
    reason?: boolean
    balanceType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    holdExpiredAt?: boolean
    balanceId?: boolean
  }

  export type TransactionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "isHold" | "type" | "reason" | "balanceType" | "createdAt" | "updatedAt" | "holdExpiredAt" | "balanceId", ExtArgs["result"]["transactions"]>
  export type TransactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    balance?: boolean | UserBalanceDefaultArgs<ExtArgs>
    withdrawal?: boolean | Transactions$withdrawalArgs<ExtArgs>
    payment?: boolean | Transactions$paymentArgs<ExtArgs>
  }
  export type TransactionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    balance?: boolean | UserBalanceDefaultArgs<ExtArgs>
  }
  export type TransactionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    balance?: boolean | UserBalanceDefaultArgs<ExtArgs>
  }

  export type $TransactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transactions"
    objects: {
      balance: Prisma.$UserBalancePayload<ExtArgs>
      withdrawal: Prisma.$WithdrawalsPayload<ExtArgs> | null
      payment: Prisma.$PaymentsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      isHold: boolean
      type: $Enums.TransactionTypeEnum
      reason: $Enums.TransactionReasonEnum
      balanceType: $Enums.BalanceTypeEnum
      createdAt: Date
      updatedAt: Date
      holdExpiredAt: Date | null
      balanceId: string
    }, ExtArgs["result"]["transactions"]>
    composites: {}
  }

  type TransactionsGetPayload<S extends boolean | null | undefined | TransactionsDefaultArgs> = $Result.GetResult<Prisma.$TransactionsPayload, S>

  type TransactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionsCountAggregateInputType | true
    }

  export interface TransactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transactions'], meta: { name: 'Transactions' } }
    /**
     * Find zero or one Transactions that matches the filter.
     * @param {TransactionsFindUniqueArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionsFindUniqueArgs>(args: SelectSubset<T, TransactionsFindUniqueArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transactions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionsFindUniqueOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsFindFirstArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionsFindFirstArgs>(args?: SelectSubset<T, TransactionsFindFirstArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsFindFirstOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transactions.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionsWithIdOnly = await prisma.transactions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionsFindManyArgs>(args?: SelectSubset<T, TransactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transactions.
     * @param {TransactionsCreateArgs} args - Arguments to create a Transactions.
     * @example
     * // Create one Transactions
     * const Transactions = await prisma.transactions.create({
     *   data: {
     *     // ... data to create a Transactions
     *   }
     * })
     * 
     */
    create<T extends TransactionsCreateArgs>(args: SelectSubset<T, TransactionsCreateArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionsCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transactions = await prisma.transactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionsCreateManyArgs>(args?: SelectSubset<T, TransactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionsCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transactions = await prisma.transactions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionsWithIdOnly = await prisma.transactions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionsCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transactions.
     * @param {TransactionsDeleteArgs} args - Arguments to delete one Transactions.
     * @example
     * // Delete one Transactions
     * const Transactions = await prisma.transactions.delete({
     *   where: {
     *     // ... filter to delete one Transactions
     *   }
     * })
     * 
     */
    delete<T extends TransactionsDeleteArgs>(args: SelectSubset<T, TransactionsDeleteArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transactions.
     * @param {TransactionsUpdateArgs} args - Arguments to update one Transactions.
     * @example
     * // Update one Transactions
     * const transactions = await prisma.transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionsUpdateArgs>(args: SelectSubset<T, TransactionsUpdateArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionsDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionsDeleteManyArgs>(args?: SelectSubset<T, TransactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transactions = await prisma.transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionsUpdateManyArgs>(args: SelectSubset<T, TransactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionsUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transactions = await prisma.transactions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionsWithIdOnly = await prisma.transactions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionsUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transactions.
     * @param {TransactionsUpsertArgs} args - Arguments to update or create a Transactions.
     * @example
     * // Update or create a Transactions
     * const transactions = await prisma.transactions.upsert({
     *   create: {
     *     // ... data to create a Transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transactions we want to update
     *   }
     * })
     */
    upsert<T extends TransactionsUpsertArgs>(args: SelectSubset<T, TransactionsUpsertArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transactions.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionsCountArgs>(
      args?: Subset<T, TransactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionsAggregateArgs>(args: Subset<T, TransactionsAggregateArgs>): Prisma.PrismaPromise<GetTransactionsAggregateType<T>>

    /**
     * Group by Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionsGroupByArgs['orderBy'] }
        : { orderBy?: TransactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transactions model
   */
  readonly fields: TransactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    balance<T extends UserBalanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserBalanceDefaultArgs<ExtArgs>>): Prisma__UserBalanceClient<$Result.GetResult<Prisma.$UserBalancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    withdrawal<T extends Transactions$withdrawalArgs<ExtArgs> = {}>(args?: Subset<T, Transactions$withdrawalArgs<ExtArgs>>): Prisma__WithdrawalsClient<$Result.GetResult<Prisma.$WithdrawalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payment<T extends Transactions$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Transactions$paymentArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transactions model
   */ 
  interface TransactionsFieldRefs {
    readonly id: FieldRef<"Transactions", 'String'>
    readonly amount: FieldRef<"Transactions", 'Float'>
    readonly isHold: FieldRef<"Transactions", 'Boolean'>
    readonly type: FieldRef<"Transactions", 'TransactionTypeEnum'>
    readonly reason: FieldRef<"Transactions", 'TransactionReasonEnum'>
    readonly balanceType: FieldRef<"Transactions", 'BalanceTypeEnum'>
    readonly createdAt: FieldRef<"Transactions", 'DateTime'>
    readonly updatedAt: FieldRef<"Transactions", 'DateTime'>
    readonly holdExpiredAt: FieldRef<"Transactions", 'DateTime'>
    readonly balanceId: FieldRef<"Transactions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Transactions findUnique
   */
  export type TransactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions findUniqueOrThrow
   */
  export type TransactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions findFirst
   */
  export type TransactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Transactions findFirstOrThrow
   */
  export type TransactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Transactions findMany
   */
  export type TransactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Transactions create
   */
  export type TransactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Transactions.
     */
    data: XOR<TransactionsCreateInput, TransactionsUncheckedCreateInput>
  }

  /**
   * Transactions createMany
   */
  export type TransactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionsCreateManyInput | TransactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transactions createManyAndReturn
   */
  export type TransactionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionsCreateManyInput | TransactionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transactions update
   */
  export type TransactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Transactions.
     */
    data: XOR<TransactionsUpdateInput, TransactionsUncheckedUpdateInput>
    /**
     * Choose, which Transactions to update.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions updateMany
   */
  export type TransactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionsWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transactions updateManyAndReturn
   */
  export type TransactionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionsWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transactions upsert
   */
  export type TransactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Transactions to update in case it exists.
     */
    where: TransactionsWhereUniqueInput
    /**
     * In case the Transactions found by the `where` argument doesn't exist, create a new Transactions with this data.
     */
    create: XOR<TransactionsCreateInput, TransactionsUncheckedCreateInput>
    /**
     * In case the Transactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionsUpdateInput, TransactionsUncheckedUpdateInput>
  }

  /**
   * Transactions delete
   */
  export type TransactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter which Transactions to delete.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions deleteMany
   */
  export type TransactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionsWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transactions.withdrawal
   */
  export type Transactions$withdrawalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawals
     */
    select?: WithdrawalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawals
     */
    omit?: WithdrawalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalsInclude<ExtArgs> | null
    where?: WithdrawalsWhereInput
  }

  /**
   * Transactions.payment
   */
  export type Transactions$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    where?: PaymentsWhereInput
  }

  /**
   * Transactions without action
   */
  export type TransactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
  }


  /**
   * Model Withdrawals
   */

  export type AggregateWithdrawals = {
    _count: WithdrawalsCountAggregateOutputType | null
    _avg: WithdrawalsAvgAggregateOutputType | null
    _sum: WithdrawalsSumAggregateOutputType | null
    _min: WithdrawalsMinAggregateOutputType | null
    _max: WithdrawalsMaxAggregateOutputType | null
  }

  export type WithdrawalsAvgAggregateOutputType = {
    amountStars: number | null
    amountUSD: number | null
    amountTON: number | null
  }

  export type WithdrawalsSumAggregateOutputType = {
    amountStars: number | null
    amountUSD: number | null
    amountTON: number | null
  }

  export type WithdrawalsMinAggregateOutputType = {
    id: string | null
    status: $Enums.WithdrawalStatusEnum | null
    amountStars: number | null
    amountUSD: number | null
    amountTON: number | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    transactionId: string | null
  }

  export type WithdrawalsMaxAggregateOutputType = {
    id: string | null
    status: $Enums.WithdrawalStatusEnum | null
    amountStars: number | null
    amountUSD: number | null
    amountTON: number | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    transactionId: string | null
  }

  export type WithdrawalsCountAggregateOutputType = {
    id: number
    status: number
    amountStars: number
    amountUSD: number
    amountTON: number
    address: number
    createdAt: number
    updatedAt: number
    userId: number
    transactionId: number
    _all: number
  }


  export type WithdrawalsAvgAggregateInputType = {
    amountStars?: true
    amountUSD?: true
    amountTON?: true
  }

  export type WithdrawalsSumAggregateInputType = {
    amountStars?: true
    amountUSD?: true
    amountTON?: true
  }

  export type WithdrawalsMinAggregateInputType = {
    id?: true
    status?: true
    amountStars?: true
    amountUSD?: true
    amountTON?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    transactionId?: true
  }

  export type WithdrawalsMaxAggregateInputType = {
    id?: true
    status?: true
    amountStars?: true
    amountUSD?: true
    amountTON?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    transactionId?: true
  }

  export type WithdrawalsCountAggregateInputType = {
    id?: true
    status?: true
    amountStars?: true
    amountUSD?: true
    amountTON?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    transactionId?: true
    _all?: true
  }

  export type WithdrawalsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Withdrawals to aggregate.
     */
    where?: WithdrawalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdrawals to fetch.
     */
    orderBy?: WithdrawalsOrderByWithRelationInput | WithdrawalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WithdrawalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Withdrawals
    **/
    _count?: true | WithdrawalsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WithdrawalsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WithdrawalsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WithdrawalsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WithdrawalsMaxAggregateInputType
  }

  export type GetWithdrawalsAggregateType<T extends WithdrawalsAggregateArgs> = {
        [P in keyof T & keyof AggregateWithdrawals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWithdrawals[P]>
      : GetScalarType<T[P], AggregateWithdrawals[P]>
  }




  export type WithdrawalsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WithdrawalsWhereInput
    orderBy?: WithdrawalsOrderByWithAggregationInput | WithdrawalsOrderByWithAggregationInput[]
    by: WithdrawalsScalarFieldEnum[] | WithdrawalsScalarFieldEnum
    having?: WithdrawalsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WithdrawalsCountAggregateInputType | true
    _avg?: WithdrawalsAvgAggregateInputType
    _sum?: WithdrawalsSumAggregateInputType
    _min?: WithdrawalsMinAggregateInputType
    _max?: WithdrawalsMaxAggregateInputType
  }

  export type WithdrawalsGroupByOutputType = {
    id: string
    status: $Enums.WithdrawalStatusEnum
    amountStars: number
    amountUSD: number
    amountTON: number
    address: string
    createdAt: Date
    updatedAt: Date
    userId: string
    transactionId: string
    _count: WithdrawalsCountAggregateOutputType | null
    _avg: WithdrawalsAvgAggregateOutputType | null
    _sum: WithdrawalsSumAggregateOutputType | null
    _min: WithdrawalsMinAggregateOutputType | null
    _max: WithdrawalsMaxAggregateOutputType | null
  }

  type GetWithdrawalsGroupByPayload<T extends WithdrawalsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WithdrawalsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WithdrawalsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WithdrawalsGroupByOutputType[P]>
            : GetScalarType<T[P], WithdrawalsGroupByOutputType[P]>
        }
      >
    >


  export type WithdrawalsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    amountStars?: boolean
    amountUSD?: boolean
    amountTON?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    transactionId?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    transacrion?: boolean | TransactionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["withdrawals"]>

  export type WithdrawalsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    amountStars?: boolean
    amountUSD?: boolean
    amountTON?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    transactionId?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    transacrion?: boolean | TransactionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["withdrawals"]>

  export type WithdrawalsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    amountStars?: boolean
    amountUSD?: boolean
    amountTON?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    transactionId?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    transacrion?: boolean | TransactionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["withdrawals"]>

  export type WithdrawalsSelectScalar = {
    id?: boolean
    status?: boolean
    amountStars?: boolean
    amountUSD?: boolean
    amountTON?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    transactionId?: boolean
  }

  export type WithdrawalsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "amountStars" | "amountUSD" | "amountTON" | "address" | "createdAt" | "updatedAt" | "userId" | "transactionId", ExtArgs["result"]["withdrawals"]>
  export type WithdrawalsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    transacrion?: boolean | TransactionsDefaultArgs<ExtArgs>
  }
  export type WithdrawalsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    transacrion?: boolean | TransactionsDefaultArgs<ExtArgs>
  }
  export type WithdrawalsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    transacrion?: boolean | TransactionsDefaultArgs<ExtArgs>
  }

  export type $WithdrawalsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Withdrawals"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      transacrion: Prisma.$TransactionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.WithdrawalStatusEnum
      amountStars: number
      amountUSD: number
      amountTON: number
      address: string
      createdAt: Date
      updatedAt: Date
      userId: string
      transactionId: string
    }, ExtArgs["result"]["withdrawals"]>
    composites: {}
  }

  type WithdrawalsGetPayload<S extends boolean | null | undefined | WithdrawalsDefaultArgs> = $Result.GetResult<Prisma.$WithdrawalsPayload, S>

  type WithdrawalsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WithdrawalsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WithdrawalsCountAggregateInputType | true
    }

  export interface WithdrawalsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Withdrawals'], meta: { name: 'Withdrawals' } }
    /**
     * Find zero or one Withdrawals that matches the filter.
     * @param {WithdrawalsFindUniqueArgs} args - Arguments to find a Withdrawals
     * @example
     * // Get one Withdrawals
     * const withdrawals = await prisma.withdrawals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WithdrawalsFindUniqueArgs>(args: SelectSubset<T, WithdrawalsFindUniqueArgs<ExtArgs>>): Prisma__WithdrawalsClient<$Result.GetResult<Prisma.$WithdrawalsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Withdrawals that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WithdrawalsFindUniqueOrThrowArgs} args - Arguments to find a Withdrawals
     * @example
     * // Get one Withdrawals
     * const withdrawals = await prisma.withdrawals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WithdrawalsFindUniqueOrThrowArgs>(args: SelectSubset<T, WithdrawalsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WithdrawalsClient<$Result.GetResult<Prisma.$WithdrawalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Withdrawals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalsFindFirstArgs} args - Arguments to find a Withdrawals
     * @example
     * // Get one Withdrawals
     * const withdrawals = await prisma.withdrawals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WithdrawalsFindFirstArgs>(args?: SelectSubset<T, WithdrawalsFindFirstArgs<ExtArgs>>): Prisma__WithdrawalsClient<$Result.GetResult<Prisma.$WithdrawalsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Withdrawals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalsFindFirstOrThrowArgs} args - Arguments to find a Withdrawals
     * @example
     * // Get one Withdrawals
     * const withdrawals = await prisma.withdrawals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WithdrawalsFindFirstOrThrowArgs>(args?: SelectSubset<T, WithdrawalsFindFirstOrThrowArgs<ExtArgs>>): Prisma__WithdrawalsClient<$Result.GetResult<Prisma.$WithdrawalsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Withdrawals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Withdrawals
     * const withdrawals = await prisma.withdrawals.findMany()
     * 
     * // Get first 10 Withdrawals
     * const withdrawals = await prisma.withdrawals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const withdrawalsWithIdOnly = await prisma.withdrawals.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WithdrawalsFindManyArgs>(args?: SelectSubset<T, WithdrawalsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Withdrawals.
     * @param {WithdrawalsCreateArgs} args - Arguments to create a Withdrawals.
     * @example
     * // Create one Withdrawals
     * const Withdrawals = await prisma.withdrawals.create({
     *   data: {
     *     // ... data to create a Withdrawals
     *   }
     * })
     * 
     */
    create<T extends WithdrawalsCreateArgs>(args: SelectSubset<T, WithdrawalsCreateArgs<ExtArgs>>): Prisma__WithdrawalsClient<$Result.GetResult<Prisma.$WithdrawalsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Withdrawals.
     * @param {WithdrawalsCreateManyArgs} args - Arguments to create many Withdrawals.
     * @example
     * // Create many Withdrawals
     * const withdrawals = await prisma.withdrawals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WithdrawalsCreateManyArgs>(args?: SelectSubset<T, WithdrawalsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Withdrawals and returns the data saved in the database.
     * @param {WithdrawalsCreateManyAndReturnArgs} args - Arguments to create many Withdrawals.
     * @example
     * // Create many Withdrawals
     * const withdrawals = await prisma.withdrawals.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Withdrawals and only return the `id`
     * const withdrawalsWithIdOnly = await prisma.withdrawals.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WithdrawalsCreateManyAndReturnArgs>(args?: SelectSubset<T, WithdrawalsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawalsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Withdrawals.
     * @param {WithdrawalsDeleteArgs} args - Arguments to delete one Withdrawals.
     * @example
     * // Delete one Withdrawals
     * const Withdrawals = await prisma.withdrawals.delete({
     *   where: {
     *     // ... filter to delete one Withdrawals
     *   }
     * })
     * 
     */
    delete<T extends WithdrawalsDeleteArgs>(args: SelectSubset<T, WithdrawalsDeleteArgs<ExtArgs>>): Prisma__WithdrawalsClient<$Result.GetResult<Prisma.$WithdrawalsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Withdrawals.
     * @param {WithdrawalsUpdateArgs} args - Arguments to update one Withdrawals.
     * @example
     * // Update one Withdrawals
     * const withdrawals = await prisma.withdrawals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WithdrawalsUpdateArgs>(args: SelectSubset<T, WithdrawalsUpdateArgs<ExtArgs>>): Prisma__WithdrawalsClient<$Result.GetResult<Prisma.$WithdrawalsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Withdrawals.
     * @param {WithdrawalsDeleteManyArgs} args - Arguments to filter Withdrawals to delete.
     * @example
     * // Delete a few Withdrawals
     * const { count } = await prisma.withdrawals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WithdrawalsDeleteManyArgs>(args?: SelectSubset<T, WithdrawalsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Withdrawals
     * const withdrawals = await prisma.withdrawals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WithdrawalsUpdateManyArgs>(args: SelectSubset<T, WithdrawalsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Withdrawals and returns the data updated in the database.
     * @param {WithdrawalsUpdateManyAndReturnArgs} args - Arguments to update many Withdrawals.
     * @example
     * // Update many Withdrawals
     * const withdrawals = await prisma.withdrawals.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Withdrawals and only return the `id`
     * const withdrawalsWithIdOnly = await prisma.withdrawals.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WithdrawalsUpdateManyAndReturnArgs>(args: SelectSubset<T, WithdrawalsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawalsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Withdrawals.
     * @param {WithdrawalsUpsertArgs} args - Arguments to update or create a Withdrawals.
     * @example
     * // Update or create a Withdrawals
     * const withdrawals = await prisma.withdrawals.upsert({
     *   create: {
     *     // ... data to create a Withdrawals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Withdrawals we want to update
     *   }
     * })
     */
    upsert<T extends WithdrawalsUpsertArgs>(args: SelectSubset<T, WithdrawalsUpsertArgs<ExtArgs>>): Prisma__WithdrawalsClient<$Result.GetResult<Prisma.$WithdrawalsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalsCountArgs} args - Arguments to filter Withdrawals to count.
     * @example
     * // Count the number of Withdrawals
     * const count = await prisma.withdrawals.count({
     *   where: {
     *     // ... the filter for the Withdrawals we want to count
     *   }
     * })
    **/
    count<T extends WithdrawalsCountArgs>(
      args?: Subset<T, WithdrawalsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WithdrawalsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WithdrawalsAggregateArgs>(args: Subset<T, WithdrawalsAggregateArgs>): Prisma.PrismaPromise<GetWithdrawalsAggregateType<T>>

    /**
     * Group by Withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WithdrawalsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WithdrawalsGroupByArgs['orderBy'] }
        : { orderBy?: WithdrawalsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WithdrawalsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWithdrawalsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Withdrawals model
   */
  readonly fields: WithdrawalsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Withdrawals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WithdrawalsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transacrion<T extends TransactionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionsDefaultArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Withdrawals model
   */ 
  interface WithdrawalsFieldRefs {
    readonly id: FieldRef<"Withdrawals", 'String'>
    readonly status: FieldRef<"Withdrawals", 'WithdrawalStatusEnum'>
    readonly amountStars: FieldRef<"Withdrawals", 'Float'>
    readonly amountUSD: FieldRef<"Withdrawals", 'Float'>
    readonly amountTON: FieldRef<"Withdrawals", 'Float'>
    readonly address: FieldRef<"Withdrawals", 'String'>
    readonly createdAt: FieldRef<"Withdrawals", 'DateTime'>
    readonly updatedAt: FieldRef<"Withdrawals", 'DateTime'>
    readonly userId: FieldRef<"Withdrawals", 'String'>
    readonly transactionId: FieldRef<"Withdrawals", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Withdrawals findUnique
   */
  export type WithdrawalsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawals
     */
    select?: WithdrawalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawals
     */
    omit?: WithdrawalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalsInclude<ExtArgs> | null
    /**
     * Filter, which Withdrawals to fetch.
     */
    where: WithdrawalsWhereUniqueInput
  }

  /**
   * Withdrawals findUniqueOrThrow
   */
  export type WithdrawalsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawals
     */
    select?: WithdrawalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawals
     */
    omit?: WithdrawalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalsInclude<ExtArgs> | null
    /**
     * Filter, which Withdrawals to fetch.
     */
    where: WithdrawalsWhereUniqueInput
  }

  /**
   * Withdrawals findFirst
   */
  export type WithdrawalsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawals
     */
    select?: WithdrawalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawals
     */
    omit?: WithdrawalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalsInclude<ExtArgs> | null
    /**
     * Filter, which Withdrawals to fetch.
     */
    where?: WithdrawalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdrawals to fetch.
     */
    orderBy?: WithdrawalsOrderByWithRelationInput | WithdrawalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Withdrawals.
     */
    cursor?: WithdrawalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Withdrawals.
     */
    distinct?: WithdrawalsScalarFieldEnum | WithdrawalsScalarFieldEnum[]
  }

  /**
   * Withdrawals findFirstOrThrow
   */
  export type WithdrawalsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawals
     */
    select?: WithdrawalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawals
     */
    omit?: WithdrawalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalsInclude<ExtArgs> | null
    /**
     * Filter, which Withdrawals to fetch.
     */
    where?: WithdrawalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdrawals to fetch.
     */
    orderBy?: WithdrawalsOrderByWithRelationInput | WithdrawalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Withdrawals.
     */
    cursor?: WithdrawalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Withdrawals.
     */
    distinct?: WithdrawalsScalarFieldEnum | WithdrawalsScalarFieldEnum[]
  }

  /**
   * Withdrawals findMany
   */
  export type WithdrawalsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawals
     */
    select?: WithdrawalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawals
     */
    omit?: WithdrawalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalsInclude<ExtArgs> | null
    /**
     * Filter, which Withdrawals to fetch.
     */
    where?: WithdrawalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdrawals to fetch.
     */
    orderBy?: WithdrawalsOrderByWithRelationInput | WithdrawalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Withdrawals.
     */
    cursor?: WithdrawalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdrawals.
     */
    skip?: number
    distinct?: WithdrawalsScalarFieldEnum | WithdrawalsScalarFieldEnum[]
  }

  /**
   * Withdrawals create
   */
  export type WithdrawalsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawals
     */
    select?: WithdrawalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawals
     */
    omit?: WithdrawalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalsInclude<ExtArgs> | null
    /**
     * The data needed to create a Withdrawals.
     */
    data: XOR<WithdrawalsCreateInput, WithdrawalsUncheckedCreateInput>
  }

  /**
   * Withdrawals createMany
   */
  export type WithdrawalsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Withdrawals.
     */
    data: WithdrawalsCreateManyInput | WithdrawalsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Withdrawals createManyAndReturn
   */
  export type WithdrawalsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawals
     */
    select?: WithdrawalsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawals
     */
    omit?: WithdrawalsOmit<ExtArgs> | null
    /**
     * The data used to create many Withdrawals.
     */
    data: WithdrawalsCreateManyInput | WithdrawalsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Withdrawals update
   */
  export type WithdrawalsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawals
     */
    select?: WithdrawalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawals
     */
    omit?: WithdrawalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalsInclude<ExtArgs> | null
    /**
     * The data needed to update a Withdrawals.
     */
    data: XOR<WithdrawalsUpdateInput, WithdrawalsUncheckedUpdateInput>
    /**
     * Choose, which Withdrawals to update.
     */
    where: WithdrawalsWhereUniqueInput
  }

  /**
   * Withdrawals updateMany
   */
  export type WithdrawalsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Withdrawals.
     */
    data: XOR<WithdrawalsUpdateManyMutationInput, WithdrawalsUncheckedUpdateManyInput>
    /**
     * Filter which Withdrawals to update
     */
    where?: WithdrawalsWhereInput
    /**
     * Limit how many Withdrawals to update.
     */
    limit?: number
  }

  /**
   * Withdrawals updateManyAndReturn
   */
  export type WithdrawalsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawals
     */
    select?: WithdrawalsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawals
     */
    omit?: WithdrawalsOmit<ExtArgs> | null
    /**
     * The data used to update Withdrawals.
     */
    data: XOR<WithdrawalsUpdateManyMutationInput, WithdrawalsUncheckedUpdateManyInput>
    /**
     * Filter which Withdrawals to update
     */
    where?: WithdrawalsWhereInput
    /**
     * Limit how many Withdrawals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Withdrawals upsert
   */
  export type WithdrawalsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawals
     */
    select?: WithdrawalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawals
     */
    omit?: WithdrawalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalsInclude<ExtArgs> | null
    /**
     * The filter to search for the Withdrawals to update in case it exists.
     */
    where: WithdrawalsWhereUniqueInput
    /**
     * In case the Withdrawals found by the `where` argument doesn't exist, create a new Withdrawals with this data.
     */
    create: XOR<WithdrawalsCreateInput, WithdrawalsUncheckedCreateInput>
    /**
     * In case the Withdrawals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WithdrawalsUpdateInput, WithdrawalsUncheckedUpdateInput>
  }

  /**
   * Withdrawals delete
   */
  export type WithdrawalsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawals
     */
    select?: WithdrawalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawals
     */
    omit?: WithdrawalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalsInclude<ExtArgs> | null
    /**
     * Filter which Withdrawals to delete.
     */
    where: WithdrawalsWhereUniqueInput
  }

  /**
   * Withdrawals deleteMany
   */
  export type WithdrawalsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Withdrawals to delete
     */
    where?: WithdrawalsWhereInput
    /**
     * Limit how many Withdrawals to delete.
     */
    limit?: number
  }

  /**
   * Withdrawals without action
   */
  export type WithdrawalsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawals
     */
    select?: WithdrawalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawals
     */
    omit?: WithdrawalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalsInclude<ExtArgs> | null
  }


  /**
   * Model Payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsMinAggregateOutputType = {
    id: string | null
    status: $Enums.PaymentStatusEnum | null
    amount: string | null
    exchangeRate: string | null
    token: string | null
    linkPay: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    currencyKey: $Enums.CurrencyEnum | null
    SubscriptionId: string | null
    methodKey: $Enums.PaymentMethodEnum | null
    transactionId: string | null
  }

  export type PaymentsMaxAggregateOutputType = {
    id: string | null
    status: $Enums.PaymentStatusEnum | null
    amount: string | null
    exchangeRate: string | null
    token: string | null
    linkPay: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    currencyKey: $Enums.CurrencyEnum | null
    SubscriptionId: string | null
    methodKey: $Enums.PaymentMethodEnum | null
    transactionId: string | null
  }

  export type PaymentsCountAggregateOutputType = {
    id: number
    status: number
    amount: number
    exchangeRate: number
    token: number
    linkPay: number
    details: number
    createdAt: number
    updatedAt: number
    userId: number
    currencyKey: number
    SubscriptionId: number
    methodKey: number
    transactionId: number
    _all: number
  }


  export type PaymentsMinAggregateInputType = {
    id?: true
    status?: true
    amount?: true
    exchangeRate?: true
    token?: true
    linkPay?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    currencyKey?: true
    SubscriptionId?: true
    methodKey?: true
    transactionId?: true
  }

  export type PaymentsMaxAggregateInputType = {
    id?: true
    status?: true
    amount?: true
    exchangeRate?: true
    token?: true
    linkPay?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    currencyKey?: true
    SubscriptionId?: true
    methodKey?: true
    transactionId?: true
  }

  export type PaymentsCountAggregateInputType = {
    id?: true
    status?: true
    amount?: true
    exchangeRate?: true
    token?: true
    linkPay?: true
    details?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    currencyKey?: true
    SubscriptionId?: true
    methodKey?: true
    transactionId?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to aggregate.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type PaymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsWhereInput
    orderBy?: PaymentsOrderByWithAggregationInput | PaymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: PaymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    id: string
    status: $Enums.PaymentStatusEnum
    amount: string
    exchangeRate: string
    token: string
    linkPay: string | null
    details: JsonValue | null
    createdAt: Date
    updatedAt: Date
    userId: string
    currencyKey: $Enums.CurrencyEnum
    SubscriptionId: string | null
    methodKey: $Enums.PaymentMethodEnum
    transactionId: string | null
    _count: PaymentsCountAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends PaymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type PaymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    amount?: boolean
    exchangeRate?: boolean
    token?: boolean
    linkPay?: boolean
    details?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    currencyKey?: boolean
    SubscriptionId?: boolean
    methodKey?: boolean
    transactionId?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    Subscription?: boolean | Payments$SubscriptionArgs<ExtArgs>
    method?: boolean | PaymentMethodsDefaultArgs<ExtArgs>
    transacrion?: boolean | Payments$transacrionArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type PaymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    amount?: boolean
    exchangeRate?: boolean
    token?: boolean
    linkPay?: boolean
    details?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    currencyKey?: boolean
    SubscriptionId?: boolean
    methodKey?: boolean
    transactionId?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    Subscription?: boolean | Payments$SubscriptionArgs<ExtArgs>
    method?: boolean | PaymentMethodsDefaultArgs<ExtArgs>
    transacrion?: boolean | Payments$transacrionArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type PaymentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    amount?: boolean
    exchangeRate?: boolean
    token?: boolean
    linkPay?: boolean
    details?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    currencyKey?: boolean
    SubscriptionId?: boolean
    methodKey?: boolean
    transactionId?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    Subscription?: boolean | Payments$SubscriptionArgs<ExtArgs>
    method?: boolean | PaymentMethodsDefaultArgs<ExtArgs>
    transacrion?: boolean | Payments$transacrionArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type PaymentsSelectScalar = {
    id?: boolean
    status?: boolean
    amount?: boolean
    exchangeRate?: boolean
    token?: boolean
    linkPay?: boolean
    details?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    currencyKey?: boolean
    SubscriptionId?: boolean
    methodKey?: boolean
    transactionId?: boolean
  }

  export type PaymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "amount" | "exchangeRate" | "token" | "linkPay" | "details" | "createdAt" | "updatedAt" | "userId" | "currencyKey" | "SubscriptionId" | "methodKey" | "transactionId", ExtArgs["result"]["payments"]>
  export type PaymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    Subscription?: boolean | Payments$SubscriptionArgs<ExtArgs>
    method?: boolean | PaymentMethodsDefaultArgs<ExtArgs>
    transacrion?: boolean | Payments$transacrionArgs<ExtArgs>
  }
  export type PaymentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    Subscription?: boolean | Payments$SubscriptionArgs<ExtArgs>
    method?: boolean | PaymentMethodsDefaultArgs<ExtArgs>
    transacrion?: boolean | Payments$transacrionArgs<ExtArgs>
  }
  export type PaymentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    Subscription?: boolean | Payments$SubscriptionArgs<ExtArgs>
    method?: boolean | PaymentMethodsDefaultArgs<ExtArgs>
    transacrion?: boolean | Payments$transacrionArgs<ExtArgs>
  }

  export type $PaymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payments"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      currency: Prisma.$CurrencyPayload<ExtArgs>
      Subscription: Prisma.$SubscriptionsPayload<ExtArgs> | null
      method: Prisma.$PaymentMethodsPayload<ExtArgs>
      transacrion: Prisma.$TransactionsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.PaymentStatusEnum
      amount: string
      exchangeRate: string
      token: string
      linkPay: string | null
      details: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      userId: string
      currencyKey: $Enums.CurrencyEnum
      SubscriptionId: string | null
      methodKey: $Enums.PaymentMethodEnum
      transactionId: string | null
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type PaymentsGetPayload<S extends boolean | null | undefined | PaymentsDefaultArgs> = $Result.GetResult<Prisma.$PaymentsPayload, S>

  type PaymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface PaymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payments'], meta: { name: 'Payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {PaymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentsFindUniqueArgs>(args: SelectSubset<T, PaymentsFindUniqueArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentsFindFirstArgs>(args?: SelectSubset<T, PaymentsFindFirstArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentsWithIdOnly = await prisma.payments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentsFindManyArgs>(args?: SelectSubset<T, PaymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payments.
     * @param {PaymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
     */
    create<T extends PaymentsCreateArgs>(args: SelectSubset<T, PaymentsCreateArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentsCreateManyArgs>(args?: SelectSubset<T, PaymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentsCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payments.
     * @param {PaymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
     */
    delete<T extends PaymentsDeleteArgs>(args: SelectSubset<T, PaymentsDeleteArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payments.
     * @param {PaymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentsUpdateArgs>(args: SelectSubset<T, PaymentsUpdateArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentsDeleteManyArgs>(args?: SelectSubset<T, PaymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentsUpdateManyArgs>(args: SelectSubset<T, PaymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentsUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentsUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payments.
     * @param {PaymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
     */
    upsert<T extends PaymentsUpsertArgs>(args: SelectSubset<T, PaymentsUpsertArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentsCountArgs>(
      args?: Subset<T, PaymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentsGroupByArgs['orderBy'] }
        : { orderBy?: PaymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payments model
   */
  readonly fields: PaymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    currency<T extends CurrencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CurrencyDefaultArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Subscription<T extends Payments$SubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Payments$SubscriptionArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    method<T extends PaymentMethodsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethodsDefaultArgs<ExtArgs>>): Prisma__PaymentMethodsClient<$Result.GetResult<Prisma.$PaymentMethodsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transacrion<T extends Payments$transacrionArgs<ExtArgs> = {}>(args?: Subset<T, Payments$transacrionArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payments model
   */ 
  interface PaymentsFieldRefs {
    readonly id: FieldRef<"Payments", 'String'>
    readonly status: FieldRef<"Payments", 'PaymentStatusEnum'>
    readonly amount: FieldRef<"Payments", 'String'>
    readonly exchangeRate: FieldRef<"Payments", 'String'>
    readonly token: FieldRef<"Payments", 'String'>
    readonly linkPay: FieldRef<"Payments", 'String'>
    readonly details: FieldRef<"Payments", 'Json'>
    readonly createdAt: FieldRef<"Payments", 'DateTime'>
    readonly updatedAt: FieldRef<"Payments", 'DateTime'>
    readonly userId: FieldRef<"Payments", 'String'>
    readonly currencyKey: FieldRef<"Payments", 'CurrencyEnum'>
    readonly SubscriptionId: FieldRef<"Payments", 'String'>
    readonly methodKey: FieldRef<"Payments", 'PaymentMethodEnum'>
    readonly transactionId: FieldRef<"Payments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Payments findUnique
   */
  export type PaymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments findUniqueOrThrow
   */
  export type PaymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments findFirst
   */
  export type PaymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Payments findFirstOrThrow
   */
  export type PaymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Payments findMany
   */
  export type PaymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Payments create
   */
  export type PaymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Payments.
     */
    data: XOR<PaymentsCreateInput, PaymentsUncheckedCreateInput>
  }

  /**
   * Payments createMany
   */
  export type PaymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentsCreateManyInput | PaymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payments createManyAndReturn
   */
  export type PaymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentsCreateManyInput | PaymentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payments update
   */
  export type PaymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Payments.
     */
    data: XOR<PaymentsUpdateInput, PaymentsUncheckedUpdateInput>
    /**
     * Choose, which Payments to update.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments updateMany
   */
  export type PaymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentsWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payments updateManyAndReturn
   */
  export type PaymentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentsWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payments upsert
   */
  export type PaymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Payments to update in case it exists.
     */
    where: PaymentsWhereUniqueInput
    /**
     * In case the Payments found by the `where` argument doesn't exist, create a new Payments with this data.
     */
    create: XOR<PaymentsCreateInput, PaymentsUncheckedCreateInput>
    /**
     * In case the Payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentsUpdateInput, PaymentsUncheckedUpdateInput>
  }

  /**
   * Payments delete
   */
  export type PaymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter which Payments to delete.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments deleteMany
   */
  export type PaymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentsWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payments.Subscription
   */
  export type Payments$SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    where?: SubscriptionsWhereInput
  }

  /**
   * Payments.transacrion
   */
  export type Payments$transacrionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transactions
     */
    omit?: TransactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    where?: TransactionsWhereInput
  }

  /**
   * Payments without action
   */
  export type PaymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
  }


  /**
   * Model PaymentMethods
   */

  export type AggregatePaymentMethods = {
    _count: PaymentMethodsCountAggregateOutputType | null
    _avg: PaymentMethodsAvgAggregateOutputType | null
    _sum: PaymentMethodsSumAggregateOutputType | null
    _min: PaymentMethodsMinAggregateOutputType | null
    _max: PaymentMethodsMaxAggregateOutputType | null
  }

  export type PaymentMethodsAvgAggregateOutputType = {
    minAmount: number | null
    maxAmount: number | null
    commission: number | null
  }

  export type PaymentMethodsSumAggregateOutputType = {
    minAmount: number | null
    maxAmount: number | null
    commission: number | null
  }

  export type PaymentMethodsMinAggregateOutputType = {
    key: $Enums.PaymentMethodEnum | null
    name: string | null
    isActive: boolean | null
    isTonBlockchain: boolean | null
    tonSmartContractAddress: string | null
    minAmount: number | null
    maxAmount: number | null
    commission: number | null
    isPlusCommission: boolean | null
    type: $Enums.PaymentMethodTypeEnum | null
    system: $Enums.PaymentSystemEnum | null
    currencyKey: $Enums.CurrencyEnum | null
  }

  export type PaymentMethodsMaxAggregateOutputType = {
    key: $Enums.PaymentMethodEnum | null
    name: string | null
    isActive: boolean | null
    isTonBlockchain: boolean | null
    tonSmartContractAddress: string | null
    minAmount: number | null
    maxAmount: number | null
    commission: number | null
    isPlusCommission: boolean | null
    type: $Enums.PaymentMethodTypeEnum | null
    system: $Enums.PaymentSystemEnum | null
    currencyKey: $Enums.CurrencyEnum | null
  }

  export type PaymentMethodsCountAggregateOutputType = {
    key: number
    name: number
    isActive: number
    isTonBlockchain: number
    tonSmartContractAddress: number
    minAmount: number
    maxAmount: number
    commission: number
    isPlusCommission: number
    type: number
    system: number
    currencyKey: number
    _all: number
  }


  export type PaymentMethodsAvgAggregateInputType = {
    minAmount?: true
    maxAmount?: true
    commission?: true
  }

  export type PaymentMethodsSumAggregateInputType = {
    minAmount?: true
    maxAmount?: true
    commission?: true
  }

  export type PaymentMethodsMinAggregateInputType = {
    key?: true
    name?: true
    isActive?: true
    isTonBlockchain?: true
    tonSmartContractAddress?: true
    minAmount?: true
    maxAmount?: true
    commission?: true
    isPlusCommission?: true
    type?: true
    system?: true
    currencyKey?: true
  }

  export type PaymentMethodsMaxAggregateInputType = {
    key?: true
    name?: true
    isActive?: true
    isTonBlockchain?: true
    tonSmartContractAddress?: true
    minAmount?: true
    maxAmount?: true
    commission?: true
    isPlusCommission?: true
    type?: true
    system?: true
    currencyKey?: true
  }

  export type PaymentMethodsCountAggregateInputType = {
    key?: true
    name?: true
    isActive?: true
    isTonBlockchain?: true
    tonSmartContractAddress?: true
    minAmount?: true
    maxAmount?: true
    commission?: true
    isPlusCommission?: true
    type?: true
    system?: true
    currencyKey?: true
    _all?: true
  }

  export type PaymentMethodsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethods to aggregate.
     */
    where?: PaymentMethodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodsOrderByWithRelationInput | PaymentMethodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMethodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMethods
    **/
    _count?: true | PaymentMethodsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentMethodsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentMethodsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMethodsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMethodsMaxAggregateInputType
  }

  export type GetPaymentMethodsAggregateType<T extends PaymentMethodsAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMethods]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMethods[P]>
      : GetScalarType<T[P], AggregatePaymentMethods[P]>
  }




  export type PaymentMethodsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodsWhereInput
    orderBy?: PaymentMethodsOrderByWithAggregationInput | PaymentMethodsOrderByWithAggregationInput[]
    by: PaymentMethodsScalarFieldEnum[] | PaymentMethodsScalarFieldEnum
    having?: PaymentMethodsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMethodsCountAggregateInputType | true
    _avg?: PaymentMethodsAvgAggregateInputType
    _sum?: PaymentMethodsSumAggregateInputType
    _min?: PaymentMethodsMinAggregateInputType
    _max?: PaymentMethodsMaxAggregateInputType
  }

  export type PaymentMethodsGroupByOutputType = {
    key: $Enums.PaymentMethodEnum
    name: string
    isActive: boolean
    isTonBlockchain: boolean
    tonSmartContractAddress: string | null
    minAmount: number
    maxAmount: number
    commission: number
    isPlusCommission: boolean
    type: $Enums.PaymentMethodTypeEnum
    system: $Enums.PaymentSystemEnum
    currencyKey: $Enums.CurrencyEnum
    _count: PaymentMethodsCountAggregateOutputType | null
    _avg: PaymentMethodsAvgAggregateOutputType | null
    _sum: PaymentMethodsSumAggregateOutputType | null
    _min: PaymentMethodsMinAggregateOutputType | null
    _max: PaymentMethodsMaxAggregateOutputType | null
  }

  type GetPaymentMethodsGroupByPayload<T extends PaymentMethodsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMethodsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMethodsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMethodsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMethodsGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMethodsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    name?: boolean
    isActive?: boolean
    isTonBlockchain?: boolean
    tonSmartContractAddress?: boolean
    minAmount?: boolean
    maxAmount?: boolean
    commission?: boolean
    isPlusCommission?: boolean
    type?: boolean
    system?: boolean
    currencyKey?: boolean
    payments?: boolean | PaymentMethods$paymentsArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    _count?: boolean | PaymentMethodsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethods"]>

  export type PaymentMethodsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    name?: boolean
    isActive?: boolean
    isTonBlockchain?: boolean
    tonSmartContractAddress?: boolean
    minAmount?: boolean
    maxAmount?: boolean
    commission?: boolean
    isPlusCommission?: boolean
    type?: boolean
    system?: boolean
    currencyKey?: boolean
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethods"]>

  export type PaymentMethodsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    name?: boolean
    isActive?: boolean
    isTonBlockchain?: boolean
    tonSmartContractAddress?: boolean
    minAmount?: boolean
    maxAmount?: boolean
    commission?: boolean
    isPlusCommission?: boolean
    type?: boolean
    system?: boolean
    currencyKey?: boolean
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethods"]>

  export type PaymentMethodsSelectScalar = {
    key?: boolean
    name?: boolean
    isActive?: boolean
    isTonBlockchain?: boolean
    tonSmartContractAddress?: boolean
    minAmount?: boolean
    maxAmount?: boolean
    commission?: boolean
    isPlusCommission?: boolean
    type?: boolean
    system?: boolean
    currencyKey?: boolean
  }

  export type PaymentMethodsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "name" | "isActive" | "isTonBlockchain" | "tonSmartContractAddress" | "minAmount" | "maxAmount" | "commission" | "isPlusCommission" | "type" | "system" | "currencyKey", ExtArgs["result"]["paymentMethods"]>
  export type PaymentMethodsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | PaymentMethods$paymentsArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    _count?: boolean | PaymentMethodsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentMethodsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }
  export type PaymentMethodsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }

  export type $PaymentMethodsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMethods"
    objects: {
      payments: Prisma.$PaymentsPayload<ExtArgs>[]
      currency: Prisma.$CurrencyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      key: $Enums.PaymentMethodEnum
      name: string
      isActive: boolean
      isTonBlockchain: boolean
      tonSmartContractAddress: string | null
      minAmount: number
      maxAmount: number
      commission: number
      isPlusCommission: boolean
      type: $Enums.PaymentMethodTypeEnum
      system: $Enums.PaymentSystemEnum
      currencyKey: $Enums.CurrencyEnum
    }, ExtArgs["result"]["paymentMethods"]>
    composites: {}
  }

  type PaymentMethodsGetPayload<S extends boolean | null | undefined | PaymentMethodsDefaultArgs> = $Result.GetResult<Prisma.$PaymentMethodsPayload, S>

  type PaymentMethodsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentMethodsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentMethodsCountAggregateInputType | true
    }

  export interface PaymentMethodsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMethods'], meta: { name: 'PaymentMethods' } }
    /**
     * Find zero or one PaymentMethods that matches the filter.
     * @param {PaymentMethodsFindUniqueArgs} args - Arguments to find a PaymentMethods
     * @example
     * // Get one PaymentMethods
     * const paymentMethods = await prisma.paymentMethods.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMethodsFindUniqueArgs>(args: SelectSubset<T, PaymentMethodsFindUniqueArgs<ExtArgs>>): Prisma__PaymentMethodsClient<$Result.GetResult<Prisma.$PaymentMethodsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentMethods that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentMethodsFindUniqueOrThrowArgs} args - Arguments to find a PaymentMethods
     * @example
     * // Get one PaymentMethods
     * const paymentMethods = await prisma.paymentMethods.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMethodsFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMethodsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodsClient<$Result.GetResult<Prisma.$PaymentMethodsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodsFindFirstArgs} args - Arguments to find a PaymentMethods
     * @example
     * // Get one PaymentMethods
     * const paymentMethods = await prisma.paymentMethods.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMethodsFindFirstArgs>(args?: SelectSubset<T, PaymentMethodsFindFirstArgs<ExtArgs>>): Prisma__PaymentMethodsClient<$Result.GetResult<Prisma.$PaymentMethodsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethods that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodsFindFirstOrThrowArgs} args - Arguments to find a PaymentMethods
     * @example
     * // Get one PaymentMethods
     * const paymentMethods = await prisma.paymentMethods.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMethodsFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMethodsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodsClient<$Result.GetResult<Prisma.$PaymentMethodsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMethods
     * const paymentMethods = await prisma.paymentMethods.findMany()
     * 
     * // Get first 10 PaymentMethods
     * const paymentMethods = await prisma.paymentMethods.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const paymentMethodsWithNameOnly = await prisma.paymentMethods.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends PaymentMethodsFindManyArgs>(args?: SelectSubset<T, PaymentMethodsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentMethods.
     * @param {PaymentMethodsCreateArgs} args - Arguments to create a PaymentMethods.
     * @example
     * // Create one PaymentMethods
     * const PaymentMethods = await prisma.paymentMethods.create({
     *   data: {
     *     // ... data to create a PaymentMethods
     *   }
     * })
     * 
     */
    create<T extends PaymentMethodsCreateArgs>(args: SelectSubset<T, PaymentMethodsCreateArgs<ExtArgs>>): Prisma__PaymentMethodsClient<$Result.GetResult<Prisma.$PaymentMethodsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentMethods.
     * @param {PaymentMethodsCreateManyArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethods = await prisma.paymentMethods.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMethodsCreateManyArgs>(args?: SelectSubset<T, PaymentMethodsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentMethods and returns the data saved in the database.
     * @param {PaymentMethodsCreateManyAndReturnArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethods = await prisma.paymentMethods.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentMethods and only return the `name`
     * const paymentMethodsWithNameOnly = await prisma.paymentMethods.createManyAndReturn({
     *   select: { name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentMethodsCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentMethodsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentMethods.
     * @param {PaymentMethodsDeleteArgs} args - Arguments to delete one PaymentMethods.
     * @example
     * // Delete one PaymentMethods
     * const PaymentMethods = await prisma.paymentMethods.delete({
     *   where: {
     *     // ... filter to delete one PaymentMethods
     *   }
     * })
     * 
     */
    delete<T extends PaymentMethodsDeleteArgs>(args: SelectSubset<T, PaymentMethodsDeleteArgs<ExtArgs>>): Prisma__PaymentMethodsClient<$Result.GetResult<Prisma.$PaymentMethodsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentMethods.
     * @param {PaymentMethodsUpdateArgs} args - Arguments to update one PaymentMethods.
     * @example
     * // Update one PaymentMethods
     * const paymentMethods = await prisma.paymentMethods.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMethodsUpdateArgs>(args: SelectSubset<T, PaymentMethodsUpdateArgs<ExtArgs>>): Prisma__PaymentMethodsClient<$Result.GetResult<Prisma.$PaymentMethodsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentMethods.
     * @param {PaymentMethodsDeleteManyArgs} args - Arguments to filter PaymentMethods to delete.
     * @example
     * // Delete a few PaymentMethods
     * const { count } = await prisma.paymentMethods.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMethodsDeleteManyArgs>(args?: SelectSubset<T, PaymentMethodsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMethods
     * const paymentMethods = await prisma.paymentMethods.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMethodsUpdateManyArgs>(args: SelectSubset<T, PaymentMethodsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods and returns the data updated in the database.
     * @param {PaymentMethodsUpdateManyAndReturnArgs} args - Arguments to update many PaymentMethods.
     * @example
     * // Update many PaymentMethods
     * const paymentMethods = await prisma.paymentMethods.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentMethods and only return the `name`
     * const paymentMethodsWithNameOnly = await prisma.paymentMethods.updateManyAndReturn({
     *   select: { name: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentMethodsUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentMethodsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentMethods.
     * @param {PaymentMethodsUpsertArgs} args - Arguments to update or create a PaymentMethods.
     * @example
     * // Update or create a PaymentMethods
     * const paymentMethods = await prisma.paymentMethods.upsert({
     *   create: {
     *     // ... data to create a PaymentMethods
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMethods we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMethodsUpsertArgs>(args: SelectSubset<T, PaymentMethodsUpsertArgs<ExtArgs>>): Prisma__PaymentMethodsClient<$Result.GetResult<Prisma.$PaymentMethodsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodsCountArgs} args - Arguments to filter PaymentMethods to count.
     * @example
     * // Count the number of PaymentMethods
     * const count = await prisma.paymentMethods.count({
     *   where: {
     *     // ... the filter for the PaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends PaymentMethodsCountArgs>(
      args?: Subset<T, PaymentMethodsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMethodsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMethodsAggregateArgs>(args: Subset<T, PaymentMethodsAggregateArgs>): Prisma.PrismaPromise<GetPaymentMethodsAggregateType<T>>

    /**
     * Group by PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMethodsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMethodsGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMethodsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMethodsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMethodsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMethods model
   */
  readonly fields: PaymentMethodsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMethods.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMethodsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payments<T extends PaymentMethods$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethods$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    currency<T extends CurrencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CurrencyDefaultArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMethods model
   */ 
  interface PaymentMethodsFieldRefs {
    readonly key: FieldRef<"PaymentMethods", 'PaymentMethodEnum'>
    readonly name: FieldRef<"PaymentMethods", 'String'>
    readonly isActive: FieldRef<"PaymentMethods", 'Boolean'>
    readonly isTonBlockchain: FieldRef<"PaymentMethods", 'Boolean'>
    readonly tonSmartContractAddress: FieldRef<"PaymentMethods", 'String'>
    readonly minAmount: FieldRef<"PaymentMethods", 'Float'>
    readonly maxAmount: FieldRef<"PaymentMethods", 'Float'>
    readonly commission: FieldRef<"PaymentMethods", 'Float'>
    readonly isPlusCommission: FieldRef<"PaymentMethods", 'Boolean'>
    readonly type: FieldRef<"PaymentMethods", 'PaymentMethodTypeEnum'>
    readonly system: FieldRef<"PaymentMethods", 'PaymentSystemEnum'>
    readonly currencyKey: FieldRef<"PaymentMethods", 'CurrencyEnum'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMethods findUnique
   */
  export type PaymentMethodsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethods
     */
    select?: PaymentMethodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethods
     */
    omit?: PaymentMethodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where: PaymentMethodsWhereUniqueInput
  }

  /**
   * PaymentMethods findUniqueOrThrow
   */
  export type PaymentMethodsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethods
     */
    select?: PaymentMethodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethods
     */
    omit?: PaymentMethodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where: PaymentMethodsWhereUniqueInput
  }

  /**
   * PaymentMethods findFirst
   */
  export type PaymentMethodsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethods
     */
    select?: PaymentMethodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethods
     */
    omit?: PaymentMethodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where?: PaymentMethodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodsOrderByWithRelationInput | PaymentMethodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodsScalarFieldEnum | PaymentMethodsScalarFieldEnum[]
  }

  /**
   * PaymentMethods findFirstOrThrow
   */
  export type PaymentMethodsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethods
     */
    select?: PaymentMethodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethods
     */
    omit?: PaymentMethodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where?: PaymentMethodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodsOrderByWithRelationInput | PaymentMethodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodsScalarFieldEnum | PaymentMethodsScalarFieldEnum[]
  }

  /**
   * PaymentMethods findMany
   */
  export type PaymentMethodsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethods
     */
    select?: PaymentMethodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethods
     */
    omit?: PaymentMethodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where?: PaymentMethodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodsOrderByWithRelationInput | PaymentMethodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMethods.
     */
    cursor?: PaymentMethodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    distinct?: PaymentMethodsScalarFieldEnum | PaymentMethodsScalarFieldEnum[]
  }

  /**
   * PaymentMethods create
   */
  export type PaymentMethodsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethods
     */
    select?: PaymentMethodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethods
     */
    omit?: PaymentMethodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodsInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentMethods.
     */
    data: XOR<PaymentMethodsCreateInput, PaymentMethodsUncheckedCreateInput>
  }

  /**
   * PaymentMethods createMany
   */
  export type PaymentMethodsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodsCreateManyInput | PaymentMethodsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethods createManyAndReturn
   */
  export type PaymentMethodsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethods
     */
    select?: PaymentMethodsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethods
     */
    omit?: PaymentMethodsOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodsCreateManyInput | PaymentMethodsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentMethods update
   */
  export type PaymentMethodsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethods
     */
    select?: PaymentMethodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethods
     */
    omit?: PaymentMethodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodsInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentMethods.
     */
    data: XOR<PaymentMethodsUpdateInput, PaymentMethodsUncheckedUpdateInput>
    /**
     * Choose, which PaymentMethods to update.
     */
    where: PaymentMethodsWhereUniqueInput
  }

  /**
   * PaymentMethods updateMany
   */
  export type PaymentMethodsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodsUpdateManyMutationInput, PaymentMethodsUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodsWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethods updateManyAndReturn
   */
  export type PaymentMethodsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethods
     */
    select?: PaymentMethodsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethods
     */
    omit?: PaymentMethodsOmit<ExtArgs> | null
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodsUpdateManyMutationInput, PaymentMethodsUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodsWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentMethods upsert
   */
  export type PaymentMethodsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethods
     */
    select?: PaymentMethodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethods
     */
    omit?: PaymentMethodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodsInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentMethods to update in case it exists.
     */
    where: PaymentMethodsWhereUniqueInput
    /**
     * In case the PaymentMethods found by the `where` argument doesn't exist, create a new PaymentMethods with this data.
     */
    create: XOR<PaymentMethodsCreateInput, PaymentMethodsUncheckedCreateInput>
    /**
     * In case the PaymentMethods was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMethodsUpdateInput, PaymentMethodsUncheckedUpdateInput>
  }

  /**
   * PaymentMethods delete
   */
  export type PaymentMethodsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethods
     */
    select?: PaymentMethodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethods
     */
    omit?: PaymentMethodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodsInclude<ExtArgs> | null
    /**
     * Filter which PaymentMethods to delete.
     */
    where: PaymentMethodsWhereUniqueInput
  }

  /**
   * PaymentMethods deleteMany
   */
  export type PaymentMethodsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethods to delete
     */
    where?: PaymentMethodsWhereInput
    /**
     * Limit how many PaymentMethods to delete.
     */
    limit?: number
  }

  /**
   * PaymentMethods.payments
   */
  export type PaymentMethods$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    where?: PaymentsWhereInput
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    cursor?: PaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * PaymentMethods without action
   */
  export type PaymentMethodsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethods
     */
    select?: PaymentMethodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethods
     */
    omit?: PaymentMethodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SettingsScalarFieldEnum: {
    key: 'key',
    tgStarsToUSD: 'tgStarsToUSD',
    priceSubscriptionStars: 'priceSubscriptionStars',
    comissionStarsToTon: 'comissionStarsToTon',
    adsRewardStars: 'adsRewardStars',
    adsTaskRewardStars: 'adsTaskRewardStars',
    hourRatioPayment: 'hourRatioPayment',
    dayRatioPayment: 'dayRatioPayment',
    threeMouthesRatioPayment: 'threeMouthesRatioPayment',
    sixMouthesRatioPayment: 'sixMouthesRatioPayment',
    oneYearRatioPayment: 'oneYearRatioPayment',
    twoYearRatioPayment: 'twoYearRatioPayment',
    threeYearRatioPayment: 'threeYearRatioPayment',
    referralOneLevelPercent: 'referralOneLevelPercent',
    referralTwoLevelPercent: 'referralTwoLevelPercent',
    referralThreeLevelPercent: 'referralThreeLevelPercent',
    referralInviteRewardStars: 'referralInviteRewardStars',
    referralInvitePremiumRewardStars: 'referralInvitePremiumRewardStars',
    limitDevices: 'limitDevices',
    freePlanDays: 'freePlanDays',
    freePlanDaysForReferrals: 'freePlanDaysForReferrals'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const UserTelegramDataScalarFieldEnum: {
    id: 'id',
    isLive: 'isLive',
    isRtl: 'isRtl',
    isPremium: 'isPremium',
    isBot: 'isBot',
    firstName: 'firstName',
    lastName: 'lastName',
    username: 'username',
    languageCode: 'languageCode',
    photoUrl: 'photoUrl',
    addedToAttachmentMenu: 'addedToAttachmentMenu',
    allowsWriteToPm: 'allowsWriteToPm',
    updatedAt: 'updatedAt'
  };

  export type UserTelegramDataScalarFieldEnum = (typeof UserTelegramDataScalarFieldEnum)[keyof typeof UserTelegramDataScalarFieldEnum]


  export const ReferralsScalarFieldEnum: {
    id: 'id',
    level: 'level',
    inviterId: 'inviterId',
    referralId: 'referralId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReferralsScalarFieldEnum = (typeof ReferralsScalarFieldEnum)[keyof typeof ReferralsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    telegramId: 'telegramId',
    tonWallet: 'tonWallet',
    isFreePlanAvailable: 'isFreePlanAvailable',
    isBanned: 'isBanned',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastStartedAt: 'lastStartedAt',
    banExpiredAt: 'banExpiredAt',
    deletedAt: 'deletedAt',
    roleId: 'roleId',
    telegramDataId: 'telegramDataId',
    balanceId: 'balanceId',
    languageId: 'languageId'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const AdsViewsScalarFieldEnum: {
    id: 'id',
    networkKey: 'networkKey',
    type: 'type',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type AdsViewsScalarFieldEnum = (typeof AdsViewsScalarFieldEnum)[keyof typeof AdsViewsScalarFieldEnum]


  export const AdsNetworksScalarFieldEnum: {
    key: 'key',
    isActive: 'isActive',
    name: 'name'
  };

  export type AdsNetworksScalarFieldEnum = (typeof AdsNetworksScalarFieldEnum)[keyof typeof AdsNetworksScalarFieldEnum]


  export const UserBalanceScalarFieldEnum: {
    id: 'id',
    paymentBalance: 'paymentBalance',
    holdBalance: 'holdBalance',
    totalEarnedWithdrawalBalance: 'totalEarnedWithdrawalBalance',
    withdrawalBalance: 'withdrawalBalance',
    isUseWithdrawalBalance: 'isUseWithdrawalBalance',
    updatedAt: 'updatedAt'
  };

  export type UserBalanceScalarFieldEnum = (typeof UserBalanceScalarFieldEnum)[keyof typeof UserBalanceScalarFieldEnum]


  export const SubscriptionsScalarFieldEnum: {
    id: 'id',
    username: 'username',
    isActive: 'isActive',
    isAutoRenewal: 'isAutoRenewal',
    token: 'token',
    period: 'period',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    expiredAt: 'expiredAt',
    userId: 'userId'
  };

  export type SubscriptionsScalarFieldEnum = (typeof SubscriptionsScalarFieldEnum)[keyof typeof SubscriptionsScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    key: 'key',
    name: 'name',
    discount: 'discount',
    limitSubscriptions: 'limitSubscriptions'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const LanguageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    nativeName: 'nativeName',
    iso6391: 'iso6391',
    iso6392: 'iso6392',
    iso6393: 'iso6393'
  };

  export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


  export const CurrencyScalarFieldEnum: {
    key: 'key',
    name: 'name',
    symbol: 'symbol',
    rate: 'rate',
    coinmarketcapUCID: 'coinmarketcapUCID',
    updatedAt: 'updatedAt'
  };

  export type CurrencyScalarFieldEnum = (typeof CurrencyScalarFieldEnum)[keyof typeof CurrencyScalarFieldEnum]


  export const TransactionsScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    isHold: 'isHold',
    type: 'type',
    reason: 'reason',
    balanceType: 'balanceType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    holdExpiredAt: 'holdExpiredAt',
    balanceId: 'balanceId'
  };

  export type TransactionsScalarFieldEnum = (typeof TransactionsScalarFieldEnum)[keyof typeof TransactionsScalarFieldEnum]


  export const WithdrawalsScalarFieldEnum: {
    id: 'id',
    status: 'status',
    amountStars: 'amountStars',
    amountUSD: 'amountUSD',
    amountTON: 'amountTON',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    transactionId: 'transactionId'
  };

  export type WithdrawalsScalarFieldEnum = (typeof WithdrawalsScalarFieldEnum)[keyof typeof WithdrawalsScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    id: 'id',
    status: 'status',
    amount: 'amount',
    exchangeRate: 'exchangeRate',
    token: 'token',
    linkPay: 'linkPay',
    details: 'details',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    currencyKey: 'currencyKey',
    SubscriptionId: 'SubscriptionId',
    methodKey: 'methodKey',
    transactionId: 'transactionId'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const PaymentMethodsScalarFieldEnum: {
    key: 'key',
    name: 'name',
    isActive: 'isActive',
    isTonBlockchain: 'isTonBlockchain',
    tonSmartContractAddress: 'tonSmartContractAddress',
    minAmount: 'minAmount',
    maxAmount: 'maxAmount',
    commission: 'commission',
    isPlusCommission: 'isPlusCommission',
    type: 'type',
    system: 'system',
    currencyKey: 'currencyKey'
  };

  export type PaymentMethodsScalarFieldEnum = (typeof PaymentMethodsScalarFieldEnum)[keyof typeof PaymentMethodsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'DefaultEnum'
   */
  export type EnumDefaultEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DefaultEnum'>
    


  /**
   * Reference to a field of type 'DefaultEnum[]'
   */
  export type ListEnumDefaultEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DefaultEnum[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRoleEnum'
   */
  export type EnumUserRoleEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRoleEnum'>
    


  /**
   * Reference to a field of type 'UserRoleEnum[]'
   */
  export type ListEnumUserRoleEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRoleEnum[]'>
    


  /**
   * Reference to a field of type 'AdsNetworkEnum'
   */
  export type EnumAdsNetworkEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdsNetworkEnum'>
    


  /**
   * Reference to a field of type 'AdsNetworkEnum[]'
   */
  export type ListEnumAdsNetworkEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdsNetworkEnum[]'>
    


  /**
   * Reference to a field of type 'AdsViewTypeEnum'
   */
  export type EnumAdsViewTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdsViewTypeEnum'>
    


  /**
   * Reference to a field of type 'AdsViewTypeEnum[]'
   */
  export type ListEnumAdsViewTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdsViewTypeEnum[]'>
    


  /**
   * Reference to a field of type 'SubscriptionPeriodEnum'
   */
  export type EnumSubscriptionPeriodEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPeriodEnum'>
    


  /**
   * Reference to a field of type 'SubscriptionPeriodEnum[]'
   */
  export type ListEnumSubscriptionPeriodEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPeriodEnum[]'>
    


  /**
   * Reference to a field of type 'CurrencyEnum'
   */
  export type EnumCurrencyEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CurrencyEnum'>
    


  /**
   * Reference to a field of type 'CurrencyEnum[]'
   */
  export type ListEnumCurrencyEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CurrencyEnum[]'>
    


  /**
   * Reference to a field of type 'TransactionTypeEnum'
   */
  export type EnumTransactionTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionTypeEnum'>
    


  /**
   * Reference to a field of type 'TransactionTypeEnum[]'
   */
  export type ListEnumTransactionTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionTypeEnum[]'>
    


  /**
   * Reference to a field of type 'TransactionReasonEnum'
   */
  export type EnumTransactionReasonEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionReasonEnum'>
    


  /**
   * Reference to a field of type 'TransactionReasonEnum[]'
   */
  export type ListEnumTransactionReasonEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionReasonEnum[]'>
    


  /**
   * Reference to a field of type 'BalanceTypeEnum'
   */
  export type EnumBalanceTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BalanceTypeEnum'>
    


  /**
   * Reference to a field of type 'BalanceTypeEnum[]'
   */
  export type ListEnumBalanceTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BalanceTypeEnum[]'>
    


  /**
   * Reference to a field of type 'WithdrawalStatusEnum'
   */
  export type EnumWithdrawalStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WithdrawalStatusEnum'>
    


  /**
   * Reference to a field of type 'WithdrawalStatusEnum[]'
   */
  export type ListEnumWithdrawalStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WithdrawalStatusEnum[]'>
    


  /**
   * Reference to a field of type 'PaymentStatusEnum'
   */
  export type EnumPaymentStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatusEnum'>
    


  /**
   * Reference to a field of type 'PaymentStatusEnum[]'
   */
  export type ListEnumPaymentStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatusEnum[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'PaymentMethodEnum'
   */
  export type EnumPaymentMethodEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethodEnum'>
    


  /**
   * Reference to a field of type 'PaymentMethodEnum[]'
   */
  export type ListEnumPaymentMethodEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethodEnum[]'>
    


  /**
   * Reference to a field of type 'PaymentMethodTypeEnum'
   */
  export type EnumPaymentMethodTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethodTypeEnum'>
    


  /**
   * Reference to a field of type 'PaymentMethodTypeEnum[]'
   */
  export type ListEnumPaymentMethodTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethodTypeEnum[]'>
    


  /**
   * Reference to a field of type 'PaymentSystemEnum'
   */
  export type EnumPaymentSystemEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentSystemEnum'>
    


  /**
   * Reference to a field of type 'PaymentSystemEnum[]'
   */
  export type ListEnumPaymentSystemEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentSystemEnum[]'>
    
  /**
   * Deep Input Types
   */


  export type SettingsWhereInput = {
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    key?: EnumDefaultEnumFilter<"Settings"> | $Enums.DefaultEnum
    tgStarsToUSD?: FloatFilter<"Settings"> | number
    priceSubscriptionStars?: IntFilter<"Settings"> | number
    comissionStarsToTon?: FloatFilter<"Settings"> | number
    adsRewardStars?: FloatFilter<"Settings"> | number
    adsTaskRewardStars?: FloatFilter<"Settings"> | number
    hourRatioPayment?: FloatFilter<"Settings"> | number
    dayRatioPayment?: FloatFilter<"Settings"> | number
    threeMouthesRatioPayment?: FloatFilter<"Settings"> | number
    sixMouthesRatioPayment?: FloatFilter<"Settings"> | number
    oneYearRatioPayment?: FloatFilter<"Settings"> | number
    twoYearRatioPayment?: FloatFilter<"Settings"> | number
    threeYearRatioPayment?: FloatFilter<"Settings"> | number
    referralOneLevelPercent?: FloatFilter<"Settings"> | number
    referralTwoLevelPercent?: FloatFilter<"Settings"> | number
    referralThreeLevelPercent?: FloatFilter<"Settings"> | number
    referralInviteRewardStars?: FloatFilter<"Settings"> | number
    referralInvitePremiumRewardStars?: FloatFilter<"Settings"> | number
    limitDevices?: IntFilter<"Settings"> | number
    freePlanDays?: IntFilter<"Settings"> | number
    freePlanDaysForReferrals?: IntFilter<"Settings"> | number
  }

  export type SettingsOrderByWithRelationInput = {
    key?: SortOrder
    tgStarsToUSD?: SortOrder
    priceSubscriptionStars?: SortOrder
    comissionStarsToTon?: SortOrder
    adsRewardStars?: SortOrder
    adsTaskRewardStars?: SortOrder
    hourRatioPayment?: SortOrder
    dayRatioPayment?: SortOrder
    threeMouthesRatioPayment?: SortOrder
    sixMouthesRatioPayment?: SortOrder
    oneYearRatioPayment?: SortOrder
    twoYearRatioPayment?: SortOrder
    threeYearRatioPayment?: SortOrder
    referralOneLevelPercent?: SortOrder
    referralTwoLevelPercent?: SortOrder
    referralThreeLevelPercent?: SortOrder
    referralInviteRewardStars?: SortOrder
    referralInvitePremiumRewardStars?: SortOrder
    limitDevices?: SortOrder
    freePlanDays?: SortOrder
    freePlanDaysForReferrals?: SortOrder
  }

  export type SettingsWhereUniqueInput = Prisma.AtLeast<{
    key?: $Enums.DefaultEnum
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    tgStarsToUSD?: FloatFilter<"Settings"> | number
    priceSubscriptionStars?: IntFilter<"Settings"> | number
    comissionStarsToTon?: FloatFilter<"Settings"> | number
    adsRewardStars?: FloatFilter<"Settings"> | number
    adsTaskRewardStars?: FloatFilter<"Settings"> | number
    hourRatioPayment?: FloatFilter<"Settings"> | number
    dayRatioPayment?: FloatFilter<"Settings"> | number
    threeMouthesRatioPayment?: FloatFilter<"Settings"> | number
    sixMouthesRatioPayment?: FloatFilter<"Settings"> | number
    oneYearRatioPayment?: FloatFilter<"Settings"> | number
    twoYearRatioPayment?: FloatFilter<"Settings"> | number
    threeYearRatioPayment?: FloatFilter<"Settings"> | number
    referralOneLevelPercent?: FloatFilter<"Settings"> | number
    referralTwoLevelPercent?: FloatFilter<"Settings"> | number
    referralThreeLevelPercent?: FloatFilter<"Settings"> | number
    referralInviteRewardStars?: FloatFilter<"Settings"> | number
    referralInvitePremiumRewardStars?: FloatFilter<"Settings"> | number
    limitDevices?: IntFilter<"Settings"> | number
    freePlanDays?: IntFilter<"Settings"> | number
    freePlanDaysForReferrals?: IntFilter<"Settings"> | number
  }, "key">

  export type SettingsOrderByWithAggregationInput = {
    key?: SortOrder
    tgStarsToUSD?: SortOrder
    priceSubscriptionStars?: SortOrder
    comissionStarsToTon?: SortOrder
    adsRewardStars?: SortOrder
    adsTaskRewardStars?: SortOrder
    hourRatioPayment?: SortOrder
    dayRatioPayment?: SortOrder
    threeMouthesRatioPayment?: SortOrder
    sixMouthesRatioPayment?: SortOrder
    oneYearRatioPayment?: SortOrder
    twoYearRatioPayment?: SortOrder
    threeYearRatioPayment?: SortOrder
    referralOneLevelPercent?: SortOrder
    referralTwoLevelPercent?: SortOrder
    referralThreeLevelPercent?: SortOrder
    referralInviteRewardStars?: SortOrder
    referralInvitePremiumRewardStars?: SortOrder
    limitDevices?: SortOrder
    freePlanDays?: SortOrder
    freePlanDaysForReferrals?: SortOrder
    _count?: SettingsCountOrderByAggregateInput
    _avg?: SettingsAvgOrderByAggregateInput
    _max?: SettingsMaxOrderByAggregateInput
    _min?: SettingsMinOrderByAggregateInput
    _sum?: SettingsSumOrderByAggregateInput
  }

  export type SettingsScalarWhereWithAggregatesInput = {
    AND?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    OR?: SettingsScalarWhereWithAggregatesInput[]
    NOT?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    key?: EnumDefaultEnumWithAggregatesFilter<"Settings"> | $Enums.DefaultEnum
    tgStarsToUSD?: FloatWithAggregatesFilter<"Settings"> | number
    priceSubscriptionStars?: IntWithAggregatesFilter<"Settings"> | number
    comissionStarsToTon?: FloatWithAggregatesFilter<"Settings"> | number
    adsRewardStars?: FloatWithAggregatesFilter<"Settings"> | number
    adsTaskRewardStars?: FloatWithAggregatesFilter<"Settings"> | number
    hourRatioPayment?: FloatWithAggregatesFilter<"Settings"> | number
    dayRatioPayment?: FloatWithAggregatesFilter<"Settings"> | number
    threeMouthesRatioPayment?: FloatWithAggregatesFilter<"Settings"> | number
    sixMouthesRatioPayment?: FloatWithAggregatesFilter<"Settings"> | number
    oneYearRatioPayment?: FloatWithAggregatesFilter<"Settings"> | number
    twoYearRatioPayment?: FloatWithAggregatesFilter<"Settings"> | number
    threeYearRatioPayment?: FloatWithAggregatesFilter<"Settings"> | number
    referralOneLevelPercent?: FloatWithAggregatesFilter<"Settings"> | number
    referralTwoLevelPercent?: FloatWithAggregatesFilter<"Settings"> | number
    referralThreeLevelPercent?: FloatWithAggregatesFilter<"Settings"> | number
    referralInviteRewardStars?: FloatWithAggregatesFilter<"Settings"> | number
    referralInvitePremiumRewardStars?: FloatWithAggregatesFilter<"Settings"> | number
    limitDevices?: IntWithAggregatesFilter<"Settings"> | number
    freePlanDays?: IntWithAggregatesFilter<"Settings"> | number
    freePlanDaysForReferrals?: IntWithAggregatesFilter<"Settings"> | number
  }

  export type UserTelegramDataWhereInput = {
    AND?: UserTelegramDataWhereInput | UserTelegramDataWhereInput[]
    OR?: UserTelegramDataWhereInput[]
    NOT?: UserTelegramDataWhereInput | UserTelegramDataWhereInput[]
    id?: StringFilter<"UserTelegramData"> | string
    isLive?: BoolFilter<"UserTelegramData"> | boolean
    isRtl?: BoolFilter<"UserTelegramData"> | boolean
    isPremium?: BoolFilter<"UserTelegramData"> | boolean
    isBot?: BoolFilter<"UserTelegramData"> | boolean
    firstName?: StringFilter<"UserTelegramData"> | string
    lastName?: StringNullableFilter<"UserTelegramData"> | string | null
    username?: StringNullableFilter<"UserTelegramData"> | string | null
    languageCode?: StringFilter<"UserTelegramData"> | string
    photoUrl?: StringNullableFilter<"UserTelegramData"> | string | null
    addedToAttachmentMenu?: BoolFilter<"UserTelegramData"> | boolean
    allowsWriteToPm?: BoolFilter<"UserTelegramData"> | boolean
    updatedAt?: DateTimeFilter<"UserTelegramData"> | Date | string
    user?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
  }

  export type UserTelegramDataOrderByWithRelationInput = {
    id?: SortOrder
    isLive?: SortOrder
    isRtl?: SortOrder
    isPremium?: SortOrder
    isBot?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    languageCode?: SortOrder
    photoUrl?: SortOrderInput | SortOrder
    addedToAttachmentMenu?: SortOrder
    allowsWriteToPm?: SortOrder
    updatedAt?: SortOrder
    user?: UsersOrderByWithRelationInput
  }

  export type UserTelegramDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserTelegramDataWhereInput | UserTelegramDataWhereInput[]
    OR?: UserTelegramDataWhereInput[]
    NOT?: UserTelegramDataWhereInput | UserTelegramDataWhereInput[]
    isLive?: BoolFilter<"UserTelegramData"> | boolean
    isRtl?: BoolFilter<"UserTelegramData"> | boolean
    isPremium?: BoolFilter<"UserTelegramData"> | boolean
    isBot?: BoolFilter<"UserTelegramData"> | boolean
    firstName?: StringFilter<"UserTelegramData"> | string
    lastName?: StringNullableFilter<"UserTelegramData"> | string | null
    username?: StringNullableFilter<"UserTelegramData"> | string | null
    languageCode?: StringFilter<"UserTelegramData"> | string
    photoUrl?: StringNullableFilter<"UserTelegramData"> | string | null
    addedToAttachmentMenu?: BoolFilter<"UserTelegramData"> | boolean
    allowsWriteToPm?: BoolFilter<"UserTelegramData"> | boolean
    updatedAt?: DateTimeFilter<"UserTelegramData"> | Date | string
    user?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
  }, "id">

  export type UserTelegramDataOrderByWithAggregationInput = {
    id?: SortOrder
    isLive?: SortOrder
    isRtl?: SortOrder
    isPremium?: SortOrder
    isBot?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    languageCode?: SortOrder
    photoUrl?: SortOrderInput | SortOrder
    addedToAttachmentMenu?: SortOrder
    allowsWriteToPm?: SortOrder
    updatedAt?: SortOrder
    _count?: UserTelegramDataCountOrderByAggregateInput
    _max?: UserTelegramDataMaxOrderByAggregateInput
    _min?: UserTelegramDataMinOrderByAggregateInput
  }

  export type UserTelegramDataScalarWhereWithAggregatesInput = {
    AND?: UserTelegramDataScalarWhereWithAggregatesInput | UserTelegramDataScalarWhereWithAggregatesInput[]
    OR?: UserTelegramDataScalarWhereWithAggregatesInput[]
    NOT?: UserTelegramDataScalarWhereWithAggregatesInput | UserTelegramDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserTelegramData"> | string
    isLive?: BoolWithAggregatesFilter<"UserTelegramData"> | boolean
    isRtl?: BoolWithAggregatesFilter<"UserTelegramData"> | boolean
    isPremium?: BoolWithAggregatesFilter<"UserTelegramData"> | boolean
    isBot?: BoolWithAggregatesFilter<"UserTelegramData"> | boolean
    firstName?: StringWithAggregatesFilter<"UserTelegramData"> | string
    lastName?: StringNullableWithAggregatesFilter<"UserTelegramData"> | string | null
    username?: StringNullableWithAggregatesFilter<"UserTelegramData"> | string | null
    languageCode?: StringWithAggregatesFilter<"UserTelegramData"> | string
    photoUrl?: StringNullableWithAggregatesFilter<"UserTelegramData"> | string | null
    addedToAttachmentMenu?: BoolWithAggregatesFilter<"UserTelegramData"> | boolean
    allowsWriteToPm?: BoolWithAggregatesFilter<"UserTelegramData"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"UserTelegramData"> | Date | string
  }

  export type ReferralsWhereInput = {
    AND?: ReferralsWhereInput | ReferralsWhereInput[]
    OR?: ReferralsWhereInput[]
    NOT?: ReferralsWhereInput | ReferralsWhereInput[]
    id?: StringFilter<"Referrals"> | string
    level?: IntFilter<"Referrals"> | number
    inviterId?: StringFilter<"Referrals"> | string
    referralId?: StringFilter<"Referrals"> | string
    createdAt?: DateTimeFilter<"Referrals"> | Date | string
    updatedAt?: DateTimeFilter<"Referrals"> | Date | string
    inviter?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    referral?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type ReferralsOrderByWithRelationInput = {
    id?: SortOrder
    level?: SortOrder
    inviterId?: SortOrder
    referralId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inviter?: UsersOrderByWithRelationInput
    referral?: UsersOrderByWithRelationInput
  }

  export type ReferralsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReferralsWhereInput | ReferralsWhereInput[]
    OR?: ReferralsWhereInput[]
    NOT?: ReferralsWhereInput | ReferralsWhereInput[]
    level?: IntFilter<"Referrals"> | number
    inviterId?: StringFilter<"Referrals"> | string
    referralId?: StringFilter<"Referrals"> | string
    createdAt?: DateTimeFilter<"Referrals"> | Date | string
    updatedAt?: DateTimeFilter<"Referrals"> | Date | string
    inviter?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    referral?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id">

  export type ReferralsOrderByWithAggregationInput = {
    id?: SortOrder
    level?: SortOrder
    inviterId?: SortOrder
    referralId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReferralsCountOrderByAggregateInput
    _avg?: ReferralsAvgOrderByAggregateInput
    _max?: ReferralsMaxOrderByAggregateInput
    _min?: ReferralsMinOrderByAggregateInput
    _sum?: ReferralsSumOrderByAggregateInput
  }

  export type ReferralsScalarWhereWithAggregatesInput = {
    AND?: ReferralsScalarWhereWithAggregatesInput | ReferralsScalarWhereWithAggregatesInput[]
    OR?: ReferralsScalarWhereWithAggregatesInput[]
    NOT?: ReferralsScalarWhereWithAggregatesInput | ReferralsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Referrals"> | string
    level?: IntWithAggregatesFilter<"Referrals"> | number
    inviterId?: StringWithAggregatesFilter<"Referrals"> | string
    referralId?: StringWithAggregatesFilter<"Referrals"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Referrals"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Referrals"> | Date | string
  }

  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    id?: StringFilter<"Users"> | string
    telegramId?: StringFilter<"Users"> | string
    tonWallet?: StringNullableFilter<"Users"> | string | null
    isFreePlanAvailable?: BoolFilter<"Users"> | boolean
    isBanned?: BoolFilter<"Users"> | boolean
    isDeleted?: BoolFilter<"Users"> | boolean
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    lastStartedAt?: DateTimeNullableFilter<"Users"> | Date | string | null
    banExpiredAt?: DateTimeNullableFilter<"Users"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Users"> | Date | string | null
    roleId?: EnumUserRoleEnumFilter<"Users"> | $Enums.UserRoleEnum
    telegramDataId?: StringNullableFilter<"Users"> | string | null
    balanceId?: StringNullableFilter<"Users"> | string | null
    languageId?: StringFilter<"Users"> | string
    role?: XOR<RolesScalarRelationFilter, RolesWhereInput>
    payments?: PaymentsListRelationFilter
    referrals?: ReferralsListRelationFilter
    inviters?: ReferralsListRelationFilter
    telegramData?: XOR<UserTelegramDataNullableScalarRelationFilter, UserTelegramDataWhereInput> | null
    balance?: XOR<UserBalanceNullableScalarRelationFilter, UserBalanceWhereInput> | null
    language?: XOR<LanguageScalarRelationFilter, LanguageWhereInput>
    subscriptions?: SubscriptionsListRelationFilter
    withdrawals?: WithdrawalsListRelationFilter
    adsViews?: AdsViewsListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder
    telegramId?: SortOrder
    tonWallet?: SortOrderInput | SortOrder
    isFreePlanAvailable?: SortOrder
    isBanned?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastStartedAt?: SortOrderInput | SortOrder
    banExpiredAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    roleId?: SortOrder
    telegramDataId?: SortOrderInput | SortOrder
    balanceId?: SortOrderInput | SortOrder
    languageId?: SortOrder
    role?: RolesOrderByWithRelationInput
    payments?: PaymentsOrderByRelationAggregateInput
    referrals?: ReferralsOrderByRelationAggregateInput
    inviters?: ReferralsOrderByRelationAggregateInput
    telegramData?: UserTelegramDataOrderByWithRelationInput
    balance?: UserBalanceOrderByWithRelationInput
    language?: LanguageOrderByWithRelationInput
    subscriptions?: SubscriptionsOrderByRelationAggregateInput
    withdrawals?: WithdrawalsOrderByRelationAggregateInput
    adsViews?: AdsViewsOrderByRelationAggregateInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    telegramId?: string
    tonWallet?: string
    telegramDataId?: string
    balanceId?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    isFreePlanAvailable?: BoolFilter<"Users"> | boolean
    isBanned?: BoolFilter<"Users"> | boolean
    isDeleted?: BoolFilter<"Users"> | boolean
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    lastStartedAt?: DateTimeNullableFilter<"Users"> | Date | string | null
    banExpiredAt?: DateTimeNullableFilter<"Users"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Users"> | Date | string | null
    roleId?: EnumUserRoleEnumFilter<"Users"> | $Enums.UserRoleEnum
    languageId?: StringFilter<"Users"> | string
    role?: XOR<RolesScalarRelationFilter, RolesWhereInput>
    payments?: PaymentsListRelationFilter
    referrals?: ReferralsListRelationFilter
    inviters?: ReferralsListRelationFilter
    telegramData?: XOR<UserTelegramDataNullableScalarRelationFilter, UserTelegramDataWhereInput> | null
    balance?: XOR<UserBalanceNullableScalarRelationFilter, UserBalanceWhereInput> | null
    language?: XOR<LanguageScalarRelationFilter, LanguageWhereInput>
    subscriptions?: SubscriptionsListRelationFilter
    withdrawals?: WithdrawalsListRelationFilter
    adsViews?: AdsViewsListRelationFilter
  }, "id" | "telegramId" | "tonWallet" | "telegramDataId" | "balanceId">

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder
    telegramId?: SortOrder
    tonWallet?: SortOrderInput | SortOrder
    isFreePlanAvailable?: SortOrder
    isBanned?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastStartedAt?: SortOrderInput | SortOrder
    banExpiredAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    roleId?: SortOrder
    telegramDataId?: SortOrderInput | SortOrder
    balanceId?: SortOrderInput | SortOrder
    languageId?: SortOrder
    _count?: UsersCountOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Users"> | string
    telegramId?: StringWithAggregatesFilter<"Users"> | string
    tonWallet?: StringNullableWithAggregatesFilter<"Users"> | string | null
    isFreePlanAvailable?: BoolWithAggregatesFilter<"Users"> | boolean
    isBanned?: BoolWithAggregatesFilter<"Users"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"Users"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    lastStartedAt?: DateTimeNullableWithAggregatesFilter<"Users"> | Date | string | null
    banExpiredAt?: DateTimeNullableWithAggregatesFilter<"Users"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Users"> | Date | string | null
    roleId?: EnumUserRoleEnumWithAggregatesFilter<"Users"> | $Enums.UserRoleEnum
    telegramDataId?: StringNullableWithAggregatesFilter<"Users"> | string | null
    balanceId?: StringNullableWithAggregatesFilter<"Users"> | string | null
    languageId?: StringWithAggregatesFilter<"Users"> | string
  }

  export type AdsViewsWhereInput = {
    AND?: AdsViewsWhereInput | AdsViewsWhereInput[]
    OR?: AdsViewsWhereInput[]
    NOT?: AdsViewsWhereInput | AdsViewsWhereInput[]
    id?: StringFilter<"AdsViews"> | string
    networkKey?: EnumAdsNetworkEnumFilter<"AdsViews"> | $Enums.AdsNetworkEnum
    type?: EnumAdsViewTypeEnumFilter<"AdsViews"> | $Enums.AdsViewTypeEnum
    createdAt?: DateTimeFilter<"AdsViews"> | Date | string
    userId?: StringFilter<"AdsViews"> | string
    network?: XOR<AdsNetworksScalarRelationFilter, AdsNetworksWhereInput>
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type AdsViewsOrderByWithRelationInput = {
    id?: SortOrder
    networkKey?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    network?: AdsNetworksOrderByWithRelationInput
    user?: UsersOrderByWithRelationInput
  }

  export type AdsViewsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdsViewsWhereInput | AdsViewsWhereInput[]
    OR?: AdsViewsWhereInput[]
    NOT?: AdsViewsWhereInput | AdsViewsWhereInput[]
    networkKey?: EnumAdsNetworkEnumFilter<"AdsViews"> | $Enums.AdsNetworkEnum
    type?: EnumAdsViewTypeEnumFilter<"AdsViews"> | $Enums.AdsViewTypeEnum
    createdAt?: DateTimeFilter<"AdsViews"> | Date | string
    userId?: StringFilter<"AdsViews"> | string
    network?: XOR<AdsNetworksScalarRelationFilter, AdsNetworksWhereInput>
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id">

  export type AdsViewsOrderByWithAggregationInput = {
    id?: SortOrder
    networkKey?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    _count?: AdsViewsCountOrderByAggregateInput
    _max?: AdsViewsMaxOrderByAggregateInput
    _min?: AdsViewsMinOrderByAggregateInput
  }

  export type AdsViewsScalarWhereWithAggregatesInput = {
    AND?: AdsViewsScalarWhereWithAggregatesInput | AdsViewsScalarWhereWithAggregatesInput[]
    OR?: AdsViewsScalarWhereWithAggregatesInput[]
    NOT?: AdsViewsScalarWhereWithAggregatesInput | AdsViewsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdsViews"> | string
    networkKey?: EnumAdsNetworkEnumWithAggregatesFilter<"AdsViews"> | $Enums.AdsNetworkEnum
    type?: EnumAdsViewTypeEnumWithAggregatesFilter<"AdsViews"> | $Enums.AdsViewTypeEnum
    createdAt?: DateTimeWithAggregatesFilter<"AdsViews"> | Date | string
    userId?: StringWithAggregatesFilter<"AdsViews"> | string
  }

  export type AdsNetworksWhereInput = {
    AND?: AdsNetworksWhereInput | AdsNetworksWhereInput[]
    OR?: AdsNetworksWhereInput[]
    NOT?: AdsNetworksWhereInput | AdsNetworksWhereInput[]
    key?: EnumAdsNetworkEnumFilter<"AdsNetworks"> | $Enums.AdsNetworkEnum
    isActive?: BoolFilter<"AdsNetworks"> | boolean
    name?: StringFilter<"AdsNetworks"> | string
    adsViews?: AdsViewsListRelationFilter
  }

  export type AdsNetworksOrderByWithRelationInput = {
    key?: SortOrder
    isActive?: SortOrder
    name?: SortOrder
    adsViews?: AdsViewsOrderByRelationAggregateInput
  }

  export type AdsNetworksWhereUniqueInput = Prisma.AtLeast<{
    key?: $Enums.AdsNetworkEnum
    AND?: AdsNetworksWhereInput | AdsNetworksWhereInput[]
    OR?: AdsNetworksWhereInput[]
    NOT?: AdsNetworksWhereInput | AdsNetworksWhereInput[]
    isActive?: BoolFilter<"AdsNetworks"> | boolean
    name?: StringFilter<"AdsNetworks"> | string
    adsViews?: AdsViewsListRelationFilter
  }, "key">

  export type AdsNetworksOrderByWithAggregationInput = {
    key?: SortOrder
    isActive?: SortOrder
    name?: SortOrder
    _count?: AdsNetworksCountOrderByAggregateInput
    _max?: AdsNetworksMaxOrderByAggregateInput
    _min?: AdsNetworksMinOrderByAggregateInput
  }

  export type AdsNetworksScalarWhereWithAggregatesInput = {
    AND?: AdsNetworksScalarWhereWithAggregatesInput | AdsNetworksScalarWhereWithAggregatesInput[]
    OR?: AdsNetworksScalarWhereWithAggregatesInput[]
    NOT?: AdsNetworksScalarWhereWithAggregatesInput | AdsNetworksScalarWhereWithAggregatesInput[]
    key?: EnumAdsNetworkEnumWithAggregatesFilter<"AdsNetworks"> | $Enums.AdsNetworkEnum
    isActive?: BoolWithAggregatesFilter<"AdsNetworks"> | boolean
    name?: StringWithAggregatesFilter<"AdsNetworks"> | string
  }

  export type UserBalanceWhereInput = {
    AND?: UserBalanceWhereInput | UserBalanceWhereInput[]
    OR?: UserBalanceWhereInput[]
    NOT?: UserBalanceWhereInput | UserBalanceWhereInput[]
    id?: StringFilter<"UserBalance"> | string
    paymentBalance?: FloatFilter<"UserBalance"> | number
    holdBalance?: FloatFilter<"UserBalance"> | number
    totalEarnedWithdrawalBalance?: FloatFilter<"UserBalance"> | number
    withdrawalBalance?: FloatFilter<"UserBalance"> | number
    isUseWithdrawalBalance?: BoolFilter<"UserBalance"> | boolean
    updatedAt?: DateTimeFilter<"UserBalance"> | Date | string
    user?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
    transactions?: TransactionsListRelationFilter
  }

  export type UserBalanceOrderByWithRelationInput = {
    id?: SortOrder
    paymentBalance?: SortOrder
    holdBalance?: SortOrder
    totalEarnedWithdrawalBalance?: SortOrder
    withdrawalBalance?: SortOrder
    isUseWithdrawalBalance?: SortOrder
    updatedAt?: SortOrder
    user?: UsersOrderByWithRelationInput
    transactions?: TransactionsOrderByRelationAggregateInput
  }

  export type UserBalanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserBalanceWhereInput | UserBalanceWhereInput[]
    OR?: UserBalanceWhereInput[]
    NOT?: UserBalanceWhereInput | UserBalanceWhereInput[]
    paymentBalance?: FloatFilter<"UserBalance"> | number
    holdBalance?: FloatFilter<"UserBalance"> | number
    totalEarnedWithdrawalBalance?: FloatFilter<"UserBalance"> | number
    withdrawalBalance?: FloatFilter<"UserBalance"> | number
    isUseWithdrawalBalance?: BoolFilter<"UserBalance"> | boolean
    updatedAt?: DateTimeFilter<"UserBalance"> | Date | string
    user?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
    transactions?: TransactionsListRelationFilter
  }, "id">

  export type UserBalanceOrderByWithAggregationInput = {
    id?: SortOrder
    paymentBalance?: SortOrder
    holdBalance?: SortOrder
    totalEarnedWithdrawalBalance?: SortOrder
    withdrawalBalance?: SortOrder
    isUseWithdrawalBalance?: SortOrder
    updatedAt?: SortOrder
    _count?: UserBalanceCountOrderByAggregateInput
    _avg?: UserBalanceAvgOrderByAggregateInput
    _max?: UserBalanceMaxOrderByAggregateInput
    _min?: UserBalanceMinOrderByAggregateInput
    _sum?: UserBalanceSumOrderByAggregateInput
  }

  export type UserBalanceScalarWhereWithAggregatesInput = {
    AND?: UserBalanceScalarWhereWithAggregatesInput | UserBalanceScalarWhereWithAggregatesInput[]
    OR?: UserBalanceScalarWhereWithAggregatesInput[]
    NOT?: UserBalanceScalarWhereWithAggregatesInput | UserBalanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserBalance"> | string
    paymentBalance?: FloatWithAggregatesFilter<"UserBalance"> | number
    holdBalance?: FloatWithAggregatesFilter<"UserBalance"> | number
    totalEarnedWithdrawalBalance?: FloatWithAggregatesFilter<"UserBalance"> | number
    withdrawalBalance?: FloatWithAggregatesFilter<"UserBalance"> | number
    isUseWithdrawalBalance?: BoolWithAggregatesFilter<"UserBalance"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"UserBalance"> | Date | string
  }

  export type SubscriptionsWhereInput = {
    AND?: SubscriptionsWhereInput | SubscriptionsWhereInput[]
    OR?: SubscriptionsWhereInput[]
    NOT?: SubscriptionsWhereInput | SubscriptionsWhereInput[]
    id?: StringFilter<"Subscriptions"> | string
    username?: StringFilter<"Subscriptions"> | string
    isActive?: BoolFilter<"Subscriptions"> | boolean
    isAutoRenewal?: BoolFilter<"Subscriptions"> | boolean
    token?: StringFilter<"Subscriptions"> | string
    period?: EnumSubscriptionPeriodEnumFilter<"Subscriptions"> | $Enums.SubscriptionPeriodEnum
    createdAt?: DateTimeFilter<"Subscriptions"> | Date | string
    updatedAt?: DateTimeFilter<"Subscriptions"> | Date | string
    expiredAt?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    userId?: StringFilter<"Subscriptions"> | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    payments?: PaymentsListRelationFilter
  }

  export type SubscriptionsOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    isActive?: SortOrder
    isAutoRenewal?: SortOrder
    token?: SortOrder
    period?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiredAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UsersOrderByWithRelationInput
    payments?: PaymentsOrderByRelationAggregateInput
  }

  export type SubscriptionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    token?: string
    userId?: string
    AND?: SubscriptionsWhereInput | SubscriptionsWhereInput[]
    OR?: SubscriptionsWhereInput[]
    NOT?: SubscriptionsWhereInput | SubscriptionsWhereInput[]
    isActive?: BoolFilter<"Subscriptions"> | boolean
    isAutoRenewal?: BoolFilter<"Subscriptions"> | boolean
    period?: EnumSubscriptionPeriodEnumFilter<"Subscriptions"> | $Enums.SubscriptionPeriodEnum
    createdAt?: DateTimeFilter<"Subscriptions"> | Date | string
    updatedAt?: DateTimeFilter<"Subscriptions"> | Date | string
    expiredAt?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    payments?: PaymentsListRelationFilter
  }, "id" | "username" | "token" | "userId">

  export type SubscriptionsOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    isActive?: SortOrder
    isAutoRenewal?: SortOrder
    token?: SortOrder
    period?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiredAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: SubscriptionsCountOrderByAggregateInput
    _max?: SubscriptionsMaxOrderByAggregateInput
    _min?: SubscriptionsMinOrderByAggregateInput
  }

  export type SubscriptionsScalarWhereWithAggregatesInput = {
    AND?: SubscriptionsScalarWhereWithAggregatesInput | SubscriptionsScalarWhereWithAggregatesInput[]
    OR?: SubscriptionsScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionsScalarWhereWithAggregatesInput | SubscriptionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscriptions"> | string
    username?: StringWithAggregatesFilter<"Subscriptions"> | string
    isActive?: BoolWithAggregatesFilter<"Subscriptions"> | boolean
    isAutoRenewal?: BoolWithAggregatesFilter<"Subscriptions"> | boolean
    token?: StringWithAggregatesFilter<"Subscriptions"> | string
    period?: EnumSubscriptionPeriodEnumWithAggregatesFilter<"Subscriptions"> | $Enums.SubscriptionPeriodEnum
    createdAt?: DateTimeWithAggregatesFilter<"Subscriptions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscriptions"> | Date | string
    expiredAt?: DateTimeNullableWithAggregatesFilter<"Subscriptions"> | Date | string | null
    userId?: StringWithAggregatesFilter<"Subscriptions"> | string
  }

  export type RolesWhereInput = {
    AND?: RolesWhereInput | RolesWhereInput[]
    OR?: RolesWhereInput[]
    NOT?: RolesWhereInput | RolesWhereInput[]
    key?: EnumUserRoleEnumFilter<"Roles"> | $Enums.UserRoleEnum
    name?: StringFilter<"Roles"> | string
    discount?: FloatFilter<"Roles"> | number
    limitSubscriptions?: IntFilter<"Roles"> | number
    users?: UsersListRelationFilter
  }

  export type RolesOrderByWithRelationInput = {
    key?: SortOrder
    name?: SortOrder
    discount?: SortOrder
    limitSubscriptions?: SortOrder
    users?: UsersOrderByRelationAggregateInput
  }

  export type RolesWhereUniqueInput = Prisma.AtLeast<{
    key?: $Enums.UserRoleEnum
    AND?: RolesWhereInput | RolesWhereInput[]
    OR?: RolesWhereInput[]
    NOT?: RolesWhereInput | RolesWhereInput[]
    name?: StringFilter<"Roles"> | string
    discount?: FloatFilter<"Roles"> | number
    limitSubscriptions?: IntFilter<"Roles"> | number
    users?: UsersListRelationFilter
  }, "key">

  export type RolesOrderByWithAggregationInput = {
    key?: SortOrder
    name?: SortOrder
    discount?: SortOrder
    limitSubscriptions?: SortOrder
    _count?: RolesCountOrderByAggregateInput
    _avg?: RolesAvgOrderByAggregateInput
    _max?: RolesMaxOrderByAggregateInput
    _min?: RolesMinOrderByAggregateInput
    _sum?: RolesSumOrderByAggregateInput
  }

  export type RolesScalarWhereWithAggregatesInput = {
    AND?: RolesScalarWhereWithAggregatesInput | RolesScalarWhereWithAggregatesInput[]
    OR?: RolesScalarWhereWithAggregatesInput[]
    NOT?: RolesScalarWhereWithAggregatesInput | RolesScalarWhereWithAggregatesInput[]
    key?: EnumUserRoleEnumWithAggregatesFilter<"Roles"> | $Enums.UserRoleEnum
    name?: StringWithAggregatesFilter<"Roles"> | string
    discount?: FloatWithAggregatesFilter<"Roles"> | number
    limitSubscriptions?: IntWithAggregatesFilter<"Roles"> | number
  }

  export type LanguageWhereInput = {
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    id?: StringFilter<"Language"> | string
    name?: StringFilter<"Language"> | string
    nativeName?: StringFilter<"Language"> | string
    iso6391?: StringFilter<"Language"> | string
    iso6392?: StringFilter<"Language"> | string
    iso6393?: StringFilter<"Language"> | string
    users?: UsersListRelationFilter
  }

  export type LanguageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    nativeName?: SortOrder
    iso6391?: SortOrder
    iso6392?: SortOrder
    iso6393?: SortOrder
    users?: UsersOrderByRelationAggregateInput
  }

  export type LanguageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    iso6391?: string
    iso6392?: string
    iso6393?: string
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    name?: StringFilter<"Language"> | string
    nativeName?: StringFilter<"Language"> | string
    users?: UsersListRelationFilter
  }, "id" | "iso6391" | "iso6392" | "iso6393">

  export type LanguageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    nativeName?: SortOrder
    iso6391?: SortOrder
    iso6392?: SortOrder
    iso6393?: SortOrder
    _count?: LanguageCountOrderByAggregateInput
    _max?: LanguageMaxOrderByAggregateInput
    _min?: LanguageMinOrderByAggregateInput
  }

  export type LanguageScalarWhereWithAggregatesInput = {
    AND?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    OR?: LanguageScalarWhereWithAggregatesInput[]
    NOT?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Language"> | string
    name?: StringWithAggregatesFilter<"Language"> | string
    nativeName?: StringWithAggregatesFilter<"Language"> | string
    iso6391?: StringWithAggregatesFilter<"Language"> | string
    iso6392?: StringWithAggregatesFilter<"Language"> | string
    iso6393?: StringWithAggregatesFilter<"Language"> | string
  }

  export type CurrencyWhereInput = {
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    key?: EnumCurrencyEnumFilter<"Currency"> | $Enums.CurrencyEnum
    name?: StringFilter<"Currency"> | string
    symbol?: StringFilter<"Currency"> | string
    rate?: FloatFilter<"Currency"> | number
    coinmarketcapUCID?: StringNullableFilter<"Currency"> | string | null
    updatedAt?: DateTimeFilter<"Currency"> | Date | string
    payments?: PaymentsListRelationFilter
    paymentMethods?: PaymentMethodsListRelationFilter
  }

  export type CurrencyOrderByWithRelationInput = {
    key?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    rate?: SortOrder
    coinmarketcapUCID?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    payments?: PaymentsOrderByRelationAggregateInput
    paymentMethods?: PaymentMethodsOrderByRelationAggregateInput
  }

  export type CurrencyWhereUniqueInput = Prisma.AtLeast<{
    key?: $Enums.CurrencyEnum
    coinmarketcapUCID?: string
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    name?: StringFilter<"Currency"> | string
    symbol?: StringFilter<"Currency"> | string
    rate?: FloatFilter<"Currency"> | number
    updatedAt?: DateTimeFilter<"Currency"> | Date | string
    payments?: PaymentsListRelationFilter
    paymentMethods?: PaymentMethodsListRelationFilter
  }, "key" | "coinmarketcapUCID">

  export type CurrencyOrderByWithAggregationInput = {
    key?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    rate?: SortOrder
    coinmarketcapUCID?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: CurrencyCountOrderByAggregateInput
    _avg?: CurrencyAvgOrderByAggregateInput
    _max?: CurrencyMaxOrderByAggregateInput
    _min?: CurrencyMinOrderByAggregateInput
    _sum?: CurrencySumOrderByAggregateInput
  }

  export type CurrencyScalarWhereWithAggregatesInput = {
    AND?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    OR?: CurrencyScalarWhereWithAggregatesInput[]
    NOT?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    key?: EnumCurrencyEnumWithAggregatesFilter<"Currency"> | $Enums.CurrencyEnum
    name?: StringWithAggregatesFilter<"Currency"> | string
    symbol?: StringWithAggregatesFilter<"Currency"> | string
    rate?: FloatWithAggregatesFilter<"Currency"> | number
    coinmarketcapUCID?: StringNullableWithAggregatesFilter<"Currency"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Currency"> | Date | string
  }

  export type TransactionsWhereInput = {
    AND?: TransactionsWhereInput | TransactionsWhereInput[]
    OR?: TransactionsWhereInput[]
    NOT?: TransactionsWhereInput | TransactionsWhereInput[]
    id?: StringFilter<"Transactions"> | string
    amount?: FloatFilter<"Transactions"> | number
    isHold?: BoolFilter<"Transactions"> | boolean
    type?: EnumTransactionTypeEnumFilter<"Transactions"> | $Enums.TransactionTypeEnum
    reason?: EnumTransactionReasonEnumFilter<"Transactions"> | $Enums.TransactionReasonEnum
    balanceType?: EnumBalanceTypeEnumFilter<"Transactions"> | $Enums.BalanceTypeEnum
    createdAt?: DateTimeFilter<"Transactions"> | Date | string
    updatedAt?: DateTimeFilter<"Transactions"> | Date | string
    holdExpiredAt?: DateTimeNullableFilter<"Transactions"> | Date | string | null
    balanceId?: StringFilter<"Transactions"> | string
    balance?: XOR<UserBalanceScalarRelationFilter, UserBalanceWhereInput>
    withdrawal?: XOR<WithdrawalsNullableScalarRelationFilter, WithdrawalsWhereInput> | null
    payment?: XOR<PaymentsNullableScalarRelationFilter, PaymentsWhereInput> | null
  }

  export type TransactionsOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    isHold?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    balanceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    holdExpiredAt?: SortOrderInput | SortOrder
    balanceId?: SortOrder
    balance?: UserBalanceOrderByWithRelationInput
    withdrawal?: WithdrawalsOrderByWithRelationInput
    payment?: PaymentsOrderByWithRelationInput
  }

  export type TransactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionsWhereInput | TransactionsWhereInput[]
    OR?: TransactionsWhereInput[]
    NOT?: TransactionsWhereInput | TransactionsWhereInput[]
    amount?: FloatFilter<"Transactions"> | number
    isHold?: BoolFilter<"Transactions"> | boolean
    type?: EnumTransactionTypeEnumFilter<"Transactions"> | $Enums.TransactionTypeEnum
    reason?: EnumTransactionReasonEnumFilter<"Transactions"> | $Enums.TransactionReasonEnum
    balanceType?: EnumBalanceTypeEnumFilter<"Transactions"> | $Enums.BalanceTypeEnum
    createdAt?: DateTimeFilter<"Transactions"> | Date | string
    updatedAt?: DateTimeFilter<"Transactions"> | Date | string
    holdExpiredAt?: DateTimeNullableFilter<"Transactions"> | Date | string | null
    balanceId?: StringFilter<"Transactions"> | string
    balance?: XOR<UserBalanceScalarRelationFilter, UserBalanceWhereInput>
    withdrawal?: XOR<WithdrawalsNullableScalarRelationFilter, WithdrawalsWhereInput> | null
    payment?: XOR<PaymentsNullableScalarRelationFilter, PaymentsWhereInput> | null
  }, "id">

  export type TransactionsOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    isHold?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    balanceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    holdExpiredAt?: SortOrderInput | SortOrder
    balanceId?: SortOrder
    _count?: TransactionsCountOrderByAggregateInput
    _avg?: TransactionsAvgOrderByAggregateInput
    _max?: TransactionsMaxOrderByAggregateInput
    _min?: TransactionsMinOrderByAggregateInput
    _sum?: TransactionsSumOrderByAggregateInput
  }

  export type TransactionsScalarWhereWithAggregatesInput = {
    AND?: TransactionsScalarWhereWithAggregatesInput | TransactionsScalarWhereWithAggregatesInput[]
    OR?: TransactionsScalarWhereWithAggregatesInput[]
    NOT?: TransactionsScalarWhereWithAggregatesInput | TransactionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transactions"> | string
    amount?: FloatWithAggregatesFilter<"Transactions"> | number
    isHold?: BoolWithAggregatesFilter<"Transactions"> | boolean
    type?: EnumTransactionTypeEnumWithAggregatesFilter<"Transactions"> | $Enums.TransactionTypeEnum
    reason?: EnumTransactionReasonEnumWithAggregatesFilter<"Transactions"> | $Enums.TransactionReasonEnum
    balanceType?: EnumBalanceTypeEnumWithAggregatesFilter<"Transactions"> | $Enums.BalanceTypeEnum
    createdAt?: DateTimeWithAggregatesFilter<"Transactions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transactions"> | Date | string
    holdExpiredAt?: DateTimeNullableWithAggregatesFilter<"Transactions"> | Date | string | null
    balanceId?: StringWithAggregatesFilter<"Transactions"> | string
  }

  export type WithdrawalsWhereInput = {
    AND?: WithdrawalsWhereInput | WithdrawalsWhereInput[]
    OR?: WithdrawalsWhereInput[]
    NOT?: WithdrawalsWhereInput | WithdrawalsWhereInput[]
    id?: StringFilter<"Withdrawals"> | string
    status?: EnumWithdrawalStatusEnumFilter<"Withdrawals"> | $Enums.WithdrawalStatusEnum
    amountStars?: FloatFilter<"Withdrawals"> | number
    amountUSD?: FloatFilter<"Withdrawals"> | number
    amountTON?: FloatFilter<"Withdrawals"> | number
    address?: StringFilter<"Withdrawals"> | string
    createdAt?: DateTimeFilter<"Withdrawals"> | Date | string
    updatedAt?: DateTimeFilter<"Withdrawals"> | Date | string
    userId?: StringFilter<"Withdrawals"> | string
    transactionId?: StringFilter<"Withdrawals"> | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    transacrion?: XOR<TransactionsScalarRelationFilter, TransactionsWhereInput>
  }

  export type WithdrawalsOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    amountStars?: SortOrder
    amountUSD?: SortOrder
    amountTON?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
    user?: UsersOrderByWithRelationInput
    transacrion?: TransactionsOrderByWithRelationInput
  }

  export type WithdrawalsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId?: string
    AND?: WithdrawalsWhereInput | WithdrawalsWhereInput[]
    OR?: WithdrawalsWhereInput[]
    NOT?: WithdrawalsWhereInput | WithdrawalsWhereInput[]
    status?: EnumWithdrawalStatusEnumFilter<"Withdrawals"> | $Enums.WithdrawalStatusEnum
    amountStars?: FloatFilter<"Withdrawals"> | number
    amountUSD?: FloatFilter<"Withdrawals"> | number
    amountTON?: FloatFilter<"Withdrawals"> | number
    address?: StringFilter<"Withdrawals"> | string
    createdAt?: DateTimeFilter<"Withdrawals"> | Date | string
    updatedAt?: DateTimeFilter<"Withdrawals"> | Date | string
    userId?: StringFilter<"Withdrawals"> | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    transacrion?: XOR<TransactionsScalarRelationFilter, TransactionsWhereInput>
  }, "id" | "transactionId">

  export type WithdrawalsOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    amountStars?: SortOrder
    amountUSD?: SortOrder
    amountTON?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
    _count?: WithdrawalsCountOrderByAggregateInput
    _avg?: WithdrawalsAvgOrderByAggregateInput
    _max?: WithdrawalsMaxOrderByAggregateInput
    _min?: WithdrawalsMinOrderByAggregateInput
    _sum?: WithdrawalsSumOrderByAggregateInput
  }

  export type WithdrawalsScalarWhereWithAggregatesInput = {
    AND?: WithdrawalsScalarWhereWithAggregatesInput | WithdrawalsScalarWhereWithAggregatesInput[]
    OR?: WithdrawalsScalarWhereWithAggregatesInput[]
    NOT?: WithdrawalsScalarWhereWithAggregatesInput | WithdrawalsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Withdrawals"> | string
    status?: EnumWithdrawalStatusEnumWithAggregatesFilter<"Withdrawals"> | $Enums.WithdrawalStatusEnum
    amountStars?: FloatWithAggregatesFilter<"Withdrawals"> | number
    amountUSD?: FloatWithAggregatesFilter<"Withdrawals"> | number
    amountTON?: FloatWithAggregatesFilter<"Withdrawals"> | number
    address?: StringWithAggregatesFilter<"Withdrawals"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Withdrawals"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Withdrawals"> | Date | string
    userId?: StringWithAggregatesFilter<"Withdrawals"> | string
    transactionId?: StringWithAggregatesFilter<"Withdrawals"> | string
  }

  export type PaymentsWhereInput = {
    AND?: PaymentsWhereInput | PaymentsWhereInput[]
    OR?: PaymentsWhereInput[]
    NOT?: PaymentsWhereInput | PaymentsWhereInput[]
    id?: StringFilter<"Payments"> | string
    status?: EnumPaymentStatusEnumFilter<"Payments"> | $Enums.PaymentStatusEnum
    amount?: StringFilter<"Payments"> | string
    exchangeRate?: StringFilter<"Payments"> | string
    token?: StringFilter<"Payments"> | string
    linkPay?: StringNullableFilter<"Payments"> | string | null
    details?: JsonNullableFilter<"Payments">
    createdAt?: DateTimeFilter<"Payments"> | Date | string
    updatedAt?: DateTimeFilter<"Payments"> | Date | string
    userId?: StringFilter<"Payments"> | string
    currencyKey?: EnumCurrencyEnumFilter<"Payments"> | $Enums.CurrencyEnum
    SubscriptionId?: StringNullableFilter<"Payments"> | string | null
    methodKey?: EnumPaymentMethodEnumFilter<"Payments"> | $Enums.PaymentMethodEnum
    transactionId?: StringNullableFilter<"Payments"> | string | null
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
    Subscription?: XOR<SubscriptionsNullableScalarRelationFilter, SubscriptionsWhereInput> | null
    method?: XOR<PaymentMethodsScalarRelationFilter, PaymentMethodsWhereInput>
    transacrion?: XOR<TransactionsNullableScalarRelationFilter, TransactionsWhereInput> | null
  }

  export type PaymentsOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    exchangeRate?: SortOrder
    token?: SortOrder
    linkPay?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    currencyKey?: SortOrder
    SubscriptionId?: SortOrderInput | SortOrder
    methodKey?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    user?: UsersOrderByWithRelationInput
    currency?: CurrencyOrderByWithRelationInput
    Subscription?: SubscriptionsOrderByWithRelationInput
    method?: PaymentMethodsOrderByWithRelationInput
    transacrion?: TransactionsOrderByWithRelationInput
  }

  export type PaymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    transactionId?: string
    AND?: PaymentsWhereInput | PaymentsWhereInput[]
    OR?: PaymentsWhereInput[]
    NOT?: PaymentsWhereInput | PaymentsWhereInput[]
    status?: EnumPaymentStatusEnumFilter<"Payments"> | $Enums.PaymentStatusEnum
    amount?: StringFilter<"Payments"> | string
    exchangeRate?: StringFilter<"Payments"> | string
    linkPay?: StringNullableFilter<"Payments"> | string | null
    details?: JsonNullableFilter<"Payments">
    createdAt?: DateTimeFilter<"Payments"> | Date | string
    updatedAt?: DateTimeFilter<"Payments"> | Date | string
    userId?: StringFilter<"Payments"> | string
    currencyKey?: EnumCurrencyEnumFilter<"Payments"> | $Enums.CurrencyEnum
    SubscriptionId?: StringNullableFilter<"Payments"> | string | null
    methodKey?: EnumPaymentMethodEnumFilter<"Payments"> | $Enums.PaymentMethodEnum
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
    Subscription?: XOR<SubscriptionsNullableScalarRelationFilter, SubscriptionsWhereInput> | null
    method?: XOR<PaymentMethodsScalarRelationFilter, PaymentMethodsWhereInput>
    transacrion?: XOR<TransactionsNullableScalarRelationFilter, TransactionsWhereInput> | null
  }, "id" | "token" | "transactionId">

  export type PaymentsOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    exchangeRate?: SortOrder
    token?: SortOrder
    linkPay?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    currencyKey?: SortOrder
    SubscriptionId?: SortOrderInput | SortOrder
    methodKey?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    _count?: PaymentsCountOrderByAggregateInput
    _max?: PaymentsMaxOrderByAggregateInput
    _min?: PaymentsMinOrderByAggregateInput
  }

  export type PaymentsScalarWhereWithAggregatesInput = {
    AND?: PaymentsScalarWhereWithAggregatesInput | PaymentsScalarWhereWithAggregatesInput[]
    OR?: PaymentsScalarWhereWithAggregatesInput[]
    NOT?: PaymentsScalarWhereWithAggregatesInput | PaymentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payments"> | string
    status?: EnumPaymentStatusEnumWithAggregatesFilter<"Payments"> | $Enums.PaymentStatusEnum
    amount?: StringWithAggregatesFilter<"Payments"> | string
    exchangeRate?: StringWithAggregatesFilter<"Payments"> | string
    token?: StringWithAggregatesFilter<"Payments"> | string
    linkPay?: StringNullableWithAggregatesFilter<"Payments"> | string | null
    details?: JsonNullableWithAggregatesFilter<"Payments">
    createdAt?: DateTimeWithAggregatesFilter<"Payments"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payments"> | Date | string
    userId?: StringWithAggregatesFilter<"Payments"> | string
    currencyKey?: EnumCurrencyEnumWithAggregatesFilter<"Payments"> | $Enums.CurrencyEnum
    SubscriptionId?: StringNullableWithAggregatesFilter<"Payments"> | string | null
    methodKey?: EnumPaymentMethodEnumWithAggregatesFilter<"Payments"> | $Enums.PaymentMethodEnum
    transactionId?: StringNullableWithAggregatesFilter<"Payments"> | string | null
  }

  export type PaymentMethodsWhereInput = {
    AND?: PaymentMethodsWhereInput | PaymentMethodsWhereInput[]
    OR?: PaymentMethodsWhereInput[]
    NOT?: PaymentMethodsWhereInput | PaymentMethodsWhereInput[]
    key?: EnumPaymentMethodEnumFilter<"PaymentMethods"> | $Enums.PaymentMethodEnum
    name?: StringFilter<"PaymentMethods"> | string
    isActive?: BoolFilter<"PaymentMethods"> | boolean
    isTonBlockchain?: BoolFilter<"PaymentMethods"> | boolean
    tonSmartContractAddress?: StringNullableFilter<"PaymentMethods"> | string | null
    minAmount?: FloatFilter<"PaymentMethods"> | number
    maxAmount?: FloatFilter<"PaymentMethods"> | number
    commission?: FloatFilter<"PaymentMethods"> | number
    isPlusCommission?: BoolFilter<"PaymentMethods"> | boolean
    type?: EnumPaymentMethodTypeEnumFilter<"PaymentMethods"> | $Enums.PaymentMethodTypeEnum
    system?: EnumPaymentSystemEnumFilter<"PaymentMethods"> | $Enums.PaymentSystemEnum
    currencyKey?: EnumCurrencyEnumFilter<"PaymentMethods"> | $Enums.CurrencyEnum
    payments?: PaymentsListRelationFilter
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
  }

  export type PaymentMethodsOrderByWithRelationInput = {
    key?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    isTonBlockchain?: SortOrder
    tonSmartContractAddress?: SortOrderInput | SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    commission?: SortOrder
    isPlusCommission?: SortOrder
    type?: SortOrder
    system?: SortOrder
    currencyKey?: SortOrder
    payments?: PaymentsOrderByRelationAggregateInput
    currency?: CurrencyOrderByWithRelationInput
  }

  export type PaymentMethodsWhereUniqueInput = Prisma.AtLeast<{
    key?: $Enums.PaymentMethodEnum
    tonSmartContractAddress?: string
    AND?: PaymentMethodsWhereInput | PaymentMethodsWhereInput[]
    OR?: PaymentMethodsWhereInput[]
    NOT?: PaymentMethodsWhereInput | PaymentMethodsWhereInput[]
    name?: StringFilter<"PaymentMethods"> | string
    isActive?: BoolFilter<"PaymentMethods"> | boolean
    isTonBlockchain?: BoolFilter<"PaymentMethods"> | boolean
    minAmount?: FloatFilter<"PaymentMethods"> | number
    maxAmount?: FloatFilter<"PaymentMethods"> | number
    commission?: FloatFilter<"PaymentMethods"> | number
    isPlusCommission?: BoolFilter<"PaymentMethods"> | boolean
    type?: EnumPaymentMethodTypeEnumFilter<"PaymentMethods"> | $Enums.PaymentMethodTypeEnum
    system?: EnumPaymentSystemEnumFilter<"PaymentMethods"> | $Enums.PaymentSystemEnum
    currencyKey?: EnumCurrencyEnumFilter<"PaymentMethods"> | $Enums.CurrencyEnum
    payments?: PaymentsListRelationFilter
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
  }, "key" | "tonSmartContractAddress">

  export type PaymentMethodsOrderByWithAggregationInput = {
    key?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    isTonBlockchain?: SortOrder
    tonSmartContractAddress?: SortOrderInput | SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    commission?: SortOrder
    isPlusCommission?: SortOrder
    type?: SortOrder
    system?: SortOrder
    currencyKey?: SortOrder
    _count?: PaymentMethodsCountOrderByAggregateInput
    _avg?: PaymentMethodsAvgOrderByAggregateInput
    _max?: PaymentMethodsMaxOrderByAggregateInput
    _min?: PaymentMethodsMinOrderByAggregateInput
    _sum?: PaymentMethodsSumOrderByAggregateInput
  }

  export type PaymentMethodsScalarWhereWithAggregatesInput = {
    AND?: PaymentMethodsScalarWhereWithAggregatesInput | PaymentMethodsScalarWhereWithAggregatesInput[]
    OR?: PaymentMethodsScalarWhereWithAggregatesInput[]
    NOT?: PaymentMethodsScalarWhereWithAggregatesInput | PaymentMethodsScalarWhereWithAggregatesInput[]
    key?: EnumPaymentMethodEnumWithAggregatesFilter<"PaymentMethods"> | $Enums.PaymentMethodEnum
    name?: StringWithAggregatesFilter<"PaymentMethods"> | string
    isActive?: BoolWithAggregatesFilter<"PaymentMethods"> | boolean
    isTonBlockchain?: BoolWithAggregatesFilter<"PaymentMethods"> | boolean
    tonSmartContractAddress?: StringNullableWithAggregatesFilter<"PaymentMethods"> | string | null
    minAmount?: FloatWithAggregatesFilter<"PaymentMethods"> | number
    maxAmount?: FloatWithAggregatesFilter<"PaymentMethods"> | number
    commission?: FloatWithAggregatesFilter<"PaymentMethods"> | number
    isPlusCommission?: BoolWithAggregatesFilter<"PaymentMethods"> | boolean
    type?: EnumPaymentMethodTypeEnumWithAggregatesFilter<"PaymentMethods"> | $Enums.PaymentMethodTypeEnum
    system?: EnumPaymentSystemEnumWithAggregatesFilter<"PaymentMethods"> | $Enums.PaymentSystemEnum
    currencyKey?: EnumCurrencyEnumWithAggregatesFilter<"PaymentMethods"> | $Enums.CurrencyEnum
  }

  export type SettingsCreateInput = {
    key?: $Enums.DefaultEnum
    tgStarsToUSD?: number
    priceSubscriptionStars?: number
    comissionStarsToTon?: number
    adsRewardStars?: number
    adsTaskRewardStars?: number
    hourRatioPayment?: number
    dayRatioPayment?: number
    threeMouthesRatioPayment?: number
    sixMouthesRatioPayment?: number
    oneYearRatioPayment?: number
    twoYearRatioPayment?: number
    threeYearRatioPayment?: number
    referralOneLevelPercent?: number
    referralTwoLevelPercent?: number
    referralThreeLevelPercent?: number
    referralInviteRewardStars?: number
    referralInvitePremiumRewardStars?: number
    limitDevices?: number
    freePlanDays?: number
    freePlanDaysForReferrals?: number
  }

  export type SettingsUncheckedCreateInput = {
    key?: $Enums.DefaultEnum
    tgStarsToUSD?: number
    priceSubscriptionStars?: number
    comissionStarsToTon?: number
    adsRewardStars?: number
    adsTaskRewardStars?: number
    hourRatioPayment?: number
    dayRatioPayment?: number
    threeMouthesRatioPayment?: number
    sixMouthesRatioPayment?: number
    oneYearRatioPayment?: number
    twoYearRatioPayment?: number
    threeYearRatioPayment?: number
    referralOneLevelPercent?: number
    referralTwoLevelPercent?: number
    referralThreeLevelPercent?: number
    referralInviteRewardStars?: number
    referralInvitePremiumRewardStars?: number
    limitDevices?: number
    freePlanDays?: number
    freePlanDaysForReferrals?: number
  }

  export type SettingsUpdateInput = {
    key?: EnumDefaultEnumFieldUpdateOperationsInput | $Enums.DefaultEnum
    tgStarsToUSD?: FloatFieldUpdateOperationsInput | number
    priceSubscriptionStars?: IntFieldUpdateOperationsInput | number
    comissionStarsToTon?: FloatFieldUpdateOperationsInput | number
    adsRewardStars?: FloatFieldUpdateOperationsInput | number
    adsTaskRewardStars?: FloatFieldUpdateOperationsInput | number
    hourRatioPayment?: FloatFieldUpdateOperationsInput | number
    dayRatioPayment?: FloatFieldUpdateOperationsInput | number
    threeMouthesRatioPayment?: FloatFieldUpdateOperationsInput | number
    sixMouthesRatioPayment?: FloatFieldUpdateOperationsInput | number
    oneYearRatioPayment?: FloatFieldUpdateOperationsInput | number
    twoYearRatioPayment?: FloatFieldUpdateOperationsInput | number
    threeYearRatioPayment?: FloatFieldUpdateOperationsInput | number
    referralOneLevelPercent?: FloatFieldUpdateOperationsInput | number
    referralTwoLevelPercent?: FloatFieldUpdateOperationsInput | number
    referralThreeLevelPercent?: FloatFieldUpdateOperationsInput | number
    referralInviteRewardStars?: FloatFieldUpdateOperationsInput | number
    referralInvitePremiumRewardStars?: FloatFieldUpdateOperationsInput | number
    limitDevices?: IntFieldUpdateOperationsInput | number
    freePlanDays?: IntFieldUpdateOperationsInput | number
    freePlanDaysForReferrals?: IntFieldUpdateOperationsInput | number
  }

  export type SettingsUncheckedUpdateInput = {
    key?: EnumDefaultEnumFieldUpdateOperationsInput | $Enums.DefaultEnum
    tgStarsToUSD?: FloatFieldUpdateOperationsInput | number
    priceSubscriptionStars?: IntFieldUpdateOperationsInput | number
    comissionStarsToTon?: FloatFieldUpdateOperationsInput | number
    adsRewardStars?: FloatFieldUpdateOperationsInput | number
    adsTaskRewardStars?: FloatFieldUpdateOperationsInput | number
    hourRatioPayment?: FloatFieldUpdateOperationsInput | number
    dayRatioPayment?: FloatFieldUpdateOperationsInput | number
    threeMouthesRatioPayment?: FloatFieldUpdateOperationsInput | number
    sixMouthesRatioPayment?: FloatFieldUpdateOperationsInput | number
    oneYearRatioPayment?: FloatFieldUpdateOperationsInput | number
    twoYearRatioPayment?: FloatFieldUpdateOperationsInput | number
    threeYearRatioPayment?: FloatFieldUpdateOperationsInput | number
    referralOneLevelPercent?: FloatFieldUpdateOperationsInput | number
    referralTwoLevelPercent?: FloatFieldUpdateOperationsInput | number
    referralThreeLevelPercent?: FloatFieldUpdateOperationsInput | number
    referralInviteRewardStars?: FloatFieldUpdateOperationsInput | number
    referralInvitePremiumRewardStars?: FloatFieldUpdateOperationsInput | number
    limitDevices?: IntFieldUpdateOperationsInput | number
    freePlanDays?: IntFieldUpdateOperationsInput | number
    freePlanDaysForReferrals?: IntFieldUpdateOperationsInput | number
  }

  export type SettingsCreateManyInput = {
    key?: $Enums.DefaultEnum
    tgStarsToUSD?: number
    priceSubscriptionStars?: number
    comissionStarsToTon?: number
    adsRewardStars?: number
    adsTaskRewardStars?: number
    hourRatioPayment?: number
    dayRatioPayment?: number
    threeMouthesRatioPayment?: number
    sixMouthesRatioPayment?: number
    oneYearRatioPayment?: number
    twoYearRatioPayment?: number
    threeYearRatioPayment?: number
    referralOneLevelPercent?: number
    referralTwoLevelPercent?: number
    referralThreeLevelPercent?: number
    referralInviteRewardStars?: number
    referralInvitePremiumRewardStars?: number
    limitDevices?: number
    freePlanDays?: number
    freePlanDaysForReferrals?: number
  }

  export type SettingsUpdateManyMutationInput = {
    key?: EnumDefaultEnumFieldUpdateOperationsInput | $Enums.DefaultEnum
    tgStarsToUSD?: FloatFieldUpdateOperationsInput | number
    priceSubscriptionStars?: IntFieldUpdateOperationsInput | number
    comissionStarsToTon?: FloatFieldUpdateOperationsInput | number
    adsRewardStars?: FloatFieldUpdateOperationsInput | number
    adsTaskRewardStars?: FloatFieldUpdateOperationsInput | number
    hourRatioPayment?: FloatFieldUpdateOperationsInput | number
    dayRatioPayment?: FloatFieldUpdateOperationsInput | number
    threeMouthesRatioPayment?: FloatFieldUpdateOperationsInput | number
    sixMouthesRatioPayment?: FloatFieldUpdateOperationsInput | number
    oneYearRatioPayment?: FloatFieldUpdateOperationsInput | number
    twoYearRatioPayment?: FloatFieldUpdateOperationsInput | number
    threeYearRatioPayment?: FloatFieldUpdateOperationsInput | number
    referralOneLevelPercent?: FloatFieldUpdateOperationsInput | number
    referralTwoLevelPercent?: FloatFieldUpdateOperationsInput | number
    referralThreeLevelPercent?: FloatFieldUpdateOperationsInput | number
    referralInviteRewardStars?: FloatFieldUpdateOperationsInput | number
    referralInvitePremiumRewardStars?: FloatFieldUpdateOperationsInput | number
    limitDevices?: IntFieldUpdateOperationsInput | number
    freePlanDays?: IntFieldUpdateOperationsInput | number
    freePlanDaysForReferrals?: IntFieldUpdateOperationsInput | number
  }

  export type SettingsUncheckedUpdateManyInput = {
    key?: EnumDefaultEnumFieldUpdateOperationsInput | $Enums.DefaultEnum
    tgStarsToUSD?: FloatFieldUpdateOperationsInput | number
    priceSubscriptionStars?: IntFieldUpdateOperationsInput | number
    comissionStarsToTon?: FloatFieldUpdateOperationsInput | number
    adsRewardStars?: FloatFieldUpdateOperationsInput | number
    adsTaskRewardStars?: FloatFieldUpdateOperationsInput | number
    hourRatioPayment?: FloatFieldUpdateOperationsInput | number
    dayRatioPayment?: FloatFieldUpdateOperationsInput | number
    threeMouthesRatioPayment?: FloatFieldUpdateOperationsInput | number
    sixMouthesRatioPayment?: FloatFieldUpdateOperationsInput | number
    oneYearRatioPayment?: FloatFieldUpdateOperationsInput | number
    twoYearRatioPayment?: FloatFieldUpdateOperationsInput | number
    threeYearRatioPayment?: FloatFieldUpdateOperationsInput | number
    referralOneLevelPercent?: FloatFieldUpdateOperationsInput | number
    referralTwoLevelPercent?: FloatFieldUpdateOperationsInput | number
    referralThreeLevelPercent?: FloatFieldUpdateOperationsInput | number
    referralInviteRewardStars?: FloatFieldUpdateOperationsInput | number
    referralInvitePremiumRewardStars?: FloatFieldUpdateOperationsInput | number
    limitDevices?: IntFieldUpdateOperationsInput | number
    freePlanDays?: IntFieldUpdateOperationsInput | number
    freePlanDaysForReferrals?: IntFieldUpdateOperationsInput | number
  }

  export type UserTelegramDataCreateInput = {
    id?: string
    isLive?: boolean
    isRtl?: boolean
    isPremium?: boolean
    isBot?: boolean
    firstName: string
    lastName?: string | null
    username?: string | null
    languageCode: string
    photoUrl?: string | null
    addedToAttachmentMenu?: boolean
    allowsWriteToPm?: boolean
    updatedAt?: Date | string
    user?: UsersCreateNestedOneWithoutTelegramDataInput
  }

  export type UserTelegramDataUncheckedCreateInput = {
    id?: string
    isLive?: boolean
    isRtl?: boolean
    isPremium?: boolean
    isBot?: boolean
    firstName: string
    lastName?: string | null
    username?: string | null
    languageCode: string
    photoUrl?: string | null
    addedToAttachmentMenu?: boolean
    allowsWriteToPm?: boolean
    updatedAt?: Date | string
    user?: UsersUncheckedCreateNestedOneWithoutTelegramDataInput
  }

  export type UserTelegramDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLive?: BoolFieldUpdateOperationsInput | boolean
    isRtl?: BoolFieldUpdateOperationsInput | boolean
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    languageCode?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    addedToAttachmentMenu?: BoolFieldUpdateOperationsInput | boolean
    allowsWriteToPm?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneWithoutTelegramDataNestedInput
  }

  export type UserTelegramDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLive?: BoolFieldUpdateOperationsInput | boolean
    isRtl?: BoolFieldUpdateOperationsInput | boolean
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    languageCode?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    addedToAttachmentMenu?: BoolFieldUpdateOperationsInput | boolean
    allowsWriteToPm?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUncheckedUpdateOneWithoutTelegramDataNestedInput
  }

  export type UserTelegramDataCreateManyInput = {
    id?: string
    isLive?: boolean
    isRtl?: boolean
    isPremium?: boolean
    isBot?: boolean
    firstName: string
    lastName?: string | null
    username?: string | null
    languageCode: string
    photoUrl?: string | null
    addedToAttachmentMenu?: boolean
    allowsWriteToPm?: boolean
    updatedAt?: Date | string
  }

  export type UserTelegramDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLive?: BoolFieldUpdateOperationsInput | boolean
    isRtl?: BoolFieldUpdateOperationsInput | boolean
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    languageCode?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    addedToAttachmentMenu?: BoolFieldUpdateOperationsInput | boolean
    allowsWriteToPm?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTelegramDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLive?: BoolFieldUpdateOperationsInput | boolean
    isRtl?: BoolFieldUpdateOperationsInput | boolean
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    languageCode?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    addedToAttachmentMenu?: BoolFieldUpdateOperationsInput | boolean
    allowsWriteToPm?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralsCreateInput = {
    id?: string
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inviter: UsersCreateNestedOneWithoutInvitersInput
    referral: UsersCreateNestedOneWithoutReferralsInput
  }

  export type ReferralsUncheckedCreateInput = {
    id?: string
    level?: number
    inviterId: string
    referralId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviter?: UsersUpdateOneRequiredWithoutInvitersNestedInput
    referral?: UsersUpdateOneRequiredWithoutReferralsNestedInput
  }

  export type ReferralsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    inviterId?: StringFieldUpdateOperationsInput | string
    referralId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralsCreateManyInput = {
    id?: string
    level?: number
    inviterId: string
    referralId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    inviterId?: StringFieldUpdateOperationsInput | string
    referralId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersCreateInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    role?: RolesCreateNestedOneWithoutUsersInput
    payments?: PaymentsCreateNestedManyWithoutUserInput
    referrals?: ReferralsCreateNestedManyWithoutReferralInput
    inviters?: ReferralsCreateNestedManyWithoutInviterInput
    telegramData?: UserTelegramDataCreateNestedOneWithoutUserInput
    balance?: UserBalanceCreateNestedOneWithoutUserInput
    language: LanguageCreateNestedOneWithoutUsersInput
    subscriptions?: SubscriptionsCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalsCreateNestedManyWithoutUserInput
    adsViews?: AdsViewsCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    roleId?: $Enums.UserRoleEnum
    telegramDataId?: string | null
    balanceId?: string | null
    languageId: string
    payments?: PaymentsUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralsUncheckedCreateNestedManyWithoutReferralInput
    inviters?: ReferralsUncheckedCreateNestedManyWithoutInviterInput
    subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalsUncheckedCreateNestedManyWithoutUserInput
    adsViews?: AdsViewsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RolesUpdateOneRequiredWithoutUsersNestedInput
    payments?: PaymentsUpdateManyWithoutUserNestedInput
    referrals?: ReferralsUpdateManyWithoutReferralNestedInput
    inviters?: ReferralsUpdateManyWithoutInviterNestedInput
    telegramData?: UserTelegramDataUpdateOneWithoutUserNestedInput
    balance?: UserBalanceUpdateOneWithoutUserNestedInput
    language?: LanguageUpdateOneRequiredWithoutUsersNestedInput
    subscriptions?: SubscriptionsUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalsUpdateManyWithoutUserNestedInput
    adsViews?: AdsViewsUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: EnumUserRoleEnumFieldUpdateOperationsInput | $Enums.UserRoleEnum
    telegramDataId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceId?: NullableStringFieldUpdateOperationsInput | string | null
    languageId?: StringFieldUpdateOperationsInput | string
    payments?: PaymentsUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralsUncheckedUpdateManyWithoutReferralNestedInput
    inviters?: ReferralsUncheckedUpdateManyWithoutInviterNestedInput
    subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalsUncheckedUpdateManyWithoutUserNestedInput
    adsViews?: AdsViewsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsersCreateManyInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    roleId?: $Enums.UserRoleEnum
    telegramDataId?: string | null
    balanceId?: string | null
    languageId: string
  }

  export type UsersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: EnumUserRoleEnumFieldUpdateOperationsInput | $Enums.UserRoleEnum
    telegramDataId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceId?: NullableStringFieldUpdateOperationsInput | string | null
    languageId?: StringFieldUpdateOperationsInput | string
  }

  export type AdsViewsCreateInput = {
    id?: string
    type?: $Enums.AdsViewTypeEnum
    createdAt?: Date | string
    network?: AdsNetworksCreateNestedOneWithoutAdsViewsInput
    user: UsersCreateNestedOneWithoutAdsViewsInput
  }

  export type AdsViewsUncheckedCreateInput = {
    id?: string
    networkKey?: $Enums.AdsNetworkEnum
    type?: $Enums.AdsViewTypeEnum
    createdAt?: Date | string
    userId: string
  }

  export type AdsViewsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAdsViewTypeEnumFieldUpdateOperationsInput | $Enums.AdsViewTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: AdsNetworksUpdateOneRequiredWithoutAdsViewsNestedInput
    user?: UsersUpdateOneRequiredWithoutAdsViewsNestedInput
  }

  export type AdsViewsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    networkKey?: EnumAdsNetworkEnumFieldUpdateOperationsInput | $Enums.AdsNetworkEnum
    type?: EnumAdsViewTypeEnumFieldUpdateOperationsInput | $Enums.AdsViewTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AdsViewsCreateManyInput = {
    id?: string
    networkKey?: $Enums.AdsNetworkEnum
    type?: $Enums.AdsViewTypeEnum
    createdAt?: Date | string
    userId: string
  }

  export type AdsViewsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAdsViewTypeEnumFieldUpdateOperationsInput | $Enums.AdsViewTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdsViewsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    networkKey?: EnumAdsNetworkEnumFieldUpdateOperationsInput | $Enums.AdsNetworkEnum
    type?: EnumAdsViewTypeEnumFieldUpdateOperationsInput | $Enums.AdsViewTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AdsNetworksCreateInput = {
    key: $Enums.AdsNetworkEnum
    isActive: boolean
    name: string
    adsViews?: AdsViewsCreateNestedManyWithoutNetworkInput
  }

  export type AdsNetworksUncheckedCreateInput = {
    key: $Enums.AdsNetworkEnum
    isActive: boolean
    name: string
    adsViews?: AdsViewsUncheckedCreateNestedManyWithoutNetworkInput
  }

  export type AdsNetworksUpdateInput = {
    key?: EnumAdsNetworkEnumFieldUpdateOperationsInput | $Enums.AdsNetworkEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    adsViews?: AdsViewsUpdateManyWithoutNetworkNestedInput
  }

  export type AdsNetworksUncheckedUpdateInput = {
    key?: EnumAdsNetworkEnumFieldUpdateOperationsInput | $Enums.AdsNetworkEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    adsViews?: AdsViewsUncheckedUpdateManyWithoutNetworkNestedInput
  }

  export type AdsNetworksCreateManyInput = {
    key: $Enums.AdsNetworkEnum
    isActive: boolean
    name: string
  }

  export type AdsNetworksUpdateManyMutationInput = {
    key?: EnumAdsNetworkEnumFieldUpdateOperationsInput | $Enums.AdsNetworkEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AdsNetworksUncheckedUpdateManyInput = {
    key?: EnumAdsNetworkEnumFieldUpdateOperationsInput | $Enums.AdsNetworkEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserBalanceCreateInput = {
    id?: string
    paymentBalance?: number
    holdBalance?: number
    totalEarnedWithdrawalBalance?: number
    withdrawalBalance?: number
    isUseWithdrawalBalance?: boolean
    updatedAt?: Date | string
    user?: UsersCreateNestedOneWithoutBalanceInput
    transactions?: TransactionsCreateNestedManyWithoutBalanceInput
  }

  export type UserBalanceUncheckedCreateInput = {
    id?: string
    paymentBalance?: number
    holdBalance?: number
    totalEarnedWithdrawalBalance?: number
    withdrawalBalance?: number
    isUseWithdrawalBalance?: boolean
    updatedAt?: Date | string
    user?: UsersUncheckedCreateNestedOneWithoutBalanceInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutBalanceInput
  }

  export type UserBalanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentBalance?: FloatFieldUpdateOperationsInput | number
    holdBalance?: FloatFieldUpdateOperationsInput | number
    totalEarnedWithdrawalBalance?: FloatFieldUpdateOperationsInput | number
    withdrawalBalance?: FloatFieldUpdateOperationsInput | number
    isUseWithdrawalBalance?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneWithoutBalanceNestedInput
    transactions?: TransactionsUpdateManyWithoutBalanceNestedInput
  }

  export type UserBalanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentBalance?: FloatFieldUpdateOperationsInput | number
    holdBalance?: FloatFieldUpdateOperationsInput | number
    totalEarnedWithdrawalBalance?: FloatFieldUpdateOperationsInput | number
    withdrawalBalance?: FloatFieldUpdateOperationsInput | number
    isUseWithdrawalBalance?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUncheckedUpdateOneWithoutBalanceNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutBalanceNestedInput
  }

  export type UserBalanceCreateManyInput = {
    id?: string
    paymentBalance?: number
    holdBalance?: number
    totalEarnedWithdrawalBalance?: number
    withdrawalBalance?: number
    isUseWithdrawalBalance?: boolean
    updatedAt?: Date | string
  }

  export type UserBalanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentBalance?: FloatFieldUpdateOperationsInput | number
    holdBalance?: FloatFieldUpdateOperationsInput | number
    totalEarnedWithdrawalBalance?: FloatFieldUpdateOperationsInput | number
    withdrawalBalance?: FloatFieldUpdateOperationsInput | number
    isUseWithdrawalBalance?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBalanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentBalance?: FloatFieldUpdateOperationsInput | number
    holdBalance?: FloatFieldUpdateOperationsInput | number
    totalEarnedWithdrawalBalance?: FloatFieldUpdateOperationsInput | number
    withdrawalBalance?: FloatFieldUpdateOperationsInput | number
    isUseWithdrawalBalance?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionsCreateInput = {
    id?: string
    username: string
    isActive?: boolean
    isAutoRenewal?: boolean
    token: string
    period?: $Enums.SubscriptionPeriodEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    expiredAt?: Date | string | null
    user: UsersCreateNestedOneWithoutSubscriptionsInput
    payments?: PaymentsCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionsUncheckedCreateInput = {
    id?: string
    username: string
    isActive?: boolean
    isAutoRenewal?: boolean
    token: string
    period?: $Enums.SubscriptionPeriodEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    expiredAt?: Date | string | null
    userId: string
    payments?: PaymentsUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAutoRenewal?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    period?: EnumSubscriptionPeriodEnumFieldUpdateOperationsInput | $Enums.SubscriptionPeriodEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UsersUpdateOneRequiredWithoutSubscriptionsNestedInput
    payments?: PaymentsUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAutoRenewal?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    period?: EnumSubscriptionPeriodEnumFieldUpdateOperationsInput | $Enums.SubscriptionPeriodEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    payments?: PaymentsUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionsCreateManyInput = {
    id?: string
    username: string
    isActive?: boolean
    isAutoRenewal?: boolean
    token: string
    period?: $Enums.SubscriptionPeriodEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    expiredAt?: Date | string | null
    userId: string
  }

  export type SubscriptionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAutoRenewal?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    period?: EnumSubscriptionPeriodEnumFieldUpdateOperationsInput | $Enums.SubscriptionPeriodEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAutoRenewal?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    period?: EnumSubscriptionPeriodEnumFieldUpdateOperationsInput | $Enums.SubscriptionPeriodEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type RolesCreateInput = {
    key: $Enums.UserRoleEnum
    name: string
    discount?: number
    limitSubscriptions?: number
    users?: UsersCreateNestedManyWithoutRoleInput
  }

  export type RolesUncheckedCreateInput = {
    key: $Enums.UserRoleEnum
    name: string
    discount?: number
    limitSubscriptions?: number
    users?: UsersUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RolesUpdateInput = {
    key?: EnumUserRoleEnumFieldUpdateOperationsInput | $Enums.UserRoleEnum
    name?: StringFieldUpdateOperationsInput | string
    discount?: FloatFieldUpdateOperationsInput | number
    limitSubscriptions?: IntFieldUpdateOperationsInput | number
    users?: UsersUpdateManyWithoutRoleNestedInput
  }

  export type RolesUncheckedUpdateInput = {
    key?: EnumUserRoleEnumFieldUpdateOperationsInput | $Enums.UserRoleEnum
    name?: StringFieldUpdateOperationsInput | string
    discount?: FloatFieldUpdateOperationsInput | number
    limitSubscriptions?: IntFieldUpdateOperationsInput | number
    users?: UsersUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RolesCreateManyInput = {
    key: $Enums.UserRoleEnum
    name: string
    discount?: number
    limitSubscriptions?: number
  }

  export type RolesUpdateManyMutationInput = {
    key?: EnumUserRoleEnumFieldUpdateOperationsInput | $Enums.UserRoleEnum
    name?: StringFieldUpdateOperationsInput | string
    discount?: FloatFieldUpdateOperationsInput | number
    limitSubscriptions?: IntFieldUpdateOperationsInput | number
  }

  export type RolesUncheckedUpdateManyInput = {
    key?: EnumUserRoleEnumFieldUpdateOperationsInput | $Enums.UserRoleEnum
    name?: StringFieldUpdateOperationsInput | string
    discount?: FloatFieldUpdateOperationsInput | number
    limitSubscriptions?: IntFieldUpdateOperationsInput | number
  }

  export type LanguageCreateInput = {
    id?: string
    name: string
    nativeName: string
    iso6391: string
    iso6392: string
    iso6393: string
    users?: UsersCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateInput = {
    id?: string
    name: string
    nativeName: string
    iso6391: string
    iso6392: string
    iso6393: string
    users?: UsersUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    iso6391?: StringFieldUpdateOperationsInput | string
    iso6392?: StringFieldUpdateOperationsInput | string
    iso6393?: StringFieldUpdateOperationsInput | string
    users?: UsersUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    iso6391?: StringFieldUpdateOperationsInput | string
    iso6392?: StringFieldUpdateOperationsInput | string
    iso6393?: StringFieldUpdateOperationsInput | string
    users?: UsersUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageCreateManyInput = {
    id?: string
    name: string
    nativeName: string
    iso6391: string
    iso6392: string
    iso6393: string
  }

  export type LanguageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    iso6391?: StringFieldUpdateOperationsInput | string
    iso6392?: StringFieldUpdateOperationsInput | string
    iso6393?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    iso6391?: StringFieldUpdateOperationsInput | string
    iso6392?: StringFieldUpdateOperationsInput | string
    iso6393?: StringFieldUpdateOperationsInput | string
  }

  export type CurrencyCreateInput = {
    key: $Enums.CurrencyEnum
    name: string
    symbol: string
    rate?: number
    coinmarketcapUCID?: string | null
    updatedAt?: Date | string
    payments?: PaymentsCreateNestedManyWithoutCurrencyInput
    paymentMethods?: PaymentMethodsCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateInput = {
    key: $Enums.CurrencyEnum
    name: string
    symbol: string
    rate?: number
    coinmarketcapUCID?: string | null
    updatedAt?: Date | string
    payments?: PaymentsUncheckedCreateNestedManyWithoutCurrencyInput
    paymentMethods?: PaymentMethodsUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUpdateInput = {
    key?: EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    coinmarketcapUCID?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentsUpdateManyWithoutCurrencyNestedInput
    paymentMethods?: PaymentMethodsUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateInput = {
    key?: EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    coinmarketcapUCID?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentsUncheckedUpdateManyWithoutCurrencyNestedInput
    paymentMethods?: PaymentMethodsUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyCreateManyInput = {
    key: $Enums.CurrencyEnum
    name: string
    symbol: string
    rate?: number
    coinmarketcapUCID?: string | null
    updatedAt?: Date | string
  }

  export type CurrencyUpdateManyMutationInput = {
    key?: EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    coinmarketcapUCID?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyUncheckedUpdateManyInput = {
    key?: EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    coinmarketcapUCID?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionsCreateInput = {
    id?: string
    amount?: number
    isHold?: boolean
    type?: $Enums.TransactionTypeEnum
    reason?: $Enums.TransactionReasonEnum
    balanceType?: $Enums.BalanceTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiredAt?: Date | string | null
    balance: UserBalanceCreateNestedOneWithoutTransactionsInput
    withdrawal?: WithdrawalsCreateNestedOneWithoutTransacrionInput
    payment?: PaymentsCreateNestedOneWithoutTransacrionInput
  }

  export type TransactionsUncheckedCreateInput = {
    id?: string
    amount?: number
    isHold?: boolean
    type?: $Enums.TransactionTypeEnum
    reason?: $Enums.TransactionReasonEnum
    balanceType?: $Enums.BalanceTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiredAt?: Date | string | null
    balanceId: string
    withdrawal?: WithdrawalsUncheckedCreateNestedOneWithoutTransacrionInput
    payment?: PaymentsUncheckedCreateNestedOneWithoutTransacrionInput
  }

  export type TransactionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isHold?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumTransactionTypeEnumFieldUpdateOperationsInput | $Enums.TransactionTypeEnum
    reason?: EnumTransactionReasonEnumFieldUpdateOperationsInput | $Enums.TransactionReasonEnum
    balanceType?: EnumBalanceTypeEnumFieldUpdateOperationsInput | $Enums.BalanceTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: UserBalanceUpdateOneRequiredWithoutTransactionsNestedInput
    withdrawal?: WithdrawalsUpdateOneWithoutTransacrionNestedInput
    payment?: PaymentsUpdateOneWithoutTransacrionNestedInput
  }

  export type TransactionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isHold?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumTransactionTypeEnumFieldUpdateOperationsInput | $Enums.TransactionTypeEnum
    reason?: EnumTransactionReasonEnumFieldUpdateOperationsInput | $Enums.TransactionReasonEnum
    balanceType?: EnumBalanceTypeEnumFieldUpdateOperationsInput | $Enums.BalanceTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balanceId?: StringFieldUpdateOperationsInput | string
    withdrawal?: WithdrawalsUncheckedUpdateOneWithoutTransacrionNestedInput
    payment?: PaymentsUncheckedUpdateOneWithoutTransacrionNestedInput
  }

  export type TransactionsCreateManyInput = {
    id?: string
    amount?: number
    isHold?: boolean
    type?: $Enums.TransactionTypeEnum
    reason?: $Enums.TransactionReasonEnum
    balanceType?: $Enums.BalanceTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiredAt?: Date | string | null
    balanceId: string
  }

  export type TransactionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isHold?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumTransactionTypeEnumFieldUpdateOperationsInput | $Enums.TransactionTypeEnum
    reason?: EnumTransactionReasonEnumFieldUpdateOperationsInput | $Enums.TransactionReasonEnum
    balanceType?: EnumBalanceTypeEnumFieldUpdateOperationsInput | $Enums.BalanceTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isHold?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumTransactionTypeEnumFieldUpdateOperationsInput | $Enums.TransactionTypeEnum
    reason?: EnumTransactionReasonEnumFieldUpdateOperationsInput | $Enums.TransactionReasonEnum
    balanceType?: EnumBalanceTypeEnumFieldUpdateOperationsInput | $Enums.BalanceTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balanceId?: StringFieldUpdateOperationsInput | string
  }

  export type WithdrawalsCreateInput = {
    id?: string
    status?: $Enums.WithdrawalStatusEnum
    amountStars?: number
    amountUSD?: number
    amountTON?: number
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutWithdrawalsInput
    transacrion: TransactionsCreateNestedOneWithoutWithdrawalInput
  }

  export type WithdrawalsUncheckedCreateInput = {
    id?: string
    status?: $Enums.WithdrawalStatusEnum
    amountStars?: number
    amountUSD?: number
    amountTON?: number
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    transactionId: string
  }

  export type WithdrawalsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWithdrawalStatusEnumFieldUpdateOperationsInput | $Enums.WithdrawalStatusEnum
    amountStars?: FloatFieldUpdateOperationsInput | number
    amountUSD?: FloatFieldUpdateOperationsInput | number
    amountTON?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutWithdrawalsNestedInput
    transacrion?: TransactionsUpdateOneRequiredWithoutWithdrawalNestedInput
  }

  export type WithdrawalsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWithdrawalStatusEnumFieldUpdateOperationsInput | $Enums.WithdrawalStatusEnum
    amountStars?: FloatFieldUpdateOperationsInput | number
    amountUSD?: FloatFieldUpdateOperationsInput | number
    amountTON?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
  }

  export type WithdrawalsCreateManyInput = {
    id?: string
    status?: $Enums.WithdrawalStatusEnum
    amountStars?: number
    amountUSD?: number
    amountTON?: number
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    transactionId: string
  }

  export type WithdrawalsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWithdrawalStatusEnumFieldUpdateOperationsInput | $Enums.WithdrawalStatusEnum
    amountStars?: FloatFieldUpdateOperationsInput | number
    amountUSD?: FloatFieldUpdateOperationsInput | number
    amountTON?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WithdrawalsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWithdrawalStatusEnumFieldUpdateOperationsInput | $Enums.WithdrawalStatusEnum
    amountStars?: FloatFieldUpdateOperationsInput | number
    amountUSD?: FloatFieldUpdateOperationsInput | number
    amountTON?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentsCreateInput = {
    id?: string
    status?: $Enums.PaymentStatusEnum
    amount?: string
    exchangeRate?: string
    token: string
    linkPay?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutPaymentsInput
    currency: CurrencyCreateNestedOneWithoutPaymentsInput
    Subscription?: SubscriptionsCreateNestedOneWithoutPaymentsInput
    method: PaymentMethodsCreateNestedOneWithoutPaymentsInput
    transacrion?: TransactionsCreateNestedOneWithoutPaymentInput
  }

  export type PaymentsUncheckedCreateInput = {
    id?: string
    status?: $Enums.PaymentStatusEnum
    amount?: string
    exchangeRate?: string
    token: string
    linkPay?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    currencyKey: $Enums.CurrencyEnum
    SubscriptionId?: string | null
    methodKey: $Enums.PaymentMethodEnum
    transactionId?: string | null
  }

  export type PaymentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusEnumFieldUpdateOperationsInput | $Enums.PaymentStatusEnum
    amount?: StringFieldUpdateOperationsInput | string
    exchangeRate?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    linkPay?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutPaymentsNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutPaymentsNestedInput
    Subscription?: SubscriptionsUpdateOneWithoutPaymentsNestedInput
    method?: PaymentMethodsUpdateOneRequiredWithoutPaymentsNestedInput
    transacrion?: TransactionsUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusEnumFieldUpdateOperationsInput | $Enums.PaymentStatusEnum
    amount?: StringFieldUpdateOperationsInput | string
    exchangeRate?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    linkPay?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    currencyKey?: EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
    SubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    methodKey?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentsCreateManyInput = {
    id?: string
    status?: $Enums.PaymentStatusEnum
    amount?: string
    exchangeRate?: string
    token: string
    linkPay?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    currencyKey: $Enums.CurrencyEnum
    SubscriptionId?: string | null
    methodKey: $Enums.PaymentMethodEnum
    transactionId?: string | null
  }

  export type PaymentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusEnumFieldUpdateOperationsInput | $Enums.PaymentStatusEnum
    amount?: StringFieldUpdateOperationsInput | string
    exchangeRate?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    linkPay?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusEnumFieldUpdateOperationsInput | $Enums.PaymentStatusEnum
    amount?: StringFieldUpdateOperationsInput | string
    exchangeRate?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    linkPay?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    currencyKey?: EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
    SubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    methodKey?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentMethodsCreateInput = {
    key: $Enums.PaymentMethodEnum
    name: string
    isActive?: boolean
    isTonBlockchain?: boolean
    tonSmartContractAddress?: string | null
    minAmount?: number
    maxAmount?: number
    commission?: number
    isPlusCommission?: boolean
    type?: $Enums.PaymentMethodTypeEnum
    system?: $Enums.PaymentSystemEnum
    payments?: PaymentsCreateNestedManyWithoutMethodInput
    currency: CurrencyCreateNestedOneWithoutPaymentMethodsInput
  }

  export type PaymentMethodsUncheckedCreateInput = {
    key: $Enums.PaymentMethodEnum
    name: string
    isActive?: boolean
    isTonBlockchain?: boolean
    tonSmartContractAddress?: string | null
    minAmount?: number
    maxAmount?: number
    commission?: number
    isPlusCommission?: boolean
    type?: $Enums.PaymentMethodTypeEnum
    system?: $Enums.PaymentSystemEnum
    currencyKey: $Enums.CurrencyEnum
    payments?: PaymentsUncheckedCreateNestedManyWithoutMethodInput
  }

  export type PaymentMethodsUpdateInput = {
    key?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTonBlockchain?: BoolFieldUpdateOperationsInput | boolean
    tonSmartContractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: FloatFieldUpdateOperationsInput | number
    maxAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    isPlusCommission?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumPaymentMethodTypeEnumFieldUpdateOperationsInput | $Enums.PaymentMethodTypeEnum
    system?: EnumPaymentSystemEnumFieldUpdateOperationsInput | $Enums.PaymentSystemEnum
    payments?: PaymentsUpdateManyWithoutMethodNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutPaymentMethodsNestedInput
  }

  export type PaymentMethodsUncheckedUpdateInput = {
    key?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTonBlockchain?: BoolFieldUpdateOperationsInput | boolean
    tonSmartContractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: FloatFieldUpdateOperationsInput | number
    maxAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    isPlusCommission?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumPaymentMethodTypeEnumFieldUpdateOperationsInput | $Enums.PaymentMethodTypeEnum
    system?: EnumPaymentSystemEnumFieldUpdateOperationsInput | $Enums.PaymentSystemEnum
    currencyKey?: EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
    payments?: PaymentsUncheckedUpdateManyWithoutMethodNestedInput
  }

  export type PaymentMethodsCreateManyInput = {
    key: $Enums.PaymentMethodEnum
    name: string
    isActive?: boolean
    isTonBlockchain?: boolean
    tonSmartContractAddress?: string | null
    minAmount?: number
    maxAmount?: number
    commission?: number
    isPlusCommission?: boolean
    type?: $Enums.PaymentMethodTypeEnum
    system?: $Enums.PaymentSystemEnum
    currencyKey: $Enums.CurrencyEnum
  }

  export type PaymentMethodsUpdateManyMutationInput = {
    key?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTonBlockchain?: BoolFieldUpdateOperationsInput | boolean
    tonSmartContractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: FloatFieldUpdateOperationsInput | number
    maxAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    isPlusCommission?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumPaymentMethodTypeEnumFieldUpdateOperationsInput | $Enums.PaymentMethodTypeEnum
    system?: EnumPaymentSystemEnumFieldUpdateOperationsInput | $Enums.PaymentSystemEnum
  }

  export type PaymentMethodsUncheckedUpdateManyInput = {
    key?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTonBlockchain?: BoolFieldUpdateOperationsInput | boolean
    tonSmartContractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: FloatFieldUpdateOperationsInput | number
    maxAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    isPlusCommission?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumPaymentMethodTypeEnumFieldUpdateOperationsInput | $Enums.PaymentMethodTypeEnum
    system?: EnumPaymentSystemEnumFieldUpdateOperationsInput | $Enums.PaymentSystemEnum
    currencyKey?: EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
  }

  export type EnumDefaultEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.DefaultEnum | EnumDefaultEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DefaultEnum[] | ListEnumDefaultEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefaultEnum[] | ListEnumDefaultEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDefaultEnumFilter<$PrismaModel> | $Enums.DefaultEnum
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type SettingsCountOrderByAggregateInput = {
    key?: SortOrder
    tgStarsToUSD?: SortOrder
    priceSubscriptionStars?: SortOrder
    comissionStarsToTon?: SortOrder
    adsRewardStars?: SortOrder
    adsTaskRewardStars?: SortOrder
    hourRatioPayment?: SortOrder
    dayRatioPayment?: SortOrder
    threeMouthesRatioPayment?: SortOrder
    sixMouthesRatioPayment?: SortOrder
    oneYearRatioPayment?: SortOrder
    twoYearRatioPayment?: SortOrder
    threeYearRatioPayment?: SortOrder
    referralOneLevelPercent?: SortOrder
    referralTwoLevelPercent?: SortOrder
    referralThreeLevelPercent?: SortOrder
    referralInviteRewardStars?: SortOrder
    referralInvitePremiumRewardStars?: SortOrder
    limitDevices?: SortOrder
    freePlanDays?: SortOrder
    freePlanDaysForReferrals?: SortOrder
  }

  export type SettingsAvgOrderByAggregateInput = {
    tgStarsToUSD?: SortOrder
    priceSubscriptionStars?: SortOrder
    comissionStarsToTon?: SortOrder
    adsRewardStars?: SortOrder
    adsTaskRewardStars?: SortOrder
    hourRatioPayment?: SortOrder
    dayRatioPayment?: SortOrder
    threeMouthesRatioPayment?: SortOrder
    sixMouthesRatioPayment?: SortOrder
    oneYearRatioPayment?: SortOrder
    twoYearRatioPayment?: SortOrder
    threeYearRatioPayment?: SortOrder
    referralOneLevelPercent?: SortOrder
    referralTwoLevelPercent?: SortOrder
    referralThreeLevelPercent?: SortOrder
    referralInviteRewardStars?: SortOrder
    referralInvitePremiumRewardStars?: SortOrder
    limitDevices?: SortOrder
    freePlanDays?: SortOrder
    freePlanDaysForReferrals?: SortOrder
  }

  export type SettingsMaxOrderByAggregateInput = {
    key?: SortOrder
    tgStarsToUSD?: SortOrder
    priceSubscriptionStars?: SortOrder
    comissionStarsToTon?: SortOrder
    adsRewardStars?: SortOrder
    adsTaskRewardStars?: SortOrder
    hourRatioPayment?: SortOrder
    dayRatioPayment?: SortOrder
    threeMouthesRatioPayment?: SortOrder
    sixMouthesRatioPayment?: SortOrder
    oneYearRatioPayment?: SortOrder
    twoYearRatioPayment?: SortOrder
    threeYearRatioPayment?: SortOrder
    referralOneLevelPercent?: SortOrder
    referralTwoLevelPercent?: SortOrder
    referralThreeLevelPercent?: SortOrder
    referralInviteRewardStars?: SortOrder
    referralInvitePremiumRewardStars?: SortOrder
    limitDevices?: SortOrder
    freePlanDays?: SortOrder
    freePlanDaysForReferrals?: SortOrder
  }

  export type SettingsMinOrderByAggregateInput = {
    key?: SortOrder
    tgStarsToUSD?: SortOrder
    priceSubscriptionStars?: SortOrder
    comissionStarsToTon?: SortOrder
    adsRewardStars?: SortOrder
    adsTaskRewardStars?: SortOrder
    hourRatioPayment?: SortOrder
    dayRatioPayment?: SortOrder
    threeMouthesRatioPayment?: SortOrder
    sixMouthesRatioPayment?: SortOrder
    oneYearRatioPayment?: SortOrder
    twoYearRatioPayment?: SortOrder
    threeYearRatioPayment?: SortOrder
    referralOneLevelPercent?: SortOrder
    referralTwoLevelPercent?: SortOrder
    referralThreeLevelPercent?: SortOrder
    referralInviteRewardStars?: SortOrder
    referralInvitePremiumRewardStars?: SortOrder
    limitDevices?: SortOrder
    freePlanDays?: SortOrder
    freePlanDaysForReferrals?: SortOrder
  }

  export type SettingsSumOrderByAggregateInput = {
    tgStarsToUSD?: SortOrder
    priceSubscriptionStars?: SortOrder
    comissionStarsToTon?: SortOrder
    adsRewardStars?: SortOrder
    adsTaskRewardStars?: SortOrder
    hourRatioPayment?: SortOrder
    dayRatioPayment?: SortOrder
    threeMouthesRatioPayment?: SortOrder
    sixMouthesRatioPayment?: SortOrder
    oneYearRatioPayment?: SortOrder
    twoYearRatioPayment?: SortOrder
    threeYearRatioPayment?: SortOrder
    referralOneLevelPercent?: SortOrder
    referralTwoLevelPercent?: SortOrder
    referralThreeLevelPercent?: SortOrder
    referralInviteRewardStars?: SortOrder
    referralInvitePremiumRewardStars?: SortOrder
    limitDevices?: SortOrder
    freePlanDays?: SortOrder
    freePlanDaysForReferrals?: SortOrder
  }

  export type EnumDefaultEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DefaultEnum | EnumDefaultEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DefaultEnum[] | ListEnumDefaultEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefaultEnum[] | ListEnumDefaultEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDefaultEnumWithAggregatesFilter<$PrismaModel> | $Enums.DefaultEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDefaultEnumFilter<$PrismaModel>
    _max?: NestedEnumDefaultEnumFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UsersNullableScalarRelationFilter = {
    is?: UsersWhereInput | null
    isNot?: UsersWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserTelegramDataCountOrderByAggregateInput = {
    id?: SortOrder
    isLive?: SortOrder
    isRtl?: SortOrder
    isPremium?: SortOrder
    isBot?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    languageCode?: SortOrder
    photoUrl?: SortOrder
    addedToAttachmentMenu?: SortOrder
    allowsWriteToPm?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTelegramDataMaxOrderByAggregateInput = {
    id?: SortOrder
    isLive?: SortOrder
    isRtl?: SortOrder
    isPremium?: SortOrder
    isBot?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    languageCode?: SortOrder
    photoUrl?: SortOrder
    addedToAttachmentMenu?: SortOrder
    allowsWriteToPm?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTelegramDataMinOrderByAggregateInput = {
    id?: SortOrder
    isLive?: SortOrder
    isRtl?: SortOrder
    isPremium?: SortOrder
    isBot?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    languageCode?: SortOrder
    photoUrl?: SortOrder
    addedToAttachmentMenu?: SortOrder
    allowsWriteToPm?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UsersScalarRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type ReferralsCountOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    inviterId?: SortOrder
    referralId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralsAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type ReferralsMaxOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    inviterId?: SortOrder
    referralId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralsMinOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    inviterId?: SortOrder
    referralId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralsSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumUserRoleEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRoleEnum | EnumUserRoleEnumFieldRefInput<$PrismaModel>
    in?: $Enums.UserRoleEnum[] | ListEnumUserRoleEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRoleEnum[] | ListEnumUserRoleEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleEnumFilter<$PrismaModel> | $Enums.UserRoleEnum
  }

  export type RolesScalarRelationFilter = {
    is?: RolesWhereInput
    isNot?: RolesWhereInput
  }

  export type PaymentsListRelationFilter = {
    every?: PaymentsWhereInput
    some?: PaymentsWhereInput
    none?: PaymentsWhereInput
  }

  export type ReferralsListRelationFilter = {
    every?: ReferralsWhereInput
    some?: ReferralsWhereInput
    none?: ReferralsWhereInput
  }

  export type UserTelegramDataNullableScalarRelationFilter = {
    is?: UserTelegramDataWhereInput | null
    isNot?: UserTelegramDataWhereInput | null
  }

  export type UserBalanceNullableScalarRelationFilter = {
    is?: UserBalanceWhereInput | null
    isNot?: UserBalanceWhereInput | null
  }

  export type LanguageScalarRelationFilter = {
    is?: LanguageWhereInput
    isNot?: LanguageWhereInput
  }

  export type SubscriptionsListRelationFilter = {
    every?: SubscriptionsWhereInput
    some?: SubscriptionsWhereInput
    none?: SubscriptionsWhereInput
  }

  export type WithdrawalsListRelationFilter = {
    every?: WithdrawalsWhereInput
    some?: WithdrawalsWhereInput
    none?: WithdrawalsWhereInput
  }

  export type AdsViewsListRelationFilter = {
    every?: AdsViewsWhereInput
    some?: AdsViewsWhereInput
    none?: AdsViewsWhereInput
  }

  export type PaymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WithdrawalsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdsViewsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder
    telegramId?: SortOrder
    tonWallet?: SortOrder
    isFreePlanAvailable?: SortOrder
    isBanned?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastStartedAt?: SortOrder
    banExpiredAt?: SortOrder
    deletedAt?: SortOrder
    roleId?: SortOrder
    telegramDataId?: SortOrder
    balanceId?: SortOrder
    languageId?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder
    telegramId?: SortOrder
    tonWallet?: SortOrder
    isFreePlanAvailable?: SortOrder
    isBanned?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastStartedAt?: SortOrder
    banExpiredAt?: SortOrder
    deletedAt?: SortOrder
    roleId?: SortOrder
    telegramDataId?: SortOrder
    balanceId?: SortOrder
    languageId?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder
    telegramId?: SortOrder
    tonWallet?: SortOrder
    isFreePlanAvailable?: SortOrder
    isBanned?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastStartedAt?: SortOrder
    banExpiredAt?: SortOrder
    deletedAt?: SortOrder
    roleId?: SortOrder
    telegramDataId?: SortOrder
    balanceId?: SortOrder
    languageId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRoleEnum | EnumUserRoleEnumFieldRefInput<$PrismaModel>
    in?: $Enums.UserRoleEnum[] | ListEnumUserRoleEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRoleEnum[] | ListEnumUserRoleEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleEnumWithAggregatesFilter<$PrismaModel> | $Enums.UserRoleEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleEnumFilter<$PrismaModel>
    _max?: NestedEnumUserRoleEnumFilter<$PrismaModel>
  }

  export type EnumAdsNetworkEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.AdsNetworkEnum | EnumAdsNetworkEnumFieldRefInput<$PrismaModel>
    in?: $Enums.AdsNetworkEnum[] | ListEnumAdsNetworkEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdsNetworkEnum[] | ListEnumAdsNetworkEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumAdsNetworkEnumFilter<$PrismaModel> | $Enums.AdsNetworkEnum
  }

  export type EnumAdsViewTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.AdsViewTypeEnum | EnumAdsViewTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.AdsViewTypeEnum[] | ListEnumAdsViewTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdsViewTypeEnum[] | ListEnumAdsViewTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumAdsViewTypeEnumFilter<$PrismaModel> | $Enums.AdsViewTypeEnum
  }

  export type AdsNetworksScalarRelationFilter = {
    is?: AdsNetworksWhereInput
    isNot?: AdsNetworksWhereInput
  }

  export type AdsViewsCountOrderByAggregateInput = {
    id?: SortOrder
    networkKey?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type AdsViewsMaxOrderByAggregateInput = {
    id?: SortOrder
    networkKey?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type AdsViewsMinOrderByAggregateInput = {
    id?: SortOrder
    networkKey?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type EnumAdsNetworkEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdsNetworkEnum | EnumAdsNetworkEnumFieldRefInput<$PrismaModel>
    in?: $Enums.AdsNetworkEnum[] | ListEnumAdsNetworkEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdsNetworkEnum[] | ListEnumAdsNetworkEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumAdsNetworkEnumWithAggregatesFilter<$PrismaModel> | $Enums.AdsNetworkEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdsNetworkEnumFilter<$PrismaModel>
    _max?: NestedEnumAdsNetworkEnumFilter<$PrismaModel>
  }

  export type EnumAdsViewTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdsViewTypeEnum | EnumAdsViewTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.AdsViewTypeEnum[] | ListEnumAdsViewTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdsViewTypeEnum[] | ListEnumAdsViewTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumAdsViewTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.AdsViewTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdsViewTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumAdsViewTypeEnumFilter<$PrismaModel>
  }

  export type AdsNetworksCountOrderByAggregateInput = {
    key?: SortOrder
    isActive?: SortOrder
    name?: SortOrder
  }

  export type AdsNetworksMaxOrderByAggregateInput = {
    key?: SortOrder
    isActive?: SortOrder
    name?: SortOrder
  }

  export type AdsNetworksMinOrderByAggregateInput = {
    key?: SortOrder
    isActive?: SortOrder
    name?: SortOrder
  }

  export type TransactionsListRelationFilter = {
    every?: TransactionsWhereInput
    some?: TransactionsWhereInput
    none?: TransactionsWhereInput
  }

  export type TransactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBalanceCountOrderByAggregateInput = {
    id?: SortOrder
    paymentBalance?: SortOrder
    holdBalance?: SortOrder
    totalEarnedWithdrawalBalance?: SortOrder
    withdrawalBalance?: SortOrder
    isUseWithdrawalBalance?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBalanceAvgOrderByAggregateInput = {
    paymentBalance?: SortOrder
    holdBalance?: SortOrder
    totalEarnedWithdrawalBalance?: SortOrder
    withdrawalBalance?: SortOrder
  }

  export type UserBalanceMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentBalance?: SortOrder
    holdBalance?: SortOrder
    totalEarnedWithdrawalBalance?: SortOrder
    withdrawalBalance?: SortOrder
    isUseWithdrawalBalance?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBalanceMinOrderByAggregateInput = {
    id?: SortOrder
    paymentBalance?: SortOrder
    holdBalance?: SortOrder
    totalEarnedWithdrawalBalance?: SortOrder
    withdrawalBalance?: SortOrder
    isUseWithdrawalBalance?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBalanceSumOrderByAggregateInput = {
    paymentBalance?: SortOrder
    holdBalance?: SortOrder
    totalEarnedWithdrawalBalance?: SortOrder
    withdrawalBalance?: SortOrder
  }

  export type EnumSubscriptionPeriodEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPeriodEnum | EnumSubscriptionPeriodEnumFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPeriodEnum[] | ListEnumSubscriptionPeriodEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPeriodEnum[] | ListEnumSubscriptionPeriodEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPeriodEnumFilter<$PrismaModel> | $Enums.SubscriptionPeriodEnum
  }

  export type SubscriptionsCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    isActive?: SortOrder
    isAutoRenewal?: SortOrder
    token?: SortOrder
    period?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiredAt?: SortOrder
    userId?: SortOrder
  }

  export type SubscriptionsMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    isActive?: SortOrder
    isAutoRenewal?: SortOrder
    token?: SortOrder
    period?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiredAt?: SortOrder
    userId?: SortOrder
  }

  export type SubscriptionsMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    isActive?: SortOrder
    isAutoRenewal?: SortOrder
    token?: SortOrder
    period?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiredAt?: SortOrder
    userId?: SortOrder
  }

  export type EnumSubscriptionPeriodEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPeriodEnum | EnumSubscriptionPeriodEnumFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPeriodEnum[] | ListEnumSubscriptionPeriodEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPeriodEnum[] | ListEnumSubscriptionPeriodEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPeriodEnumWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPeriodEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPeriodEnumFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPeriodEnumFilter<$PrismaModel>
  }

  export type UsersListRelationFilter = {
    every?: UsersWhereInput
    some?: UsersWhereInput
    none?: UsersWhereInput
  }

  export type UsersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RolesCountOrderByAggregateInput = {
    key?: SortOrder
    name?: SortOrder
    discount?: SortOrder
    limitSubscriptions?: SortOrder
  }

  export type RolesAvgOrderByAggregateInput = {
    discount?: SortOrder
    limitSubscriptions?: SortOrder
  }

  export type RolesMaxOrderByAggregateInput = {
    key?: SortOrder
    name?: SortOrder
    discount?: SortOrder
    limitSubscriptions?: SortOrder
  }

  export type RolesMinOrderByAggregateInput = {
    key?: SortOrder
    name?: SortOrder
    discount?: SortOrder
    limitSubscriptions?: SortOrder
  }

  export type RolesSumOrderByAggregateInput = {
    discount?: SortOrder
    limitSubscriptions?: SortOrder
  }

  export type LanguageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nativeName?: SortOrder
    iso6391?: SortOrder
    iso6392?: SortOrder
    iso6393?: SortOrder
  }

  export type LanguageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nativeName?: SortOrder
    iso6391?: SortOrder
    iso6392?: SortOrder
    iso6393?: SortOrder
  }

  export type LanguageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nativeName?: SortOrder
    iso6391?: SortOrder
    iso6392?: SortOrder
    iso6393?: SortOrder
  }

  export type EnumCurrencyEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyEnum | EnumCurrencyEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyEnum[] | ListEnumCurrencyEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyEnum[] | ListEnumCurrencyEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyEnumFilter<$PrismaModel> | $Enums.CurrencyEnum
  }

  export type PaymentMethodsListRelationFilter = {
    every?: PaymentMethodsWhereInput
    some?: PaymentMethodsWhereInput
    none?: PaymentMethodsWhereInput
  }

  export type PaymentMethodsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CurrencyCountOrderByAggregateInput = {
    key?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    rate?: SortOrder
    coinmarketcapUCID?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencyAvgOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type CurrencyMaxOrderByAggregateInput = {
    key?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    rate?: SortOrder
    coinmarketcapUCID?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencyMinOrderByAggregateInput = {
    key?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    rate?: SortOrder
    coinmarketcapUCID?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencySumOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type EnumCurrencyEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyEnum | EnumCurrencyEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyEnum[] | ListEnumCurrencyEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyEnum[] | ListEnumCurrencyEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyEnumWithAggregatesFilter<$PrismaModel> | $Enums.CurrencyEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCurrencyEnumFilter<$PrismaModel>
    _max?: NestedEnumCurrencyEnumFilter<$PrismaModel>
  }

  export type EnumTransactionTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionTypeEnum | EnumTransactionTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionTypeEnum[] | ListEnumTransactionTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionTypeEnum[] | ListEnumTransactionTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeEnumFilter<$PrismaModel> | $Enums.TransactionTypeEnum
  }

  export type EnumTransactionReasonEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionReasonEnum | EnumTransactionReasonEnumFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionReasonEnum[] | ListEnumTransactionReasonEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionReasonEnum[] | ListEnumTransactionReasonEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionReasonEnumFilter<$PrismaModel> | $Enums.TransactionReasonEnum
  }

  export type EnumBalanceTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.BalanceTypeEnum | EnumBalanceTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.BalanceTypeEnum[] | ListEnumBalanceTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.BalanceTypeEnum[] | ListEnumBalanceTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumBalanceTypeEnumFilter<$PrismaModel> | $Enums.BalanceTypeEnum
  }

  export type UserBalanceScalarRelationFilter = {
    is?: UserBalanceWhereInput
    isNot?: UserBalanceWhereInput
  }

  export type WithdrawalsNullableScalarRelationFilter = {
    is?: WithdrawalsWhereInput | null
    isNot?: WithdrawalsWhereInput | null
  }

  export type PaymentsNullableScalarRelationFilter = {
    is?: PaymentsWhereInput | null
    isNot?: PaymentsWhereInput | null
  }

  export type TransactionsCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    isHold?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    balanceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    holdExpiredAt?: SortOrder
    balanceId?: SortOrder
  }

  export type TransactionsAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    isHold?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    balanceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    holdExpiredAt?: SortOrder
    balanceId?: SortOrder
  }

  export type TransactionsMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    isHold?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    balanceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    holdExpiredAt?: SortOrder
    balanceId?: SortOrder
  }

  export type TransactionsSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumTransactionTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionTypeEnum | EnumTransactionTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionTypeEnum[] | ListEnumTransactionTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionTypeEnum[] | ListEnumTransactionTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.TransactionTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeEnumFilter<$PrismaModel>
  }

  export type EnumTransactionReasonEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionReasonEnum | EnumTransactionReasonEnumFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionReasonEnum[] | ListEnumTransactionReasonEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionReasonEnum[] | ListEnumTransactionReasonEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionReasonEnumWithAggregatesFilter<$PrismaModel> | $Enums.TransactionReasonEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionReasonEnumFilter<$PrismaModel>
    _max?: NestedEnumTransactionReasonEnumFilter<$PrismaModel>
  }

  export type EnumBalanceTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BalanceTypeEnum | EnumBalanceTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.BalanceTypeEnum[] | ListEnumBalanceTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.BalanceTypeEnum[] | ListEnumBalanceTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumBalanceTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.BalanceTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBalanceTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumBalanceTypeEnumFilter<$PrismaModel>
  }

  export type EnumWithdrawalStatusEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.WithdrawalStatusEnum | EnumWithdrawalStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.WithdrawalStatusEnum[] | ListEnumWithdrawalStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.WithdrawalStatusEnum[] | ListEnumWithdrawalStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumWithdrawalStatusEnumFilter<$PrismaModel> | $Enums.WithdrawalStatusEnum
  }

  export type TransactionsScalarRelationFilter = {
    is?: TransactionsWhereInput
    isNot?: TransactionsWhereInput
  }

  export type WithdrawalsCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    amountStars?: SortOrder
    amountUSD?: SortOrder
    amountTON?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
  }

  export type WithdrawalsAvgOrderByAggregateInput = {
    amountStars?: SortOrder
    amountUSD?: SortOrder
    amountTON?: SortOrder
  }

  export type WithdrawalsMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    amountStars?: SortOrder
    amountUSD?: SortOrder
    amountTON?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
  }

  export type WithdrawalsMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    amountStars?: SortOrder
    amountUSD?: SortOrder
    amountTON?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
  }

  export type WithdrawalsSumOrderByAggregateInput = {
    amountStars?: SortOrder
    amountUSD?: SortOrder
    amountTON?: SortOrder
  }

  export type EnumWithdrawalStatusEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WithdrawalStatusEnum | EnumWithdrawalStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.WithdrawalStatusEnum[] | ListEnumWithdrawalStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.WithdrawalStatusEnum[] | ListEnumWithdrawalStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumWithdrawalStatusEnumWithAggregatesFilter<$PrismaModel> | $Enums.WithdrawalStatusEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWithdrawalStatusEnumFilter<$PrismaModel>
    _max?: NestedEnumWithdrawalStatusEnumFilter<$PrismaModel>
  }

  export type EnumPaymentStatusEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatusEnum | EnumPaymentStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatusEnum[] | ListEnumPaymentStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatusEnum[] | ListEnumPaymentStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusEnumFilter<$PrismaModel> | $Enums.PaymentStatusEnum
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumPaymentMethodEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodEnum | EnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodEnum[] | ListEnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethodEnum[] | ListEnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodEnumFilter<$PrismaModel> | $Enums.PaymentMethodEnum
  }

  export type CurrencyScalarRelationFilter = {
    is?: CurrencyWhereInput
    isNot?: CurrencyWhereInput
  }

  export type SubscriptionsNullableScalarRelationFilter = {
    is?: SubscriptionsWhereInput | null
    isNot?: SubscriptionsWhereInput | null
  }

  export type PaymentMethodsScalarRelationFilter = {
    is?: PaymentMethodsWhereInput
    isNot?: PaymentMethodsWhereInput
  }

  export type TransactionsNullableScalarRelationFilter = {
    is?: TransactionsWhereInput | null
    isNot?: TransactionsWhereInput | null
  }

  export type PaymentsCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    exchangeRate?: SortOrder
    token?: SortOrder
    linkPay?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    currencyKey?: SortOrder
    SubscriptionId?: SortOrder
    methodKey?: SortOrder
    transactionId?: SortOrder
  }

  export type PaymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    exchangeRate?: SortOrder
    token?: SortOrder
    linkPay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    currencyKey?: SortOrder
    SubscriptionId?: SortOrder
    methodKey?: SortOrder
    transactionId?: SortOrder
  }

  export type PaymentsMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    exchangeRate?: SortOrder
    token?: SortOrder
    linkPay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    currencyKey?: SortOrder
    SubscriptionId?: SortOrder
    methodKey?: SortOrder
    transactionId?: SortOrder
  }

  export type EnumPaymentStatusEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatusEnum | EnumPaymentStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatusEnum[] | ListEnumPaymentStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatusEnum[] | ListEnumPaymentStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusEnumWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatusEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusEnumFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusEnumFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumPaymentMethodEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodEnum | EnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodEnum[] | ListEnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethodEnum[] | ListEnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodEnumWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethodEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodEnumFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodEnumFilter<$PrismaModel>
  }

  export type EnumPaymentMethodTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodTypeEnum | EnumPaymentMethodTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodTypeEnum[] | ListEnumPaymentMethodTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethodTypeEnum[] | ListEnumPaymentMethodTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodTypeEnumFilter<$PrismaModel> | $Enums.PaymentMethodTypeEnum
  }

  export type EnumPaymentSystemEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentSystemEnum | EnumPaymentSystemEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentSystemEnum[] | ListEnumPaymentSystemEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentSystemEnum[] | ListEnumPaymentSystemEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentSystemEnumFilter<$PrismaModel> | $Enums.PaymentSystemEnum
  }

  export type PaymentMethodsCountOrderByAggregateInput = {
    key?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    isTonBlockchain?: SortOrder
    tonSmartContractAddress?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    commission?: SortOrder
    isPlusCommission?: SortOrder
    type?: SortOrder
    system?: SortOrder
    currencyKey?: SortOrder
  }

  export type PaymentMethodsAvgOrderByAggregateInput = {
    minAmount?: SortOrder
    maxAmount?: SortOrder
    commission?: SortOrder
  }

  export type PaymentMethodsMaxOrderByAggregateInput = {
    key?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    isTonBlockchain?: SortOrder
    tonSmartContractAddress?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    commission?: SortOrder
    isPlusCommission?: SortOrder
    type?: SortOrder
    system?: SortOrder
    currencyKey?: SortOrder
  }

  export type PaymentMethodsMinOrderByAggregateInput = {
    key?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    isTonBlockchain?: SortOrder
    tonSmartContractAddress?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    commission?: SortOrder
    isPlusCommission?: SortOrder
    type?: SortOrder
    system?: SortOrder
    currencyKey?: SortOrder
  }

  export type PaymentMethodsSumOrderByAggregateInput = {
    minAmount?: SortOrder
    maxAmount?: SortOrder
    commission?: SortOrder
  }

  export type EnumPaymentMethodTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodTypeEnum | EnumPaymentMethodTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodTypeEnum[] | ListEnumPaymentMethodTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethodTypeEnum[] | ListEnumPaymentMethodTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethodTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodTypeEnumFilter<$PrismaModel>
  }

  export type EnumPaymentSystemEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentSystemEnum | EnumPaymentSystemEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentSystemEnum[] | ListEnumPaymentSystemEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentSystemEnum[] | ListEnumPaymentSystemEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentSystemEnumWithAggregatesFilter<$PrismaModel> | $Enums.PaymentSystemEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentSystemEnumFilter<$PrismaModel>
    _max?: NestedEnumPaymentSystemEnumFilter<$PrismaModel>
  }

  export type EnumDefaultEnumFieldUpdateOperationsInput = {
    set?: $Enums.DefaultEnum
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UsersCreateNestedOneWithoutTelegramDataInput = {
    create?: XOR<UsersCreateWithoutTelegramDataInput, UsersUncheckedCreateWithoutTelegramDataInput>
    connectOrCreate?: UsersCreateOrConnectWithoutTelegramDataInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUncheckedCreateNestedOneWithoutTelegramDataInput = {
    create?: XOR<UsersCreateWithoutTelegramDataInput, UsersUncheckedCreateWithoutTelegramDataInput>
    connectOrCreate?: UsersCreateOrConnectWithoutTelegramDataInput
    connect?: UsersWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UsersUpdateOneWithoutTelegramDataNestedInput = {
    create?: XOR<UsersCreateWithoutTelegramDataInput, UsersUncheckedCreateWithoutTelegramDataInput>
    connectOrCreate?: UsersCreateOrConnectWithoutTelegramDataInput
    upsert?: UsersUpsertWithoutTelegramDataInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutTelegramDataInput, UsersUpdateWithoutTelegramDataInput>, UsersUncheckedUpdateWithoutTelegramDataInput>
  }

  export type UsersUncheckedUpdateOneWithoutTelegramDataNestedInput = {
    create?: XOR<UsersCreateWithoutTelegramDataInput, UsersUncheckedCreateWithoutTelegramDataInput>
    connectOrCreate?: UsersCreateOrConnectWithoutTelegramDataInput
    upsert?: UsersUpsertWithoutTelegramDataInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutTelegramDataInput, UsersUpdateWithoutTelegramDataInput>, UsersUncheckedUpdateWithoutTelegramDataInput>
  }

  export type UsersCreateNestedOneWithoutInvitersInput = {
    create?: XOR<UsersCreateWithoutInvitersInput, UsersUncheckedCreateWithoutInvitersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutInvitersInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutReferralsInput = {
    create?: XOR<UsersCreateWithoutReferralsInput, UsersUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutReferralsInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutInvitersNestedInput = {
    create?: XOR<UsersCreateWithoutInvitersInput, UsersUncheckedCreateWithoutInvitersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutInvitersInput
    upsert?: UsersUpsertWithoutInvitersInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutInvitersInput, UsersUpdateWithoutInvitersInput>, UsersUncheckedUpdateWithoutInvitersInput>
  }

  export type UsersUpdateOneRequiredWithoutReferralsNestedInput = {
    create?: XOR<UsersCreateWithoutReferralsInput, UsersUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutReferralsInput
    upsert?: UsersUpsertWithoutReferralsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutReferralsInput, UsersUpdateWithoutReferralsInput>, UsersUncheckedUpdateWithoutReferralsInput>
  }

  export type RolesCreateNestedOneWithoutUsersInput = {
    create?: XOR<RolesCreateWithoutUsersInput, RolesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RolesCreateOrConnectWithoutUsersInput
    connect?: RolesWhereUniqueInput
  }

  export type PaymentsCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentsCreateWithoutUserInput, PaymentsUncheckedCreateWithoutUserInput> | PaymentsCreateWithoutUserInput[] | PaymentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutUserInput | PaymentsCreateOrConnectWithoutUserInput[]
    createMany?: PaymentsCreateManyUserInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type ReferralsCreateNestedManyWithoutReferralInput = {
    create?: XOR<ReferralsCreateWithoutReferralInput, ReferralsUncheckedCreateWithoutReferralInput> | ReferralsCreateWithoutReferralInput[] | ReferralsUncheckedCreateWithoutReferralInput[]
    connectOrCreate?: ReferralsCreateOrConnectWithoutReferralInput | ReferralsCreateOrConnectWithoutReferralInput[]
    createMany?: ReferralsCreateManyReferralInputEnvelope
    connect?: ReferralsWhereUniqueInput | ReferralsWhereUniqueInput[]
  }

  export type ReferralsCreateNestedManyWithoutInviterInput = {
    create?: XOR<ReferralsCreateWithoutInviterInput, ReferralsUncheckedCreateWithoutInviterInput> | ReferralsCreateWithoutInviterInput[] | ReferralsUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: ReferralsCreateOrConnectWithoutInviterInput | ReferralsCreateOrConnectWithoutInviterInput[]
    createMany?: ReferralsCreateManyInviterInputEnvelope
    connect?: ReferralsWhereUniqueInput | ReferralsWhereUniqueInput[]
  }

  export type UserTelegramDataCreateNestedOneWithoutUserInput = {
    create?: XOR<UserTelegramDataCreateWithoutUserInput, UserTelegramDataUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserTelegramDataCreateOrConnectWithoutUserInput
    connect?: UserTelegramDataWhereUniqueInput
  }

  export type UserBalanceCreateNestedOneWithoutUserInput = {
    create?: XOR<UserBalanceCreateWithoutUserInput, UserBalanceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserBalanceCreateOrConnectWithoutUserInput
    connect?: UserBalanceWhereUniqueInput
  }

  export type LanguageCreateNestedOneWithoutUsersInput = {
    create?: XOR<LanguageCreateWithoutUsersInput, LanguageUncheckedCreateWithoutUsersInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutUsersInput
    connect?: LanguageWhereUniqueInput
  }

  export type SubscriptionsCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionsCreateWithoutUserInput, SubscriptionsUncheckedCreateWithoutUserInput> | SubscriptionsCreateWithoutUserInput[] | SubscriptionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutUserInput | SubscriptionsCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionsCreateManyUserInputEnvelope
    connect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
  }

  export type WithdrawalsCreateNestedManyWithoutUserInput = {
    create?: XOR<WithdrawalsCreateWithoutUserInput, WithdrawalsUncheckedCreateWithoutUserInput> | WithdrawalsCreateWithoutUserInput[] | WithdrawalsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WithdrawalsCreateOrConnectWithoutUserInput | WithdrawalsCreateOrConnectWithoutUserInput[]
    createMany?: WithdrawalsCreateManyUserInputEnvelope
    connect?: WithdrawalsWhereUniqueInput | WithdrawalsWhereUniqueInput[]
  }

  export type AdsViewsCreateNestedManyWithoutUserInput = {
    create?: XOR<AdsViewsCreateWithoutUserInput, AdsViewsUncheckedCreateWithoutUserInput> | AdsViewsCreateWithoutUserInput[] | AdsViewsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdsViewsCreateOrConnectWithoutUserInput | AdsViewsCreateOrConnectWithoutUserInput[]
    createMany?: AdsViewsCreateManyUserInputEnvelope
    connect?: AdsViewsWhereUniqueInput | AdsViewsWhereUniqueInput[]
  }

  export type PaymentsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentsCreateWithoutUserInput, PaymentsUncheckedCreateWithoutUserInput> | PaymentsCreateWithoutUserInput[] | PaymentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutUserInput | PaymentsCreateOrConnectWithoutUserInput[]
    createMany?: PaymentsCreateManyUserInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type ReferralsUncheckedCreateNestedManyWithoutReferralInput = {
    create?: XOR<ReferralsCreateWithoutReferralInput, ReferralsUncheckedCreateWithoutReferralInput> | ReferralsCreateWithoutReferralInput[] | ReferralsUncheckedCreateWithoutReferralInput[]
    connectOrCreate?: ReferralsCreateOrConnectWithoutReferralInput | ReferralsCreateOrConnectWithoutReferralInput[]
    createMany?: ReferralsCreateManyReferralInputEnvelope
    connect?: ReferralsWhereUniqueInput | ReferralsWhereUniqueInput[]
  }

  export type ReferralsUncheckedCreateNestedManyWithoutInviterInput = {
    create?: XOR<ReferralsCreateWithoutInviterInput, ReferralsUncheckedCreateWithoutInviterInput> | ReferralsCreateWithoutInviterInput[] | ReferralsUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: ReferralsCreateOrConnectWithoutInviterInput | ReferralsCreateOrConnectWithoutInviterInput[]
    createMany?: ReferralsCreateManyInviterInputEnvelope
    connect?: ReferralsWhereUniqueInput | ReferralsWhereUniqueInput[]
  }

  export type SubscriptionsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionsCreateWithoutUserInput, SubscriptionsUncheckedCreateWithoutUserInput> | SubscriptionsCreateWithoutUserInput[] | SubscriptionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutUserInput | SubscriptionsCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionsCreateManyUserInputEnvelope
    connect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
  }

  export type WithdrawalsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WithdrawalsCreateWithoutUserInput, WithdrawalsUncheckedCreateWithoutUserInput> | WithdrawalsCreateWithoutUserInput[] | WithdrawalsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WithdrawalsCreateOrConnectWithoutUserInput | WithdrawalsCreateOrConnectWithoutUserInput[]
    createMany?: WithdrawalsCreateManyUserInputEnvelope
    connect?: WithdrawalsWhereUniqueInput | WithdrawalsWhereUniqueInput[]
  }

  export type AdsViewsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AdsViewsCreateWithoutUserInput, AdsViewsUncheckedCreateWithoutUserInput> | AdsViewsCreateWithoutUserInput[] | AdsViewsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdsViewsCreateOrConnectWithoutUserInput | AdsViewsCreateOrConnectWithoutUserInput[]
    createMany?: AdsViewsCreateManyUserInputEnvelope
    connect?: AdsViewsWhereUniqueInput | AdsViewsWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type RolesUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RolesCreateWithoutUsersInput, RolesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RolesCreateOrConnectWithoutUsersInput
    upsert?: RolesUpsertWithoutUsersInput
    connect?: RolesWhereUniqueInput
    update?: XOR<XOR<RolesUpdateToOneWithWhereWithoutUsersInput, RolesUpdateWithoutUsersInput>, RolesUncheckedUpdateWithoutUsersInput>
  }

  export type PaymentsUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentsCreateWithoutUserInput, PaymentsUncheckedCreateWithoutUserInput> | PaymentsCreateWithoutUserInput[] | PaymentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutUserInput | PaymentsCreateOrConnectWithoutUserInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutUserInput | PaymentsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentsCreateManyUserInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutUserInput | PaymentsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutUserInput | PaymentsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type ReferralsUpdateManyWithoutReferralNestedInput = {
    create?: XOR<ReferralsCreateWithoutReferralInput, ReferralsUncheckedCreateWithoutReferralInput> | ReferralsCreateWithoutReferralInput[] | ReferralsUncheckedCreateWithoutReferralInput[]
    connectOrCreate?: ReferralsCreateOrConnectWithoutReferralInput | ReferralsCreateOrConnectWithoutReferralInput[]
    upsert?: ReferralsUpsertWithWhereUniqueWithoutReferralInput | ReferralsUpsertWithWhereUniqueWithoutReferralInput[]
    createMany?: ReferralsCreateManyReferralInputEnvelope
    set?: ReferralsWhereUniqueInput | ReferralsWhereUniqueInput[]
    disconnect?: ReferralsWhereUniqueInput | ReferralsWhereUniqueInput[]
    delete?: ReferralsWhereUniqueInput | ReferralsWhereUniqueInput[]
    connect?: ReferralsWhereUniqueInput | ReferralsWhereUniqueInput[]
    update?: ReferralsUpdateWithWhereUniqueWithoutReferralInput | ReferralsUpdateWithWhereUniqueWithoutReferralInput[]
    updateMany?: ReferralsUpdateManyWithWhereWithoutReferralInput | ReferralsUpdateManyWithWhereWithoutReferralInput[]
    deleteMany?: ReferralsScalarWhereInput | ReferralsScalarWhereInput[]
  }

  export type ReferralsUpdateManyWithoutInviterNestedInput = {
    create?: XOR<ReferralsCreateWithoutInviterInput, ReferralsUncheckedCreateWithoutInviterInput> | ReferralsCreateWithoutInviterInput[] | ReferralsUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: ReferralsCreateOrConnectWithoutInviterInput | ReferralsCreateOrConnectWithoutInviterInput[]
    upsert?: ReferralsUpsertWithWhereUniqueWithoutInviterInput | ReferralsUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: ReferralsCreateManyInviterInputEnvelope
    set?: ReferralsWhereUniqueInput | ReferralsWhereUniqueInput[]
    disconnect?: ReferralsWhereUniqueInput | ReferralsWhereUniqueInput[]
    delete?: ReferralsWhereUniqueInput | ReferralsWhereUniqueInput[]
    connect?: ReferralsWhereUniqueInput | ReferralsWhereUniqueInput[]
    update?: ReferralsUpdateWithWhereUniqueWithoutInviterInput | ReferralsUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: ReferralsUpdateManyWithWhereWithoutInviterInput | ReferralsUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: ReferralsScalarWhereInput | ReferralsScalarWhereInput[]
  }

  export type UserTelegramDataUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserTelegramDataCreateWithoutUserInput, UserTelegramDataUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserTelegramDataCreateOrConnectWithoutUserInput
    upsert?: UserTelegramDataUpsertWithoutUserInput
    disconnect?: UserTelegramDataWhereInput | boolean
    delete?: UserTelegramDataWhereInput | boolean
    connect?: UserTelegramDataWhereUniqueInput
    update?: XOR<XOR<UserTelegramDataUpdateToOneWithWhereWithoutUserInput, UserTelegramDataUpdateWithoutUserInput>, UserTelegramDataUncheckedUpdateWithoutUserInput>
  }

  export type UserBalanceUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserBalanceCreateWithoutUserInput, UserBalanceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserBalanceCreateOrConnectWithoutUserInput
    upsert?: UserBalanceUpsertWithoutUserInput
    disconnect?: UserBalanceWhereInput | boolean
    delete?: UserBalanceWhereInput | boolean
    connect?: UserBalanceWhereUniqueInput
    update?: XOR<XOR<UserBalanceUpdateToOneWithWhereWithoutUserInput, UserBalanceUpdateWithoutUserInput>, UserBalanceUncheckedUpdateWithoutUserInput>
  }

  export type LanguageUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<LanguageCreateWithoutUsersInput, LanguageUncheckedCreateWithoutUsersInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutUsersInput
    upsert?: LanguageUpsertWithoutUsersInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutUsersInput, LanguageUpdateWithoutUsersInput>, LanguageUncheckedUpdateWithoutUsersInput>
  }

  export type SubscriptionsUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionsCreateWithoutUserInput, SubscriptionsUncheckedCreateWithoutUserInput> | SubscriptionsCreateWithoutUserInput[] | SubscriptionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutUserInput | SubscriptionsCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionsUpsertWithWhereUniqueWithoutUserInput | SubscriptionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionsCreateManyUserInputEnvelope
    set?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    disconnect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    delete?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    connect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    update?: SubscriptionsUpdateWithWhereUniqueWithoutUserInput | SubscriptionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionsUpdateManyWithWhereWithoutUserInput | SubscriptionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionsScalarWhereInput | SubscriptionsScalarWhereInput[]
  }

  export type WithdrawalsUpdateManyWithoutUserNestedInput = {
    create?: XOR<WithdrawalsCreateWithoutUserInput, WithdrawalsUncheckedCreateWithoutUserInput> | WithdrawalsCreateWithoutUserInput[] | WithdrawalsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WithdrawalsCreateOrConnectWithoutUserInput | WithdrawalsCreateOrConnectWithoutUserInput[]
    upsert?: WithdrawalsUpsertWithWhereUniqueWithoutUserInput | WithdrawalsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WithdrawalsCreateManyUserInputEnvelope
    set?: WithdrawalsWhereUniqueInput | WithdrawalsWhereUniqueInput[]
    disconnect?: WithdrawalsWhereUniqueInput | WithdrawalsWhereUniqueInput[]
    delete?: WithdrawalsWhereUniqueInput | WithdrawalsWhereUniqueInput[]
    connect?: WithdrawalsWhereUniqueInput | WithdrawalsWhereUniqueInput[]
    update?: WithdrawalsUpdateWithWhereUniqueWithoutUserInput | WithdrawalsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WithdrawalsUpdateManyWithWhereWithoutUserInput | WithdrawalsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WithdrawalsScalarWhereInput | WithdrawalsScalarWhereInput[]
  }

  export type AdsViewsUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdsViewsCreateWithoutUserInput, AdsViewsUncheckedCreateWithoutUserInput> | AdsViewsCreateWithoutUserInput[] | AdsViewsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdsViewsCreateOrConnectWithoutUserInput | AdsViewsCreateOrConnectWithoutUserInput[]
    upsert?: AdsViewsUpsertWithWhereUniqueWithoutUserInput | AdsViewsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdsViewsCreateManyUserInputEnvelope
    set?: AdsViewsWhereUniqueInput | AdsViewsWhereUniqueInput[]
    disconnect?: AdsViewsWhereUniqueInput | AdsViewsWhereUniqueInput[]
    delete?: AdsViewsWhereUniqueInput | AdsViewsWhereUniqueInput[]
    connect?: AdsViewsWhereUniqueInput | AdsViewsWhereUniqueInput[]
    update?: AdsViewsUpdateWithWhereUniqueWithoutUserInput | AdsViewsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdsViewsUpdateManyWithWhereWithoutUserInput | AdsViewsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdsViewsScalarWhereInput | AdsViewsScalarWhereInput[]
  }

  export type EnumUserRoleEnumFieldUpdateOperationsInput = {
    set?: $Enums.UserRoleEnum
  }

  export type PaymentsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentsCreateWithoutUserInput, PaymentsUncheckedCreateWithoutUserInput> | PaymentsCreateWithoutUserInput[] | PaymentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutUserInput | PaymentsCreateOrConnectWithoutUserInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutUserInput | PaymentsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentsCreateManyUserInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutUserInput | PaymentsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutUserInput | PaymentsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type ReferralsUncheckedUpdateManyWithoutReferralNestedInput = {
    create?: XOR<ReferralsCreateWithoutReferralInput, ReferralsUncheckedCreateWithoutReferralInput> | ReferralsCreateWithoutReferralInput[] | ReferralsUncheckedCreateWithoutReferralInput[]
    connectOrCreate?: ReferralsCreateOrConnectWithoutReferralInput | ReferralsCreateOrConnectWithoutReferralInput[]
    upsert?: ReferralsUpsertWithWhereUniqueWithoutReferralInput | ReferralsUpsertWithWhereUniqueWithoutReferralInput[]
    createMany?: ReferralsCreateManyReferralInputEnvelope
    set?: ReferralsWhereUniqueInput | ReferralsWhereUniqueInput[]
    disconnect?: ReferralsWhereUniqueInput | ReferralsWhereUniqueInput[]
    delete?: ReferralsWhereUniqueInput | ReferralsWhereUniqueInput[]
    connect?: ReferralsWhereUniqueInput | ReferralsWhereUniqueInput[]
    update?: ReferralsUpdateWithWhereUniqueWithoutReferralInput | ReferralsUpdateWithWhereUniqueWithoutReferralInput[]
    updateMany?: ReferralsUpdateManyWithWhereWithoutReferralInput | ReferralsUpdateManyWithWhereWithoutReferralInput[]
    deleteMany?: ReferralsScalarWhereInput | ReferralsScalarWhereInput[]
  }

  export type ReferralsUncheckedUpdateManyWithoutInviterNestedInput = {
    create?: XOR<ReferralsCreateWithoutInviterInput, ReferralsUncheckedCreateWithoutInviterInput> | ReferralsCreateWithoutInviterInput[] | ReferralsUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: ReferralsCreateOrConnectWithoutInviterInput | ReferralsCreateOrConnectWithoutInviterInput[]
    upsert?: ReferralsUpsertWithWhereUniqueWithoutInviterInput | ReferralsUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: ReferralsCreateManyInviterInputEnvelope
    set?: ReferralsWhereUniqueInput | ReferralsWhereUniqueInput[]
    disconnect?: ReferralsWhereUniqueInput | ReferralsWhereUniqueInput[]
    delete?: ReferralsWhereUniqueInput | ReferralsWhereUniqueInput[]
    connect?: ReferralsWhereUniqueInput | ReferralsWhereUniqueInput[]
    update?: ReferralsUpdateWithWhereUniqueWithoutInviterInput | ReferralsUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: ReferralsUpdateManyWithWhereWithoutInviterInput | ReferralsUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: ReferralsScalarWhereInput | ReferralsScalarWhereInput[]
  }

  export type SubscriptionsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionsCreateWithoutUserInput, SubscriptionsUncheckedCreateWithoutUserInput> | SubscriptionsCreateWithoutUserInput[] | SubscriptionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutUserInput | SubscriptionsCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionsUpsertWithWhereUniqueWithoutUserInput | SubscriptionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionsCreateManyUserInputEnvelope
    set?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    disconnect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    delete?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    connect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    update?: SubscriptionsUpdateWithWhereUniqueWithoutUserInput | SubscriptionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionsUpdateManyWithWhereWithoutUserInput | SubscriptionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionsScalarWhereInput | SubscriptionsScalarWhereInput[]
  }

  export type WithdrawalsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WithdrawalsCreateWithoutUserInput, WithdrawalsUncheckedCreateWithoutUserInput> | WithdrawalsCreateWithoutUserInput[] | WithdrawalsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WithdrawalsCreateOrConnectWithoutUserInput | WithdrawalsCreateOrConnectWithoutUserInput[]
    upsert?: WithdrawalsUpsertWithWhereUniqueWithoutUserInput | WithdrawalsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WithdrawalsCreateManyUserInputEnvelope
    set?: WithdrawalsWhereUniqueInput | WithdrawalsWhereUniqueInput[]
    disconnect?: WithdrawalsWhereUniqueInput | WithdrawalsWhereUniqueInput[]
    delete?: WithdrawalsWhereUniqueInput | WithdrawalsWhereUniqueInput[]
    connect?: WithdrawalsWhereUniqueInput | WithdrawalsWhereUniqueInput[]
    update?: WithdrawalsUpdateWithWhereUniqueWithoutUserInput | WithdrawalsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WithdrawalsUpdateManyWithWhereWithoutUserInput | WithdrawalsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WithdrawalsScalarWhereInput | WithdrawalsScalarWhereInput[]
  }

  export type AdsViewsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdsViewsCreateWithoutUserInput, AdsViewsUncheckedCreateWithoutUserInput> | AdsViewsCreateWithoutUserInput[] | AdsViewsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdsViewsCreateOrConnectWithoutUserInput | AdsViewsCreateOrConnectWithoutUserInput[]
    upsert?: AdsViewsUpsertWithWhereUniqueWithoutUserInput | AdsViewsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdsViewsCreateManyUserInputEnvelope
    set?: AdsViewsWhereUniqueInput | AdsViewsWhereUniqueInput[]
    disconnect?: AdsViewsWhereUniqueInput | AdsViewsWhereUniqueInput[]
    delete?: AdsViewsWhereUniqueInput | AdsViewsWhereUniqueInput[]
    connect?: AdsViewsWhereUniqueInput | AdsViewsWhereUniqueInput[]
    update?: AdsViewsUpdateWithWhereUniqueWithoutUserInput | AdsViewsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdsViewsUpdateManyWithWhereWithoutUserInput | AdsViewsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdsViewsScalarWhereInput | AdsViewsScalarWhereInput[]
  }

  export type AdsNetworksCreateNestedOneWithoutAdsViewsInput = {
    create?: XOR<AdsNetworksCreateWithoutAdsViewsInput, AdsNetworksUncheckedCreateWithoutAdsViewsInput>
    connectOrCreate?: AdsNetworksCreateOrConnectWithoutAdsViewsInput
    connect?: AdsNetworksWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutAdsViewsInput = {
    create?: XOR<UsersCreateWithoutAdsViewsInput, UsersUncheckedCreateWithoutAdsViewsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutAdsViewsInput
    connect?: UsersWhereUniqueInput
  }

  export type EnumAdsViewTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.AdsViewTypeEnum
  }

  export type AdsNetworksUpdateOneRequiredWithoutAdsViewsNestedInput = {
    create?: XOR<AdsNetworksCreateWithoutAdsViewsInput, AdsNetworksUncheckedCreateWithoutAdsViewsInput>
    connectOrCreate?: AdsNetworksCreateOrConnectWithoutAdsViewsInput
    upsert?: AdsNetworksUpsertWithoutAdsViewsInput
    connect?: AdsNetworksWhereUniqueInput
    update?: XOR<XOR<AdsNetworksUpdateToOneWithWhereWithoutAdsViewsInput, AdsNetworksUpdateWithoutAdsViewsInput>, AdsNetworksUncheckedUpdateWithoutAdsViewsInput>
  }

  export type UsersUpdateOneRequiredWithoutAdsViewsNestedInput = {
    create?: XOR<UsersCreateWithoutAdsViewsInput, UsersUncheckedCreateWithoutAdsViewsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutAdsViewsInput
    upsert?: UsersUpsertWithoutAdsViewsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutAdsViewsInput, UsersUpdateWithoutAdsViewsInput>, UsersUncheckedUpdateWithoutAdsViewsInput>
  }

  export type EnumAdsNetworkEnumFieldUpdateOperationsInput = {
    set?: $Enums.AdsNetworkEnum
  }

  export type AdsViewsCreateNestedManyWithoutNetworkInput = {
    create?: XOR<AdsViewsCreateWithoutNetworkInput, AdsViewsUncheckedCreateWithoutNetworkInput> | AdsViewsCreateWithoutNetworkInput[] | AdsViewsUncheckedCreateWithoutNetworkInput[]
    connectOrCreate?: AdsViewsCreateOrConnectWithoutNetworkInput | AdsViewsCreateOrConnectWithoutNetworkInput[]
    createMany?: AdsViewsCreateManyNetworkInputEnvelope
    connect?: AdsViewsWhereUniqueInput | AdsViewsWhereUniqueInput[]
  }

  export type AdsViewsUncheckedCreateNestedManyWithoutNetworkInput = {
    create?: XOR<AdsViewsCreateWithoutNetworkInput, AdsViewsUncheckedCreateWithoutNetworkInput> | AdsViewsCreateWithoutNetworkInput[] | AdsViewsUncheckedCreateWithoutNetworkInput[]
    connectOrCreate?: AdsViewsCreateOrConnectWithoutNetworkInput | AdsViewsCreateOrConnectWithoutNetworkInput[]
    createMany?: AdsViewsCreateManyNetworkInputEnvelope
    connect?: AdsViewsWhereUniqueInput | AdsViewsWhereUniqueInput[]
  }

  export type AdsViewsUpdateManyWithoutNetworkNestedInput = {
    create?: XOR<AdsViewsCreateWithoutNetworkInput, AdsViewsUncheckedCreateWithoutNetworkInput> | AdsViewsCreateWithoutNetworkInput[] | AdsViewsUncheckedCreateWithoutNetworkInput[]
    connectOrCreate?: AdsViewsCreateOrConnectWithoutNetworkInput | AdsViewsCreateOrConnectWithoutNetworkInput[]
    upsert?: AdsViewsUpsertWithWhereUniqueWithoutNetworkInput | AdsViewsUpsertWithWhereUniqueWithoutNetworkInput[]
    createMany?: AdsViewsCreateManyNetworkInputEnvelope
    set?: AdsViewsWhereUniqueInput | AdsViewsWhereUniqueInput[]
    disconnect?: AdsViewsWhereUniqueInput | AdsViewsWhereUniqueInput[]
    delete?: AdsViewsWhereUniqueInput | AdsViewsWhereUniqueInput[]
    connect?: AdsViewsWhereUniqueInput | AdsViewsWhereUniqueInput[]
    update?: AdsViewsUpdateWithWhereUniqueWithoutNetworkInput | AdsViewsUpdateWithWhereUniqueWithoutNetworkInput[]
    updateMany?: AdsViewsUpdateManyWithWhereWithoutNetworkInput | AdsViewsUpdateManyWithWhereWithoutNetworkInput[]
    deleteMany?: AdsViewsScalarWhereInput | AdsViewsScalarWhereInput[]
  }

  export type AdsViewsUncheckedUpdateManyWithoutNetworkNestedInput = {
    create?: XOR<AdsViewsCreateWithoutNetworkInput, AdsViewsUncheckedCreateWithoutNetworkInput> | AdsViewsCreateWithoutNetworkInput[] | AdsViewsUncheckedCreateWithoutNetworkInput[]
    connectOrCreate?: AdsViewsCreateOrConnectWithoutNetworkInput | AdsViewsCreateOrConnectWithoutNetworkInput[]
    upsert?: AdsViewsUpsertWithWhereUniqueWithoutNetworkInput | AdsViewsUpsertWithWhereUniqueWithoutNetworkInput[]
    createMany?: AdsViewsCreateManyNetworkInputEnvelope
    set?: AdsViewsWhereUniqueInput | AdsViewsWhereUniqueInput[]
    disconnect?: AdsViewsWhereUniqueInput | AdsViewsWhereUniqueInput[]
    delete?: AdsViewsWhereUniqueInput | AdsViewsWhereUniqueInput[]
    connect?: AdsViewsWhereUniqueInput | AdsViewsWhereUniqueInput[]
    update?: AdsViewsUpdateWithWhereUniqueWithoutNetworkInput | AdsViewsUpdateWithWhereUniqueWithoutNetworkInput[]
    updateMany?: AdsViewsUpdateManyWithWhereWithoutNetworkInput | AdsViewsUpdateManyWithWhereWithoutNetworkInput[]
    deleteMany?: AdsViewsScalarWhereInput | AdsViewsScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutBalanceInput = {
    create?: XOR<UsersCreateWithoutBalanceInput, UsersUncheckedCreateWithoutBalanceInput>
    connectOrCreate?: UsersCreateOrConnectWithoutBalanceInput
    connect?: UsersWhereUniqueInput
  }

  export type TransactionsCreateNestedManyWithoutBalanceInput = {
    create?: XOR<TransactionsCreateWithoutBalanceInput, TransactionsUncheckedCreateWithoutBalanceInput> | TransactionsCreateWithoutBalanceInput[] | TransactionsUncheckedCreateWithoutBalanceInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutBalanceInput | TransactionsCreateOrConnectWithoutBalanceInput[]
    createMany?: TransactionsCreateManyBalanceInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type UsersUncheckedCreateNestedOneWithoutBalanceInput = {
    create?: XOR<UsersCreateWithoutBalanceInput, UsersUncheckedCreateWithoutBalanceInput>
    connectOrCreate?: UsersCreateOrConnectWithoutBalanceInput
    connect?: UsersWhereUniqueInput
  }

  export type TransactionsUncheckedCreateNestedManyWithoutBalanceInput = {
    create?: XOR<TransactionsCreateWithoutBalanceInput, TransactionsUncheckedCreateWithoutBalanceInput> | TransactionsCreateWithoutBalanceInput[] | TransactionsUncheckedCreateWithoutBalanceInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutBalanceInput | TransactionsCreateOrConnectWithoutBalanceInput[]
    createMany?: TransactionsCreateManyBalanceInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type UsersUpdateOneWithoutBalanceNestedInput = {
    create?: XOR<UsersCreateWithoutBalanceInput, UsersUncheckedCreateWithoutBalanceInput>
    connectOrCreate?: UsersCreateOrConnectWithoutBalanceInput
    upsert?: UsersUpsertWithoutBalanceInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutBalanceInput, UsersUpdateWithoutBalanceInput>, UsersUncheckedUpdateWithoutBalanceInput>
  }

  export type TransactionsUpdateManyWithoutBalanceNestedInput = {
    create?: XOR<TransactionsCreateWithoutBalanceInput, TransactionsUncheckedCreateWithoutBalanceInput> | TransactionsCreateWithoutBalanceInput[] | TransactionsUncheckedCreateWithoutBalanceInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutBalanceInput | TransactionsCreateOrConnectWithoutBalanceInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutBalanceInput | TransactionsUpsertWithWhereUniqueWithoutBalanceInput[]
    createMany?: TransactionsCreateManyBalanceInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutBalanceInput | TransactionsUpdateWithWhereUniqueWithoutBalanceInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutBalanceInput | TransactionsUpdateManyWithWhereWithoutBalanceInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type UsersUncheckedUpdateOneWithoutBalanceNestedInput = {
    create?: XOR<UsersCreateWithoutBalanceInput, UsersUncheckedCreateWithoutBalanceInput>
    connectOrCreate?: UsersCreateOrConnectWithoutBalanceInput
    upsert?: UsersUpsertWithoutBalanceInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutBalanceInput, UsersUpdateWithoutBalanceInput>, UsersUncheckedUpdateWithoutBalanceInput>
  }

  export type TransactionsUncheckedUpdateManyWithoutBalanceNestedInput = {
    create?: XOR<TransactionsCreateWithoutBalanceInput, TransactionsUncheckedCreateWithoutBalanceInput> | TransactionsCreateWithoutBalanceInput[] | TransactionsUncheckedCreateWithoutBalanceInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutBalanceInput | TransactionsCreateOrConnectWithoutBalanceInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutBalanceInput | TransactionsUpsertWithWhereUniqueWithoutBalanceInput[]
    createMany?: TransactionsCreateManyBalanceInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutBalanceInput | TransactionsUpdateWithWhereUniqueWithoutBalanceInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutBalanceInput | TransactionsUpdateManyWithWhereWithoutBalanceInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<UsersCreateWithoutSubscriptionsInput, UsersUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutSubscriptionsInput
    connect?: UsersWhereUniqueInput
  }

  export type PaymentsCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PaymentsCreateWithoutSubscriptionInput, PaymentsUncheckedCreateWithoutSubscriptionInput> | PaymentsCreateWithoutSubscriptionInput[] | PaymentsUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutSubscriptionInput | PaymentsCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PaymentsCreateManySubscriptionInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type PaymentsUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PaymentsCreateWithoutSubscriptionInput, PaymentsUncheckedCreateWithoutSubscriptionInput> | PaymentsCreateWithoutSubscriptionInput[] | PaymentsUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutSubscriptionInput | PaymentsCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PaymentsCreateManySubscriptionInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type EnumSubscriptionPeriodEnumFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionPeriodEnum
  }

  export type UsersUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<UsersCreateWithoutSubscriptionsInput, UsersUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutSubscriptionsInput
    upsert?: UsersUpsertWithoutSubscriptionsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutSubscriptionsInput, UsersUpdateWithoutSubscriptionsInput>, UsersUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type PaymentsUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PaymentsCreateWithoutSubscriptionInput, PaymentsUncheckedCreateWithoutSubscriptionInput> | PaymentsCreateWithoutSubscriptionInput[] | PaymentsUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutSubscriptionInput | PaymentsCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutSubscriptionInput | PaymentsUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PaymentsCreateManySubscriptionInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutSubscriptionInput | PaymentsUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutSubscriptionInput | PaymentsUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type PaymentsUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PaymentsCreateWithoutSubscriptionInput, PaymentsUncheckedCreateWithoutSubscriptionInput> | PaymentsCreateWithoutSubscriptionInput[] | PaymentsUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutSubscriptionInput | PaymentsCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutSubscriptionInput | PaymentsUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PaymentsCreateManySubscriptionInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutSubscriptionInput | PaymentsUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutSubscriptionInput | PaymentsUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type UsersCreateNestedManyWithoutRoleInput = {
    create?: XOR<UsersCreateWithoutRoleInput, UsersUncheckedCreateWithoutRoleInput> | UsersCreateWithoutRoleInput[] | UsersUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutRoleInput | UsersCreateOrConnectWithoutRoleInput[]
    createMany?: UsersCreateManyRoleInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type UsersUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UsersCreateWithoutRoleInput, UsersUncheckedCreateWithoutRoleInput> | UsersCreateWithoutRoleInput[] | UsersUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutRoleInput | UsersCreateOrConnectWithoutRoleInput[]
    createMany?: UsersCreateManyRoleInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type UsersUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UsersCreateWithoutRoleInput, UsersUncheckedCreateWithoutRoleInput> | UsersCreateWithoutRoleInput[] | UsersUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutRoleInput | UsersCreateOrConnectWithoutRoleInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutRoleInput | UsersUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UsersCreateManyRoleInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutRoleInput | UsersUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutRoleInput | UsersUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type UsersUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UsersCreateWithoutRoleInput, UsersUncheckedCreateWithoutRoleInput> | UsersCreateWithoutRoleInput[] | UsersUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutRoleInput | UsersCreateOrConnectWithoutRoleInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutRoleInput | UsersUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UsersCreateManyRoleInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutRoleInput | UsersUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutRoleInput | UsersUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type UsersCreateNestedManyWithoutLanguageInput = {
    create?: XOR<UsersCreateWithoutLanguageInput, UsersUncheckedCreateWithoutLanguageInput> | UsersCreateWithoutLanguageInput[] | UsersUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutLanguageInput | UsersCreateOrConnectWithoutLanguageInput[]
    createMany?: UsersCreateManyLanguageInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type UsersUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<UsersCreateWithoutLanguageInput, UsersUncheckedCreateWithoutLanguageInput> | UsersCreateWithoutLanguageInput[] | UsersUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutLanguageInput | UsersCreateOrConnectWithoutLanguageInput[]
    createMany?: UsersCreateManyLanguageInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type UsersUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<UsersCreateWithoutLanguageInput, UsersUncheckedCreateWithoutLanguageInput> | UsersCreateWithoutLanguageInput[] | UsersUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutLanguageInput | UsersCreateOrConnectWithoutLanguageInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutLanguageInput | UsersUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: UsersCreateManyLanguageInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutLanguageInput | UsersUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutLanguageInput | UsersUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type UsersUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<UsersCreateWithoutLanguageInput, UsersUncheckedCreateWithoutLanguageInput> | UsersCreateWithoutLanguageInput[] | UsersUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutLanguageInput | UsersCreateOrConnectWithoutLanguageInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutLanguageInput | UsersUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: UsersCreateManyLanguageInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutLanguageInput | UsersUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutLanguageInput | UsersUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type PaymentsCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<PaymentsCreateWithoutCurrencyInput, PaymentsUncheckedCreateWithoutCurrencyInput> | PaymentsCreateWithoutCurrencyInput[] | PaymentsUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutCurrencyInput | PaymentsCreateOrConnectWithoutCurrencyInput[]
    createMany?: PaymentsCreateManyCurrencyInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type PaymentMethodsCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<PaymentMethodsCreateWithoutCurrencyInput, PaymentMethodsUncheckedCreateWithoutCurrencyInput> | PaymentMethodsCreateWithoutCurrencyInput[] | PaymentMethodsUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: PaymentMethodsCreateOrConnectWithoutCurrencyInput | PaymentMethodsCreateOrConnectWithoutCurrencyInput[]
    createMany?: PaymentMethodsCreateManyCurrencyInputEnvelope
    connect?: PaymentMethodsWhereUniqueInput | PaymentMethodsWhereUniqueInput[]
  }

  export type PaymentsUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<PaymentsCreateWithoutCurrencyInput, PaymentsUncheckedCreateWithoutCurrencyInput> | PaymentsCreateWithoutCurrencyInput[] | PaymentsUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutCurrencyInput | PaymentsCreateOrConnectWithoutCurrencyInput[]
    createMany?: PaymentsCreateManyCurrencyInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type PaymentMethodsUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<PaymentMethodsCreateWithoutCurrencyInput, PaymentMethodsUncheckedCreateWithoutCurrencyInput> | PaymentMethodsCreateWithoutCurrencyInput[] | PaymentMethodsUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: PaymentMethodsCreateOrConnectWithoutCurrencyInput | PaymentMethodsCreateOrConnectWithoutCurrencyInput[]
    createMany?: PaymentMethodsCreateManyCurrencyInputEnvelope
    connect?: PaymentMethodsWhereUniqueInput | PaymentMethodsWhereUniqueInput[]
  }

  export type EnumCurrencyEnumFieldUpdateOperationsInput = {
    set?: $Enums.CurrencyEnum
  }

  export type PaymentsUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<PaymentsCreateWithoutCurrencyInput, PaymentsUncheckedCreateWithoutCurrencyInput> | PaymentsCreateWithoutCurrencyInput[] | PaymentsUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutCurrencyInput | PaymentsCreateOrConnectWithoutCurrencyInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutCurrencyInput | PaymentsUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: PaymentsCreateManyCurrencyInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutCurrencyInput | PaymentsUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutCurrencyInput | PaymentsUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type PaymentMethodsUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<PaymentMethodsCreateWithoutCurrencyInput, PaymentMethodsUncheckedCreateWithoutCurrencyInput> | PaymentMethodsCreateWithoutCurrencyInput[] | PaymentMethodsUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: PaymentMethodsCreateOrConnectWithoutCurrencyInput | PaymentMethodsCreateOrConnectWithoutCurrencyInput[]
    upsert?: PaymentMethodsUpsertWithWhereUniqueWithoutCurrencyInput | PaymentMethodsUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: PaymentMethodsCreateManyCurrencyInputEnvelope
    set?: PaymentMethodsWhereUniqueInput | PaymentMethodsWhereUniqueInput[]
    disconnect?: PaymentMethodsWhereUniqueInput | PaymentMethodsWhereUniqueInput[]
    delete?: PaymentMethodsWhereUniqueInput | PaymentMethodsWhereUniqueInput[]
    connect?: PaymentMethodsWhereUniqueInput | PaymentMethodsWhereUniqueInput[]
    update?: PaymentMethodsUpdateWithWhereUniqueWithoutCurrencyInput | PaymentMethodsUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: PaymentMethodsUpdateManyWithWhereWithoutCurrencyInput | PaymentMethodsUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: PaymentMethodsScalarWhereInput | PaymentMethodsScalarWhereInput[]
  }

  export type PaymentsUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<PaymentsCreateWithoutCurrencyInput, PaymentsUncheckedCreateWithoutCurrencyInput> | PaymentsCreateWithoutCurrencyInput[] | PaymentsUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutCurrencyInput | PaymentsCreateOrConnectWithoutCurrencyInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutCurrencyInput | PaymentsUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: PaymentsCreateManyCurrencyInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutCurrencyInput | PaymentsUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutCurrencyInput | PaymentsUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type PaymentMethodsUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<PaymentMethodsCreateWithoutCurrencyInput, PaymentMethodsUncheckedCreateWithoutCurrencyInput> | PaymentMethodsCreateWithoutCurrencyInput[] | PaymentMethodsUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: PaymentMethodsCreateOrConnectWithoutCurrencyInput | PaymentMethodsCreateOrConnectWithoutCurrencyInput[]
    upsert?: PaymentMethodsUpsertWithWhereUniqueWithoutCurrencyInput | PaymentMethodsUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: PaymentMethodsCreateManyCurrencyInputEnvelope
    set?: PaymentMethodsWhereUniqueInput | PaymentMethodsWhereUniqueInput[]
    disconnect?: PaymentMethodsWhereUniqueInput | PaymentMethodsWhereUniqueInput[]
    delete?: PaymentMethodsWhereUniqueInput | PaymentMethodsWhereUniqueInput[]
    connect?: PaymentMethodsWhereUniqueInput | PaymentMethodsWhereUniqueInput[]
    update?: PaymentMethodsUpdateWithWhereUniqueWithoutCurrencyInput | PaymentMethodsUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: PaymentMethodsUpdateManyWithWhereWithoutCurrencyInput | PaymentMethodsUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: PaymentMethodsScalarWhereInput | PaymentMethodsScalarWhereInput[]
  }

  export type UserBalanceCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserBalanceCreateWithoutTransactionsInput, UserBalanceUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserBalanceCreateOrConnectWithoutTransactionsInput
    connect?: UserBalanceWhereUniqueInput
  }

  export type WithdrawalsCreateNestedOneWithoutTransacrionInput = {
    create?: XOR<WithdrawalsCreateWithoutTransacrionInput, WithdrawalsUncheckedCreateWithoutTransacrionInput>
    connectOrCreate?: WithdrawalsCreateOrConnectWithoutTransacrionInput
    connect?: WithdrawalsWhereUniqueInput
  }

  export type PaymentsCreateNestedOneWithoutTransacrionInput = {
    create?: XOR<PaymentsCreateWithoutTransacrionInput, PaymentsUncheckedCreateWithoutTransacrionInput>
    connectOrCreate?: PaymentsCreateOrConnectWithoutTransacrionInput
    connect?: PaymentsWhereUniqueInput
  }

  export type WithdrawalsUncheckedCreateNestedOneWithoutTransacrionInput = {
    create?: XOR<WithdrawalsCreateWithoutTransacrionInput, WithdrawalsUncheckedCreateWithoutTransacrionInput>
    connectOrCreate?: WithdrawalsCreateOrConnectWithoutTransacrionInput
    connect?: WithdrawalsWhereUniqueInput
  }

  export type PaymentsUncheckedCreateNestedOneWithoutTransacrionInput = {
    create?: XOR<PaymentsCreateWithoutTransacrionInput, PaymentsUncheckedCreateWithoutTransacrionInput>
    connectOrCreate?: PaymentsCreateOrConnectWithoutTransacrionInput
    connect?: PaymentsWhereUniqueInput
  }

  export type EnumTransactionTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.TransactionTypeEnum
  }

  export type EnumTransactionReasonEnumFieldUpdateOperationsInput = {
    set?: $Enums.TransactionReasonEnum
  }

  export type EnumBalanceTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.BalanceTypeEnum
  }

  export type UserBalanceUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserBalanceCreateWithoutTransactionsInput, UserBalanceUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserBalanceCreateOrConnectWithoutTransactionsInput
    upsert?: UserBalanceUpsertWithoutTransactionsInput
    connect?: UserBalanceWhereUniqueInput
    update?: XOR<XOR<UserBalanceUpdateToOneWithWhereWithoutTransactionsInput, UserBalanceUpdateWithoutTransactionsInput>, UserBalanceUncheckedUpdateWithoutTransactionsInput>
  }

  export type WithdrawalsUpdateOneWithoutTransacrionNestedInput = {
    create?: XOR<WithdrawalsCreateWithoutTransacrionInput, WithdrawalsUncheckedCreateWithoutTransacrionInput>
    connectOrCreate?: WithdrawalsCreateOrConnectWithoutTransacrionInput
    upsert?: WithdrawalsUpsertWithoutTransacrionInput
    disconnect?: WithdrawalsWhereInput | boolean
    delete?: WithdrawalsWhereInput | boolean
    connect?: WithdrawalsWhereUniqueInput
    update?: XOR<XOR<WithdrawalsUpdateToOneWithWhereWithoutTransacrionInput, WithdrawalsUpdateWithoutTransacrionInput>, WithdrawalsUncheckedUpdateWithoutTransacrionInput>
  }

  export type PaymentsUpdateOneWithoutTransacrionNestedInput = {
    create?: XOR<PaymentsCreateWithoutTransacrionInput, PaymentsUncheckedCreateWithoutTransacrionInput>
    connectOrCreate?: PaymentsCreateOrConnectWithoutTransacrionInput
    upsert?: PaymentsUpsertWithoutTransacrionInput
    disconnect?: PaymentsWhereInput | boolean
    delete?: PaymentsWhereInput | boolean
    connect?: PaymentsWhereUniqueInput
    update?: XOR<XOR<PaymentsUpdateToOneWithWhereWithoutTransacrionInput, PaymentsUpdateWithoutTransacrionInput>, PaymentsUncheckedUpdateWithoutTransacrionInput>
  }

  export type WithdrawalsUncheckedUpdateOneWithoutTransacrionNestedInput = {
    create?: XOR<WithdrawalsCreateWithoutTransacrionInput, WithdrawalsUncheckedCreateWithoutTransacrionInput>
    connectOrCreate?: WithdrawalsCreateOrConnectWithoutTransacrionInput
    upsert?: WithdrawalsUpsertWithoutTransacrionInput
    disconnect?: WithdrawalsWhereInput | boolean
    delete?: WithdrawalsWhereInput | boolean
    connect?: WithdrawalsWhereUniqueInput
    update?: XOR<XOR<WithdrawalsUpdateToOneWithWhereWithoutTransacrionInput, WithdrawalsUpdateWithoutTransacrionInput>, WithdrawalsUncheckedUpdateWithoutTransacrionInput>
  }

  export type PaymentsUncheckedUpdateOneWithoutTransacrionNestedInput = {
    create?: XOR<PaymentsCreateWithoutTransacrionInput, PaymentsUncheckedCreateWithoutTransacrionInput>
    connectOrCreate?: PaymentsCreateOrConnectWithoutTransacrionInput
    upsert?: PaymentsUpsertWithoutTransacrionInput
    disconnect?: PaymentsWhereInput | boolean
    delete?: PaymentsWhereInput | boolean
    connect?: PaymentsWhereUniqueInput
    update?: XOR<XOR<PaymentsUpdateToOneWithWhereWithoutTransacrionInput, PaymentsUpdateWithoutTransacrionInput>, PaymentsUncheckedUpdateWithoutTransacrionInput>
  }

  export type UsersCreateNestedOneWithoutWithdrawalsInput = {
    create?: XOR<UsersCreateWithoutWithdrawalsInput, UsersUncheckedCreateWithoutWithdrawalsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutWithdrawalsInput
    connect?: UsersWhereUniqueInput
  }

  export type TransactionsCreateNestedOneWithoutWithdrawalInput = {
    create?: XOR<TransactionsCreateWithoutWithdrawalInput, TransactionsUncheckedCreateWithoutWithdrawalInput>
    connectOrCreate?: TransactionsCreateOrConnectWithoutWithdrawalInput
    connect?: TransactionsWhereUniqueInput
  }

  export type EnumWithdrawalStatusEnumFieldUpdateOperationsInput = {
    set?: $Enums.WithdrawalStatusEnum
  }

  export type UsersUpdateOneRequiredWithoutWithdrawalsNestedInput = {
    create?: XOR<UsersCreateWithoutWithdrawalsInput, UsersUncheckedCreateWithoutWithdrawalsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutWithdrawalsInput
    upsert?: UsersUpsertWithoutWithdrawalsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutWithdrawalsInput, UsersUpdateWithoutWithdrawalsInput>, UsersUncheckedUpdateWithoutWithdrawalsInput>
  }

  export type TransactionsUpdateOneRequiredWithoutWithdrawalNestedInput = {
    create?: XOR<TransactionsCreateWithoutWithdrawalInput, TransactionsUncheckedCreateWithoutWithdrawalInput>
    connectOrCreate?: TransactionsCreateOrConnectWithoutWithdrawalInput
    upsert?: TransactionsUpsertWithoutWithdrawalInput
    connect?: TransactionsWhereUniqueInput
    update?: XOR<XOR<TransactionsUpdateToOneWithWhereWithoutWithdrawalInput, TransactionsUpdateWithoutWithdrawalInput>, TransactionsUncheckedUpdateWithoutWithdrawalInput>
  }

  export type UsersCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UsersCreateWithoutPaymentsInput, UsersUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPaymentsInput
    connect?: UsersWhereUniqueInput
  }

  export type CurrencyCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<CurrencyCreateWithoutPaymentsInput, CurrencyUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutPaymentsInput
    connect?: CurrencyWhereUniqueInput
  }

  export type SubscriptionsCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<SubscriptionsCreateWithoutPaymentsInput, SubscriptionsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutPaymentsInput
    connect?: SubscriptionsWhereUniqueInput
  }

  export type PaymentMethodsCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<PaymentMethodsCreateWithoutPaymentsInput, PaymentMethodsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PaymentMethodsCreateOrConnectWithoutPaymentsInput
    connect?: PaymentMethodsWhereUniqueInput
  }

  export type TransactionsCreateNestedOneWithoutPaymentInput = {
    create?: XOR<TransactionsCreateWithoutPaymentInput, TransactionsUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: TransactionsCreateOrConnectWithoutPaymentInput
    connect?: TransactionsWhereUniqueInput
  }

  export type EnumPaymentStatusEnumFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatusEnum
  }

  export type UsersUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UsersCreateWithoutPaymentsInput, UsersUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPaymentsInput
    upsert?: UsersUpsertWithoutPaymentsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutPaymentsInput, UsersUpdateWithoutPaymentsInput>, UsersUncheckedUpdateWithoutPaymentsInput>
  }

  export type CurrencyUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<CurrencyCreateWithoutPaymentsInput, CurrencyUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutPaymentsInput
    upsert?: CurrencyUpsertWithoutPaymentsInput
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutPaymentsInput, CurrencyUpdateWithoutPaymentsInput>, CurrencyUncheckedUpdateWithoutPaymentsInput>
  }

  export type SubscriptionsUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<SubscriptionsCreateWithoutPaymentsInput, SubscriptionsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutPaymentsInput
    upsert?: SubscriptionsUpsertWithoutPaymentsInput
    disconnect?: SubscriptionsWhereInput | boolean
    delete?: SubscriptionsWhereInput | boolean
    connect?: SubscriptionsWhereUniqueInput
    update?: XOR<XOR<SubscriptionsUpdateToOneWithWhereWithoutPaymentsInput, SubscriptionsUpdateWithoutPaymentsInput>, SubscriptionsUncheckedUpdateWithoutPaymentsInput>
  }

  export type PaymentMethodsUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<PaymentMethodsCreateWithoutPaymentsInput, PaymentMethodsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PaymentMethodsCreateOrConnectWithoutPaymentsInput
    upsert?: PaymentMethodsUpsertWithoutPaymentsInput
    connect?: PaymentMethodsWhereUniqueInput
    update?: XOR<XOR<PaymentMethodsUpdateToOneWithWhereWithoutPaymentsInput, PaymentMethodsUpdateWithoutPaymentsInput>, PaymentMethodsUncheckedUpdateWithoutPaymentsInput>
  }

  export type TransactionsUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<TransactionsCreateWithoutPaymentInput, TransactionsUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: TransactionsCreateOrConnectWithoutPaymentInput
    upsert?: TransactionsUpsertWithoutPaymentInput
    disconnect?: TransactionsWhereInput | boolean
    delete?: TransactionsWhereInput | boolean
    connect?: TransactionsWhereUniqueInput
    update?: XOR<XOR<TransactionsUpdateToOneWithWhereWithoutPaymentInput, TransactionsUpdateWithoutPaymentInput>, TransactionsUncheckedUpdateWithoutPaymentInput>
  }

  export type EnumPaymentMethodEnumFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethodEnum
  }

  export type PaymentsCreateNestedManyWithoutMethodInput = {
    create?: XOR<PaymentsCreateWithoutMethodInput, PaymentsUncheckedCreateWithoutMethodInput> | PaymentsCreateWithoutMethodInput[] | PaymentsUncheckedCreateWithoutMethodInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutMethodInput | PaymentsCreateOrConnectWithoutMethodInput[]
    createMany?: PaymentsCreateManyMethodInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type CurrencyCreateNestedOneWithoutPaymentMethodsInput = {
    create?: XOR<CurrencyCreateWithoutPaymentMethodsInput, CurrencyUncheckedCreateWithoutPaymentMethodsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutPaymentMethodsInput
    connect?: CurrencyWhereUniqueInput
  }

  export type PaymentsUncheckedCreateNestedManyWithoutMethodInput = {
    create?: XOR<PaymentsCreateWithoutMethodInput, PaymentsUncheckedCreateWithoutMethodInput> | PaymentsCreateWithoutMethodInput[] | PaymentsUncheckedCreateWithoutMethodInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutMethodInput | PaymentsCreateOrConnectWithoutMethodInput[]
    createMany?: PaymentsCreateManyMethodInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type EnumPaymentMethodTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethodTypeEnum
  }

  export type EnumPaymentSystemEnumFieldUpdateOperationsInput = {
    set?: $Enums.PaymentSystemEnum
  }

  export type PaymentsUpdateManyWithoutMethodNestedInput = {
    create?: XOR<PaymentsCreateWithoutMethodInput, PaymentsUncheckedCreateWithoutMethodInput> | PaymentsCreateWithoutMethodInput[] | PaymentsUncheckedCreateWithoutMethodInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutMethodInput | PaymentsCreateOrConnectWithoutMethodInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutMethodInput | PaymentsUpsertWithWhereUniqueWithoutMethodInput[]
    createMany?: PaymentsCreateManyMethodInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutMethodInput | PaymentsUpdateWithWhereUniqueWithoutMethodInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutMethodInput | PaymentsUpdateManyWithWhereWithoutMethodInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type CurrencyUpdateOneRequiredWithoutPaymentMethodsNestedInput = {
    create?: XOR<CurrencyCreateWithoutPaymentMethodsInput, CurrencyUncheckedCreateWithoutPaymentMethodsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutPaymentMethodsInput
    upsert?: CurrencyUpsertWithoutPaymentMethodsInput
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutPaymentMethodsInput, CurrencyUpdateWithoutPaymentMethodsInput>, CurrencyUncheckedUpdateWithoutPaymentMethodsInput>
  }

  export type PaymentsUncheckedUpdateManyWithoutMethodNestedInput = {
    create?: XOR<PaymentsCreateWithoutMethodInput, PaymentsUncheckedCreateWithoutMethodInput> | PaymentsCreateWithoutMethodInput[] | PaymentsUncheckedCreateWithoutMethodInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutMethodInput | PaymentsCreateOrConnectWithoutMethodInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutMethodInput | PaymentsUpsertWithWhereUniqueWithoutMethodInput[]
    createMany?: PaymentsCreateManyMethodInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutMethodInput | PaymentsUpdateWithWhereUniqueWithoutMethodInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutMethodInput | PaymentsUpdateManyWithWhereWithoutMethodInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type NestedEnumDefaultEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.DefaultEnum | EnumDefaultEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DefaultEnum[] | ListEnumDefaultEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefaultEnum[] | ListEnumDefaultEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDefaultEnumFilter<$PrismaModel> | $Enums.DefaultEnum
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumDefaultEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DefaultEnum | EnumDefaultEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DefaultEnum[] | ListEnumDefaultEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefaultEnum[] | ListEnumDefaultEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDefaultEnumWithAggregatesFilter<$PrismaModel> | $Enums.DefaultEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDefaultEnumFilter<$PrismaModel>
    _max?: NestedEnumDefaultEnumFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserRoleEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRoleEnum | EnumUserRoleEnumFieldRefInput<$PrismaModel>
    in?: $Enums.UserRoleEnum[] | ListEnumUserRoleEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRoleEnum[] | ListEnumUserRoleEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleEnumFilter<$PrismaModel> | $Enums.UserRoleEnum
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRoleEnum | EnumUserRoleEnumFieldRefInput<$PrismaModel>
    in?: $Enums.UserRoleEnum[] | ListEnumUserRoleEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRoleEnum[] | ListEnumUserRoleEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleEnumWithAggregatesFilter<$PrismaModel> | $Enums.UserRoleEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleEnumFilter<$PrismaModel>
    _max?: NestedEnumUserRoleEnumFilter<$PrismaModel>
  }

  export type NestedEnumAdsNetworkEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.AdsNetworkEnum | EnumAdsNetworkEnumFieldRefInput<$PrismaModel>
    in?: $Enums.AdsNetworkEnum[] | ListEnumAdsNetworkEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdsNetworkEnum[] | ListEnumAdsNetworkEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumAdsNetworkEnumFilter<$PrismaModel> | $Enums.AdsNetworkEnum
  }

  export type NestedEnumAdsViewTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.AdsViewTypeEnum | EnumAdsViewTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.AdsViewTypeEnum[] | ListEnumAdsViewTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdsViewTypeEnum[] | ListEnumAdsViewTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumAdsViewTypeEnumFilter<$PrismaModel> | $Enums.AdsViewTypeEnum
  }

  export type NestedEnumAdsNetworkEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdsNetworkEnum | EnumAdsNetworkEnumFieldRefInput<$PrismaModel>
    in?: $Enums.AdsNetworkEnum[] | ListEnumAdsNetworkEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdsNetworkEnum[] | ListEnumAdsNetworkEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumAdsNetworkEnumWithAggregatesFilter<$PrismaModel> | $Enums.AdsNetworkEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdsNetworkEnumFilter<$PrismaModel>
    _max?: NestedEnumAdsNetworkEnumFilter<$PrismaModel>
  }

  export type NestedEnumAdsViewTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdsViewTypeEnum | EnumAdsViewTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.AdsViewTypeEnum[] | ListEnumAdsViewTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdsViewTypeEnum[] | ListEnumAdsViewTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumAdsViewTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.AdsViewTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdsViewTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumAdsViewTypeEnumFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionPeriodEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPeriodEnum | EnumSubscriptionPeriodEnumFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPeriodEnum[] | ListEnumSubscriptionPeriodEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPeriodEnum[] | ListEnumSubscriptionPeriodEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPeriodEnumFilter<$PrismaModel> | $Enums.SubscriptionPeriodEnum
  }

  export type NestedEnumSubscriptionPeriodEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPeriodEnum | EnumSubscriptionPeriodEnumFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPeriodEnum[] | ListEnumSubscriptionPeriodEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPeriodEnum[] | ListEnumSubscriptionPeriodEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPeriodEnumWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPeriodEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPeriodEnumFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPeriodEnumFilter<$PrismaModel>
  }

  export type NestedEnumCurrencyEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyEnum | EnumCurrencyEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyEnum[] | ListEnumCurrencyEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyEnum[] | ListEnumCurrencyEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyEnumFilter<$PrismaModel> | $Enums.CurrencyEnum
  }

  export type NestedEnumCurrencyEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyEnum | EnumCurrencyEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyEnum[] | ListEnumCurrencyEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyEnum[] | ListEnumCurrencyEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyEnumWithAggregatesFilter<$PrismaModel> | $Enums.CurrencyEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCurrencyEnumFilter<$PrismaModel>
    _max?: NestedEnumCurrencyEnumFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionTypeEnum | EnumTransactionTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionTypeEnum[] | ListEnumTransactionTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionTypeEnum[] | ListEnumTransactionTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeEnumFilter<$PrismaModel> | $Enums.TransactionTypeEnum
  }

  export type NestedEnumTransactionReasonEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionReasonEnum | EnumTransactionReasonEnumFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionReasonEnum[] | ListEnumTransactionReasonEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionReasonEnum[] | ListEnumTransactionReasonEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionReasonEnumFilter<$PrismaModel> | $Enums.TransactionReasonEnum
  }

  export type NestedEnumBalanceTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.BalanceTypeEnum | EnumBalanceTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.BalanceTypeEnum[] | ListEnumBalanceTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.BalanceTypeEnum[] | ListEnumBalanceTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumBalanceTypeEnumFilter<$PrismaModel> | $Enums.BalanceTypeEnum
  }

  export type NestedEnumTransactionTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionTypeEnum | EnumTransactionTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionTypeEnum[] | ListEnumTransactionTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionTypeEnum[] | ListEnumTransactionTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.TransactionTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeEnumFilter<$PrismaModel>
  }

  export type NestedEnumTransactionReasonEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionReasonEnum | EnumTransactionReasonEnumFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionReasonEnum[] | ListEnumTransactionReasonEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionReasonEnum[] | ListEnumTransactionReasonEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionReasonEnumWithAggregatesFilter<$PrismaModel> | $Enums.TransactionReasonEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionReasonEnumFilter<$PrismaModel>
    _max?: NestedEnumTransactionReasonEnumFilter<$PrismaModel>
  }

  export type NestedEnumBalanceTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BalanceTypeEnum | EnumBalanceTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.BalanceTypeEnum[] | ListEnumBalanceTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.BalanceTypeEnum[] | ListEnumBalanceTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumBalanceTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.BalanceTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBalanceTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumBalanceTypeEnumFilter<$PrismaModel>
  }

  export type NestedEnumWithdrawalStatusEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.WithdrawalStatusEnum | EnumWithdrawalStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.WithdrawalStatusEnum[] | ListEnumWithdrawalStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.WithdrawalStatusEnum[] | ListEnumWithdrawalStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumWithdrawalStatusEnumFilter<$PrismaModel> | $Enums.WithdrawalStatusEnum
  }

  export type NestedEnumWithdrawalStatusEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WithdrawalStatusEnum | EnumWithdrawalStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.WithdrawalStatusEnum[] | ListEnumWithdrawalStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.WithdrawalStatusEnum[] | ListEnumWithdrawalStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumWithdrawalStatusEnumWithAggregatesFilter<$PrismaModel> | $Enums.WithdrawalStatusEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWithdrawalStatusEnumFilter<$PrismaModel>
    _max?: NestedEnumWithdrawalStatusEnumFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatusEnum | EnumPaymentStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatusEnum[] | ListEnumPaymentStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatusEnum[] | ListEnumPaymentStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusEnumFilter<$PrismaModel> | $Enums.PaymentStatusEnum
  }

  export type NestedEnumPaymentMethodEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodEnum | EnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodEnum[] | ListEnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethodEnum[] | ListEnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodEnumFilter<$PrismaModel> | $Enums.PaymentMethodEnum
  }

  export type NestedEnumPaymentStatusEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatusEnum | EnumPaymentStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatusEnum[] | ListEnumPaymentStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatusEnum[] | ListEnumPaymentStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusEnumWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatusEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusEnumFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusEnumFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumPaymentMethodEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodEnum | EnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodEnum[] | ListEnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethodEnum[] | ListEnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodEnumWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethodEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodEnumFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodEnumFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodTypeEnum | EnumPaymentMethodTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodTypeEnum[] | ListEnumPaymentMethodTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethodTypeEnum[] | ListEnumPaymentMethodTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodTypeEnumFilter<$PrismaModel> | $Enums.PaymentMethodTypeEnum
  }

  export type NestedEnumPaymentSystemEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentSystemEnum | EnumPaymentSystemEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentSystemEnum[] | ListEnumPaymentSystemEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentSystemEnum[] | ListEnumPaymentSystemEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentSystemEnumFilter<$PrismaModel> | $Enums.PaymentSystemEnum
  }

  export type NestedEnumPaymentMethodTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodTypeEnum | EnumPaymentMethodTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodTypeEnum[] | ListEnumPaymentMethodTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethodTypeEnum[] | ListEnumPaymentMethodTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethodTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodTypeEnumFilter<$PrismaModel>
  }

  export type NestedEnumPaymentSystemEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentSystemEnum | EnumPaymentSystemEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentSystemEnum[] | ListEnumPaymentSystemEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentSystemEnum[] | ListEnumPaymentSystemEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentSystemEnumWithAggregatesFilter<$PrismaModel> | $Enums.PaymentSystemEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentSystemEnumFilter<$PrismaModel>
    _max?: NestedEnumPaymentSystemEnumFilter<$PrismaModel>
  }

  export type UsersCreateWithoutTelegramDataInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    role?: RolesCreateNestedOneWithoutUsersInput
    payments?: PaymentsCreateNestedManyWithoutUserInput
    referrals?: ReferralsCreateNestedManyWithoutReferralInput
    inviters?: ReferralsCreateNestedManyWithoutInviterInput
    balance?: UserBalanceCreateNestedOneWithoutUserInput
    language: LanguageCreateNestedOneWithoutUsersInput
    subscriptions?: SubscriptionsCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalsCreateNestedManyWithoutUserInput
    adsViews?: AdsViewsCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutTelegramDataInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    roleId?: $Enums.UserRoleEnum
    balanceId?: string | null
    languageId: string
    payments?: PaymentsUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralsUncheckedCreateNestedManyWithoutReferralInput
    inviters?: ReferralsUncheckedCreateNestedManyWithoutInviterInput
    subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalsUncheckedCreateNestedManyWithoutUserInput
    adsViews?: AdsViewsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutTelegramDataInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutTelegramDataInput, UsersUncheckedCreateWithoutTelegramDataInput>
  }

  export type UsersUpsertWithoutTelegramDataInput = {
    update: XOR<UsersUpdateWithoutTelegramDataInput, UsersUncheckedUpdateWithoutTelegramDataInput>
    create: XOR<UsersCreateWithoutTelegramDataInput, UsersUncheckedCreateWithoutTelegramDataInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutTelegramDataInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutTelegramDataInput, UsersUncheckedUpdateWithoutTelegramDataInput>
  }

  export type UsersUpdateWithoutTelegramDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RolesUpdateOneRequiredWithoutUsersNestedInput
    payments?: PaymentsUpdateManyWithoutUserNestedInput
    referrals?: ReferralsUpdateManyWithoutReferralNestedInput
    inviters?: ReferralsUpdateManyWithoutInviterNestedInput
    balance?: UserBalanceUpdateOneWithoutUserNestedInput
    language?: LanguageUpdateOneRequiredWithoutUsersNestedInput
    subscriptions?: SubscriptionsUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalsUpdateManyWithoutUserNestedInput
    adsViews?: AdsViewsUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutTelegramDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: EnumUserRoleEnumFieldUpdateOperationsInput | $Enums.UserRoleEnum
    balanceId?: NullableStringFieldUpdateOperationsInput | string | null
    languageId?: StringFieldUpdateOperationsInput | string
    payments?: PaymentsUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralsUncheckedUpdateManyWithoutReferralNestedInput
    inviters?: ReferralsUncheckedUpdateManyWithoutInviterNestedInput
    subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalsUncheckedUpdateManyWithoutUserNestedInput
    adsViews?: AdsViewsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsersCreateWithoutInvitersInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    role?: RolesCreateNestedOneWithoutUsersInput
    payments?: PaymentsCreateNestedManyWithoutUserInput
    referrals?: ReferralsCreateNestedManyWithoutReferralInput
    telegramData?: UserTelegramDataCreateNestedOneWithoutUserInput
    balance?: UserBalanceCreateNestedOneWithoutUserInput
    language: LanguageCreateNestedOneWithoutUsersInput
    subscriptions?: SubscriptionsCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalsCreateNestedManyWithoutUserInput
    adsViews?: AdsViewsCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutInvitersInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    roleId?: $Enums.UserRoleEnum
    telegramDataId?: string | null
    balanceId?: string | null
    languageId: string
    payments?: PaymentsUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralsUncheckedCreateNestedManyWithoutReferralInput
    subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalsUncheckedCreateNestedManyWithoutUserInput
    adsViews?: AdsViewsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutInvitersInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutInvitersInput, UsersUncheckedCreateWithoutInvitersInput>
  }

  export type UsersCreateWithoutReferralsInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    role?: RolesCreateNestedOneWithoutUsersInput
    payments?: PaymentsCreateNestedManyWithoutUserInput
    inviters?: ReferralsCreateNestedManyWithoutInviterInput
    telegramData?: UserTelegramDataCreateNestedOneWithoutUserInput
    balance?: UserBalanceCreateNestedOneWithoutUserInput
    language: LanguageCreateNestedOneWithoutUsersInput
    subscriptions?: SubscriptionsCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalsCreateNestedManyWithoutUserInput
    adsViews?: AdsViewsCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutReferralsInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    roleId?: $Enums.UserRoleEnum
    telegramDataId?: string | null
    balanceId?: string | null
    languageId: string
    payments?: PaymentsUncheckedCreateNestedManyWithoutUserInput
    inviters?: ReferralsUncheckedCreateNestedManyWithoutInviterInput
    subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalsUncheckedCreateNestedManyWithoutUserInput
    adsViews?: AdsViewsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutReferralsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutReferralsInput, UsersUncheckedCreateWithoutReferralsInput>
  }

  export type UsersUpsertWithoutInvitersInput = {
    update: XOR<UsersUpdateWithoutInvitersInput, UsersUncheckedUpdateWithoutInvitersInput>
    create: XOR<UsersCreateWithoutInvitersInput, UsersUncheckedCreateWithoutInvitersInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutInvitersInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutInvitersInput, UsersUncheckedUpdateWithoutInvitersInput>
  }

  export type UsersUpdateWithoutInvitersInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RolesUpdateOneRequiredWithoutUsersNestedInput
    payments?: PaymentsUpdateManyWithoutUserNestedInput
    referrals?: ReferralsUpdateManyWithoutReferralNestedInput
    telegramData?: UserTelegramDataUpdateOneWithoutUserNestedInput
    balance?: UserBalanceUpdateOneWithoutUserNestedInput
    language?: LanguageUpdateOneRequiredWithoutUsersNestedInput
    subscriptions?: SubscriptionsUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalsUpdateManyWithoutUserNestedInput
    adsViews?: AdsViewsUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutInvitersInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: EnumUserRoleEnumFieldUpdateOperationsInput | $Enums.UserRoleEnum
    telegramDataId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceId?: NullableStringFieldUpdateOperationsInput | string | null
    languageId?: StringFieldUpdateOperationsInput | string
    payments?: PaymentsUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralsUncheckedUpdateManyWithoutReferralNestedInput
    subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalsUncheckedUpdateManyWithoutUserNestedInput
    adsViews?: AdsViewsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsersUpsertWithoutReferralsInput = {
    update: XOR<UsersUpdateWithoutReferralsInput, UsersUncheckedUpdateWithoutReferralsInput>
    create: XOR<UsersCreateWithoutReferralsInput, UsersUncheckedCreateWithoutReferralsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutReferralsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutReferralsInput, UsersUncheckedUpdateWithoutReferralsInput>
  }

  export type UsersUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RolesUpdateOneRequiredWithoutUsersNestedInput
    payments?: PaymentsUpdateManyWithoutUserNestedInput
    inviters?: ReferralsUpdateManyWithoutInviterNestedInput
    telegramData?: UserTelegramDataUpdateOneWithoutUserNestedInput
    balance?: UserBalanceUpdateOneWithoutUserNestedInput
    language?: LanguageUpdateOneRequiredWithoutUsersNestedInput
    subscriptions?: SubscriptionsUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalsUpdateManyWithoutUserNestedInput
    adsViews?: AdsViewsUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: EnumUserRoleEnumFieldUpdateOperationsInput | $Enums.UserRoleEnum
    telegramDataId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceId?: NullableStringFieldUpdateOperationsInput | string | null
    languageId?: StringFieldUpdateOperationsInput | string
    payments?: PaymentsUncheckedUpdateManyWithoutUserNestedInput
    inviters?: ReferralsUncheckedUpdateManyWithoutInviterNestedInput
    subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalsUncheckedUpdateManyWithoutUserNestedInput
    adsViews?: AdsViewsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RolesCreateWithoutUsersInput = {
    key: $Enums.UserRoleEnum
    name: string
    discount?: number
    limitSubscriptions?: number
  }

  export type RolesUncheckedCreateWithoutUsersInput = {
    key: $Enums.UserRoleEnum
    name: string
    discount?: number
    limitSubscriptions?: number
  }

  export type RolesCreateOrConnectWithoutUsersInput = {
    where: RolesWhereUniqueInput
    create: XOR<RolesCreateWithoutUsersInput, RolesUncheckedCreateWithoutUsersInput>
  }

  export type PaymentsCreateWithoutUserInput = {
    id?: string
    status?: $Enums.PaymentStatusEnum
    amount?: string
    exchangeRate?: string
    token: string
    linkPay?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    currency: CurrencyCreateNestedOneWithoutPaymentsInput
    Subscription?: SubscriptionsCreateNestedOneWithoutPaymentsInput
    method: PaymentMethodsCreateNestedOneWithoutPaymentsInput
    transacrion?: TransactionsCreateNestedOneWithoutPaymentInput
  }

  export type PaymentsUncheckedCreateWithoutUserInput = {
    id?: string
    status?: $Enums.PaymentStatusEnum
    amount?: string
    exchangeRate?: string
    token: string
    linkPay?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    currencyKey: $Enums.CurrencyEnum
    SubscriptionId?: string | null
    methodKey: $Enums.PaymentMethodEnum
    transactionId?: string | null
  }

  export type PaymentsCreateOrConnectWithoutUserInput = {
    where: PaymentsWhereUniqueInput
    create: XOR<PaymentsCreateWithoutUserInput, PaymentsUncheckedCreateWithoutUserInput>
  }

  export type PaymentsCreateManyUserInputEnvelope = {
    data: PaymentsCreateManyUserInput | PaymentsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReferralsCreateWithoutReferralInput = {
    id?: string
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inviter: UsersCreateNestedOneWithoutInvitersInput
  }

  export type ReferralsUncheckedCreateWithoutReferralInput = {
    id?: string
    level?: number
    inviterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralsCreateOrConnectWithoutReferralInput = {
    where: ReferralsWhereUniqueInput
    create: XOR<ReferralsCreateWithoutReferralInput, ReferralsUncheckedCreateWithoutReferralInput>
  }

  export type ReferralsCreateManyReferralInputEnvelope = {
    data: ReferralsCreateManyReferralInput | ReferralsCreateManyReferralInput[]
    skipDuplicates?: boolean
  }

  export type ReferralsCreateWithoutInviterInput = {
    id?: string
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referral: UsersCreateNestedOneWithoutReferralsInput
  }

  export type ReferralsUncheckedCreateWithoutInviterInput = {
    id?: string
    level?: number
    referralId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralsCreateOrConnectWithoutInviterInput = {
    where: ReferralsWhereUniqueInput
    create: XOR<ReferralsCreateWithoutInviterInput, ReferralsUncheckedCreateWithoutInviterInput>
  }

  export type ReferralsCreateManyInviterInputEnvelope = {
    data: ReferralsCreateManyInviterInput | ReferralsCreateManyInviterInput[]
    skipDuplicates?: boolean
  }

  export type UserTelegramDataCreateWithoutUserInput = {
    id?: string
    isLive?: boolean
    isRtl?: boolean
    isPremium?: boolean
    isBot?: boolean
    firstName: string
    lastName?: string | null
    username?: string | null
    languageCode: string
    photoUrl?: string | null
    addedToAttachmentMenu?: boolean
    allowsWriteToPm?: boolean
    updatedAt?: Date | string
  }

  export type UserTelegramDataUncheckedCreateWithoutUserInput = {
    id?: string
    isLive?: boolean
    isRtl?: boolean
    isPremium?: boolean
    isBot?: boolean
    firstName: string
    lastName?: string | null
    username?: string | null
    languageCode: string
    photoUrl?: string | null
    addedToAttachmentMenu?: boolean
    allowsWriteToPm?: boolean
    updatedAt?: Date | string
  }

  export type UserTelegramDataCreateOrConnectWithoutUserInput = {
    where: UserTelegramDataWhereUniqueInput
    create: XOR<UserTelegramDataCreateWithoutUserInput, UserTelegramDataUncheckedCreateWithoutUserInput>
  }

  export type UserBalanceCreateWithoutUserInput = {
    id?: string
    paymentBalance?: number
    holdBalance?: number
    totalEarnedWithdrawalBalance?: number
    withdrawalBalance?: number
    isUseWithdrawalBalance?: boolean
    updatedAt?: Date | string
    transactions?: TransactionsCreateNestedManyWithoutBalanceInput
  }

  export type UserBalanceUncheckedCreateWithoutUserInput = {
    id?: string
    paymentBalance?: number
    holdBalance?: number
    totalEarnedWithdrawalBalance?: number
    withdrawalBalance?: number
    isUseWithdrawalBalance?: boolean
    updatedAt?: Date | string
    transactions?: TransactionsUncheckedCreateNestedManyWithoutBalanceInput
  }

  export type UserBalanceCreateOrConnectWithoutUserInput = {
    where: UserBalanceWhereUniqueInput
    create: XOR<UserBalanceCreateWithoutUserInput, UserBalanceUncheckedCreateWithoutUserInput>
  }

  export type LanguageCreateWithoutUsersInput = {
    id?: string
    name: string
    nativeName: string
    iso6391: string
    iso6392: string
    iso6393: string
  }

  export type LanguageUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    nativeName: string
    iso6391: string
    iso6392: string
    iso6393: string
  }

  export type LanguageCreateOrConnectWithoutUsersInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutUsersInput, LanguageUncheckedCreateWithoutUsersInput>
  }

  export type SubscriptionsCreateWithoutUserInput = {
    id?: string
    username: string
    isActive?: boolean
    isAutoRenewal?: boolean
    token: string
    period?: $Enums.SubscriptionPeriodEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    expiredAt?: Date | string | null
    payments?: PaymentsCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionsUncheckedCreateWithoutUserInput = {
    id?: string
    username: string
    isActive?: boolean
    isAutoRenewal?: boolean
    token: string
    period?: $Enums.SubscriptionPeriodEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    expiredAt?: Date | string | null
    payments?: PaymentsUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionsCreateOrConnectWithoutUserInput = {
    where: SubscriptionsWhereUniqueInput
    create: XOR<SubscriptionsCreateWithoutUserInput, SubscriptionsUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionsCreateManyUserInputEnvelope = {
    data: SubscriptionsCreateManyUserInput | SubscriptionsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WithdrawalsCreateWithoutUserInput = {
    id?: string
    status?: $Enums.WithdrawalStatusEnum
    amountStars?: number
    amountUSD?: number
    amountTON?: number
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transacrion: TransactionsCreateNestedOneWithoutWithdrawalInput
  }

  export type WithdrawalsUncheckedCreateWithoutUserInput = {
    id?: string
    status?: $Enums.WithdrawalStatusEnum
    amountStars?: number
    amountUSD?: number
    amountTON?: number
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId: string
  }

  export type WithdrawalsCreateOrConnectWithoutUserInput = {
    where: WithdrawalsWhereUniqueInput
    create: XOR<WithdrawalsCreateWithoutUserInput, WithdrawalsUncheckedCreateWithoutUserInput>
  }

  export type WithdrawalsCreateManyUserInputEnvelope = {
    data: WithdrawalsCreateManyUserInput | WithdrawalsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AdsViewsCreateWithoutUserInput = {
    id?: string
    type?: $Enums.AdsViewTypeEnum
    createdAt?: Date | string
    network?: AdsNetworksCreateNestedOneWithoutAdsViewsInput
  }

  export type AdsViewsUncheckedCreateWithoutUserInput = {
    id?: string
    networkKey?: $Enums.AdsNetworkEnum
    type?: $Enums.AdsViewTypeEnum
    createdAt?: Date | string
  }

  export type AdsViewsCreateOrConnectWithoutUserInput = {
    where: AdsViewsWhereUniqueInput
    create: XOR<AdsViewsCreateWithoutUserInput, AdsViewsUncheckedCreateWithoutUserInput>
  }

  export type AdsViewsCreateManyUserInputEnvelope = {
    data: AdsViewsCreateManyUserInput | AdsViewsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RolesUpsertWithoutUsersInput = {
    update: XOR<RolesUpdateWithoutUsersInput, RolesUncheckedUpdateWithoutUsersInput>
    create: XOR<RolesCreateWithoutUsersInput, RolesUncheckedCreateWithoutUsersInput>
    where?: RolesWhereInput
  }

  export type RolesUpdateToOneWithWhereWithoutUsersInput = {
    where?: RolesWhereInput
    data: XOR<RolesUpdateWithoutUsersInput, RolesUncheckedUpdateWithoutUsersInput>
  }

  export type RolesUpdateWithoutUsersInput = {
    key?: EnumUserRoleEnumFieldUpdateOperationsInput | $Enums.UserRoleEnum
    name?: StringFieldUpdateOperationsInput | string
    discount?: FloatFieldUpdateOperationsInput | number
    limitSubscriptions?: IntFieldUpdateOperationsInput | number
  }

  export type RolesUncheckedUpdateWithoutUsersInput = {
    key?: EnumUserRoleEnumFieldUpdateOperationsInput | $Enums.UserRoleEnum
    name?: StringFieldUpdateOperationsInput | string
    discount?: FloatFieldUpdateOperationsInput | number
    limitSubscriptions?: IntFieldUpdateOperationsInput | number
  }

  export type PaymentsUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentsWhereUniqueInput
    update: XOR<PaymentsUpdateWithoutUserInput, PaymentsUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentsCreateWithoutUserInput, PaymentsUncheckedCreateWithoutUserInput>
  }

  export type PaymentsUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentsWhereUniqueInput
    data: XOR<PaymentsUpdateWithoutUserInput, PaymentsUncheckedUpdateWithoutUserInput>
  }

  export type PaymentsUpdateManyWithWhereWithoutUserInput = {
    where: PaymentsScalarWhereInput
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentsScalarWhereInput = {
    AND?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
    OR?: PaymentsScalarWhereInput[]
    NOT?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
    id?: StringFilter<"Payments"> | string
    status?: EnumPaymentStatusEnumFilter<"Payments"> | $Enums.PaymentStatusEnum
    amount?: StringFilter<"Payments"> | string
    exchangeRate?: StringFilter<"Payments"> | string
    token?: StringFilter<"Payments"> | string
    linkPay?: StringNullableFilter<"Payments"> | string | null
    details?: JsonNullableFilter<"Payments">
    createdAt?: DateTimeFilter<"Payments"> | Date | string
    updatedAt?: DateTimeFilter<"Payments"> | Date | string
    userId?: StringFilter<"Payments"> | string
    currencyKey?: EnumCurrencyEnumFilter<"Payments"> | $Enums.CurrencyEnum
    SubscriptionId?: StringNullableFilter<"Payments"> | string | null
    methodKey?: EnumPaymentMethodEnumFilter<"Payments"> | $Enums.PaymentMethodEnum
    transactionId?: StringNullableFilter<"Payments"> | string | null
  }

  export type ReferralsUpsertWithWhereUniqueWithoutReferralInput = {
    where: ReferralsWhereUniqueInput
    update: XOR<ReferralsUpdateWithoutReferralInput, ReferralsUncheckedUpdateWithoutReferralInput>
    create: XOR<ReferralsCreateWithoutReferralInput, ReferralsUncheckedCreateWithoutReferralInput>
  }

  export type ReferralsUpdateWithWhereUniqueWithoutReferralInput = {
    where: ReferralsWhereUniqueInput
    data: XOR<ReferralsUpdateWithoutReferralInput, ReferralsUncheckedUpdateWithoutReferralInput>
  }

  export type ReferralsUpdateManyWithWhereWithoutReferralInput = {
    where: ReferralsScalarWhereInput
    data: XOR<ReferralsUpdateManyMutationInput, ReferralsUncheckedUpdateManyWithoutReferralInput>
  }

  export type ReferralsScalarWhereInput = {
    AND?: ReferralsScalarWhereInput | ReferralsScalarWhereInput[]
    OR?: ReferralsScalarWhereInput[]
    NOT?: ReferralsScalarWhereInput | ReferralsScalarWhereInput[]
    id?: StringFilter<"Referrals"> | string
    level?: IntFilter<"Referrals"> | number
    inviterId?: StringFilter<"Referrals"> | string
    referralId?: StringFilter<"Referrals"> | string
    createdAt?: DateTimeFilter<"Referrals"> | Date | string
    updatedAt?: DateTimeFilter<"Referrals"> | Date | string
  }

  export type ReferralsUpsertWithWhereUniqueWithoutInviterInput = {
    where: ReferralsWhereUniqueInput
    update: XOR<ReferralsUpdateWithoutInviterInput, ReferralsUncheckedUpdateWithoutInviterInput>
    create: XOR<ReferralsCreateWithoutInviterInput, ReferralsUncheckedCreateWithoutInviterInput>
  }

  export type ReferralsUpdateWithWhereUniqueWithoutInviterInput = {
    where: ReferralsWhereUniqueInput
    data: XOR<ReferralsUpdateWithoutInviterInput, ReferralsUncheckedUpdateWithoutInviterInput>
  }

  export type ReferralsUpdateManyWithWhereWithoutInviterInput = {
    where: ReferralsScalarWhereInput
    data: XOR<ReferralsUpdateManyMutationInput, ReferralsUncheckedUpdateManyWithoutInviterInput>
  }

  export type UserTelegramDataUpsertWithoutUserInput = {
    update: XOR<UserTelegramDataUpdateWithoutUserInput, UserTelegramDataUncheckedUpdateWithoutUserInput>
    create: XOR<UserTelegramDataCreateWithoutUserInput, UserTelegramDataUncheckedCreateWithoutUserInput>
    where?: UserTelegramDataWhereInput
  }

  export type UserTelegramDataUpdateToOneWithWhereWithoutUserInput = {
    where?: UserTelegramDataWhereInput
    data: XOR<UserTelegramDataUpdateWithoutUserInput, UserTelegramDataUncheckedUpdateWithoutUserInput>
  }

  export type UserTelegramDataUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLive?: BoolFieldUpdateOperationsInput | boolean
    isRtl?: BoolFieldUpdateOperationsInput | boolean
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    languageCode?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    addedToAttachmentMenu?: BoolFieldUpdateOperationsInput | boolean
    allowsWriteToPm?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTelegramDataUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLive?: BoolFieldUpdateOperationsInput | boolean
    isRtl?: BoolFieldUpdateOperationsInput | boolean
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    languageCode?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    addedToAttachmentMenu?: BoolFieldUpdateOperationsInput | boolean
    allowsWriteToPm?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBalanceUpsertWithoutUserInput = {
    update: XOR<UserBalanceUpdateWithoutUserInput, UserBalanceUncheckedUpdateWithoutUserInput>
    create: XOR<UserBalanceCreateWithoutUserInput, UserBalanceUncheckedCreateWithoutUserInput>
    where?: UserBalanceWhereInput
  }

  export type UserBalanceUpdateToOneWithWhereWithoutUserInput = {
    where?: UserBalanceWhereInput
    data: XOR<UserBalanceUpdateWithoutUserInput, UserBalanceUncheckedUpdateWithoutUserInput>
  }

  export type UserBalanceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentBalance?: FloatFieldUpdateOperationsInput | number
    holdBalance?: FloatFieldUpdateOperationsInput | number
    totalEarnedWithdrawalBalance?: FloatFieldUpdateOperationsInput | number
    withdrawalBalance?: FloatFieldUpdateOperationsInput | number
    isUseWithdrawalBalance?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionsUpdateManyWithoutBalanceNestedInput
  }

  export type UserBalanceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentBalance?: FloatFieldUpdateOperationsInput | number
    holdBalance?: FloatFieldUpdateOperationsInput | number
    totalEarnedWithdrawalBalance?: FloatFieldUpdateOperationsInput | number
    withdrawalBalance?: FloatFieldUpdateOperationsInput | number
    isUseWithdrawalBalance?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionsUncheckedUpdateManyWithoutBalanceNestedInput
  }

  export type LanguageUpsertWithoutUsersInput = {
    update: XOR<LanguageUpdateWithoutUsersInput, LanguageUncheckedUpdateWithoutUsersInput>
    create: XOR<LanguageCreateWithoutUsersInput, LanguageUncheckedCreateWithoutUsersInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutUsersInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutUsersInput, LanguageUncheckedUpdateWithoutUsersInput>
  }

  export type LanguageUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    iso6391?: StringFieldUpdateOperationsInput | string
    iso6392?: StringFieldUpdateOperationsInput | string
    iso6393?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    iso6391?: StringFieldUpdateOperationsInput | string
    iso6392?: StringFieldUpdateOperationsInput | string
    iso6393?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionsUpsertWithWhereUniqueWithoutUserInput = {
    where: SubscriptionsWhereUniqueInput
    update: XOR<SubscriptionsUpdateWithoutUserInput, SubscriptionsUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionsCreateWithoutUserInput, SubscriptionsUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionsUpdateWithWhereUniqueWithoutUserInput = {
    where: SubscriptionsWhereUniqueInput
    data: XOR<SubscriptionsUpdateWithoutUserInput, SubscriptionsUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionsUpdateManyWithWhereWithoutUserInput = {
    where: SubscriptionsScalarWhereInput
    data: XOR<SubscriptionsUpdateManyMutationInput, SubscriptionsUncheckedUpdateManyWithoutUserInput>
  }

  export type SubscriptionsScalarWhereInput = {
    AND?: SubscriptionsScalarWhereInput | SubscriptionsScalarWhereInput[]
    OR?: SubscriptionsScalarWhereInput[]
    NOT?: SubscriptionsScalarWhereInput | SubscriptionsScalarWhereInput[]
    id?: StringFilter<"Subscriptions"> | string
    username?: StringFilter<"Subscriptions"> | string
    isActive?: BoolFilter<"Subscriptions"> | boolean
    isAutoRenewal?: BoolFilter<"Subscriptions"> | boolean
    token?: StringFilter<"Subscriptions"> | string
    period?: EnumSubscriptionPeriodEnumFilter<"Subscriptions"> | $Enums.SubscriptionPeriodEnum
    createdAt?: DateTimeFilter<"Subscriptions"> | Date | string
    updatedAt?: DateTimeFilter<"Subscriptions"> | Date | string
    expiredAt?: DateTimeNullableFilter<"Subscriptions"> | Date | string | null
    userId?: StringFilter<"Subscriptions"> | string
  }

  export type WithdrawalsUpsertWithWhereUniqueWithoutUserInput = {
    where: WithdrawalsWhereUniqueInput
    update: XOR<WithdrawalsUpdateWithoutUserInput, WithdrawalsUncheckedUpdateWithoutUserInput>
    create: XOR<WithdrawalsCreateWithoutUserInput, WithdrawalsUncheckedCreateWithoutUserInput>
  }

  export type WithdrawalsUpdateWithWhereUniqueWithoutUserInput = {
    where: WithdrawalsWhereUniqueInput
    data: XOR<WithdrawalsUpdateWithoutUserInput, WithdrawalsUncheckedUpdateWithoutUserInput>
  }

  export type WithdrawalsUpdateManyWithWhereWithoutUserInput = {
    where: WithdrawalsScalarWhereInput
    data: XOR<WithdrawalsUpdateManyMutationInput, WithdrawalsUncheckedUpdateManyWithoutUserInput>
  }

  export type WithdrawalsScalarWhereInput = {
    AND?: WithdrawalsScalarWhereInput | WithdrawalsScalarWhereInput[]
    OR?: WithdrawalsScalarWhereInput[]
    NOT?: WithdrawalsScalarWhereInput | WithdrawalsScalarWhereInput[]
    id?: StringFilter<"Withdrawals"> | string
    status?: EnumWithdrawalStatusEnumFilter<"Withdrawals"> | $Enums.WithdrawalStatusEnum
    amountStars?: FloatFilter<"Withdrawals"> | number
    amountUSD?: FloatFilter<"Withdrawals"> | number
    amountTON?: FloatFilter<"Withdrawals"> | number
    address?: StringFilter<"Withdrawals"> | string
    createdAt?: DateTimeFilter<"Withdrawals"> | Date | string
    updatedAt?: DateTimeFilter<"Withdrawals"> | Date | string
    userId?: StringFilter<"Withdrawals"> | string
    transactionId?: StringFilter<"Withdrawals"> | string
  }

  export type AdsViewsUpsertWithWhereUniqueWithoutUserInput = {
    where: AdsViewsWhereUniqueInput
    update: XOR<AdsViewsUpdateWithoutUserInput, AdsViewsUncheckedUpdateWithoutUserInput>
    create: XOR<AdsViewsCreateWithoutUserInput, AdsViewsUncheckedCreateWithoutUserInput>
  }

  export type AdsViewsUpdateWithWhereUniqueWithoutUserInput = {
    where: AdsViewsWhereUniqueInput
    data: XOR<AdsViewsUpdateWithoutUserInput, AdsViewsUncheckedUpdateWithoutUserInput>
  }

  export type AdsViewsUpdateManyWithWhereWithoutUserInput = {
    where: AdsViewsScalarWhereInput
    data: XOR<AdsViewsUpdateManyMutationInput, AdsViewsUncheckedUpdateManyWithoutUserInput>
  }

  export type AdsViewsScalarWhereInput = {
    AND?: AdsViewsScalarWhereInput | AdsViewsScalarWhereInput[]
    OR?: AdsViewsScalarWhereInput[]
    NOT?: AdsViewsScalarWhereInput | AdsViewsScalarWhereInput[]
    id?: StringFilter<"AdsViews"> | string
    networkKey?: EnumAdsNetworkEnumFilter<"AdsViews"> | $Enums.AdsNetworkEnum
    type?: EnumAdsViewTypeEnumFilter<"AdsViews"> | $Enums.AdsViewTypeEnum
    createdAt?: DateTimeFilter<"AdsViews"> | Date | string
    userId?: StringFilter<"AdsViews"> | string
  }

  export type AdsNetworksCreateWithoutAdsViewsInput = {
    key: $Enums.AdsNetworkEnum
    isActive: boolean
    name: string
  }

  export type AdsNetworksUncheckedCreateWithoutAdsViewsInput = {
    key: $Enums.AdsNetworkEnum
    isActive: boolean
    name: string
  }

  export type AdsNetworksCreateOrConnectWithoutAdsViewsInput = {
    where: AdsNetworksWhereUniqueInput
    create: XOR<AdsNetworksCreateWithoutAdsViewsInput, AdsNetworksUncheckedCreateWithoutAdsViewsInput>
  }

  export type UsersCreateWithoutAdsViewsInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    role?: RolesCreateNestedOneWithoutUsersInput
    payments?: PaymentsCreateNestedManyWithoutUserInput
    referrals?: ReferralsCreateNestedManyWithoutReferralInput
    inviters?: ReferralsCreateNestedManyWithoutInviterInput
    telegramData?: UserTelegramDataCreateNestedOneWithoutUserInput
    balance?: UserBalanceCreateNestedOneWithoutUserInput
    language: LanguageCreateNestedOneWithoutUsersInput
    subscriptions?: SubscriptionsCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalsCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutAdsViewsInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    roleId?: $Enums.UserRoleEnum
    telegramDataId?: string | null
    balanceId?: string | null
    languageId: string
    payments?: PaymentsUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralsUncheckedCreateNestedManyWithoutReferralInput
    inviters?: ReferralsUncheckedCreateNestedManyWithoutInviterInput
    subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutAdsViewsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutAdsViewsInput, UsersUncheckedCreateWithoutAdsViewsInput>
  }

  export type AdsNetworksUpsertWithoutAdsViewsInput = {
    update: XOR<AdsNetworksUpdateWithoutAdsViewsInput, AdsNetworksUncheckedUpdateWithoutAdsViewsInput>
    create: XOR<AdsNetworksCreateWithoutAdsViewsInput, AdsNetworksUncheckedCreateWithoutAdsViewsInput>
    where?: AdsNetworksWhereInput
  }

  export type AdsNetworksUpdateToOneWithWhereWithoutAdsViewsInput = {
    where?: AdsNetworksWhereInput
    data: XOR<AdsNetworksUpdateWithoutAdsViewsInput, AdsNetworksUncheckedUpdateWithoutAdsViewsInput>
  }

  export type AdsNetworksUpdateWithoutAdsViewsInput = {
    key?: EnumAdsNetworkEnumFieldUpdateOperationsInput | $Enums.AdsNetworkEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AdsNetworksUncheckedUpdateWithoutAdsViewsInput = {
    key?: EnumAdsNetworkEnumFieldUpdateOperationsInput | $Enums.AdsNetworkEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UsersUpsertWithoutAdsViewsInput = {
    update: XOR<UsersUpdateWithoutAdsViewsInput, UsersUncheckedUpdateWithoutAdsViewsInput>
    create: XOR<UsersCreateWithoutAdsViewsInput, UsersUncheckedCreateWithoutAdsViewsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutAdsViewsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutAdsViewsInput, UsersUncheckedUpdateWithoutAdsViewsInput>
  }

  export type UsersUpdateWithoutAdsViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RolesUpdateOneRequiredWithoutUsersNestedInput
    payments?: PaymentsUpdateManyWithoutUserNestedInput
    referrals?: ReferralsUpdateManyWithoutReferralNestedInput
    inviters?: ReferralsUpdateManyWithoutInviterNestedInput
    telegramData?: UserTelegramDataUpdateOneWithoutUserNestedInput
    balance?: UserBalanceUpdateOneWithoutUserNestedInput
    language?: LanguageUpdateOneRequiredWithoutUsersNestedInput
    subscriptions?: SubscriptionsUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalsUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutAdsViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: EnumUserRoleEnumFieldUpdateOperationsInput | $Enums.UserRoleEnum
    telegramDataId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceId?: NullableStringFieldUpdateOperationsInput | string | null
    languageId?: StringFieldUpdateOperationsInput | string
    payments?: PaymentsUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralsUncheckedUpdateManyWithoutReferralNestedInput
    inviters?: ReferralsUncheckedUpdateManyWithoutInviterNestedInput
    subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AdsViewsCreateWithoutNetworkInput = {
    id?: string
    type?: $Enums.AdsViewTypeEnum
    createdAt?: Date | string
    user: UsersCreateNestedOneWithoutAdsViewsInput
  }

  export type AdsViewsUncheckedCreateWithoutNetworkInput = {
    id?: string
    type?: $Enums.AdsViewTypeEnum
    createdAt?: Date | string
    userId: string
  }

  export type AdsViewsCreateOrConnectWithoutNetworkInput = {
    where: AdsViewsWhereUniqueInput
    create: XOR<AdsViewsCreateWithoutNetworkInput, AdsViewsUncheckedCreateWithoutNetworkInput>
  }

  export type AdsViewsCreateManyNetworkInputEnvelope = {
    data: AdsViewsCreateManyNetworkInput | AdsViewsCreateManyNetworkInput[]
    skipDuplicates?: boolean
  }

  export type AdsViewsUpsertWithWhereUniqueWithoutNetworkInput = {
    where: AdsViewsWhereUniqueInput
    update: XOR<AdsViewsUpdateWithoutNetworkInput, AdsViewsUncheckedUpdateWithoutNetworkInput>
    create: XOR<AdsViewsCreateWithoutNetworkInput, AdsViewsUncheckedCreateWithoutNetworkInput>
  }

  export type AdsViewsUpdateWithWhereUniqueWithoutNetworkInput = {
    where: AdsViewsWhereUniqueInput
    data: XOR<AdsViewsUpdateWithoutNetworkInput, AdsViewsUncheckedUpdateWithoutNetworkInput>
  }

  export type AdsViewsUpdateManyWithWhereWithoutNetworkInput = {
    where: AdsViewsScalarWhereInput
    data: XOR<AdsViewsUpdateManyMutationInput, AdsViewsUncheckedUpdateManyWithoutNetworkInput>
  }

  export type UsersCreateWithoutBalanceInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    role?: RolesCreateNestedOneWithoutUsersInput
    payments?: PaymentsCreateNestedManyWithoutUserInput
    referrals?: ReferralsCreateNestedManyWithoutReferralInput
    inviters?: ReferralsCreateNestedManyWithoutInviterInput
    telegramData?: UserTelegramDataCreateNestedOneWithoutUserInput
    language: LanguageCreateNestedOneWithoutUsersInput
    subscriptions?: SubscriptionsCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalsCreateNestedManyWithoutUserInput
    adsViews?: AdsViewsCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutBalanceInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    roleId?: $Enums.UserRoleEnum
    telegramDataId?: string | null
    languageId: string
    payments?: PaymentsUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralsUncheckedCreateNestedManyWithoutReferralInput
    inviters?: ReferralsUncheckedCreateNestedManyWithoutInviterInput
    subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalsUncheckedCreateNestedManyWithoutUserInput
    adsViews?: AdsViewsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutBalanceInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutBalanceInput, UsersUncheckedCreateWithoutBalanceInput>
  }

  export type TransactionsCreateWithoutBalanceInput = {
    id?: string
    amount?: number
    isHold?: boolean
    type?: $Enums.TransactionTypeEnum
    reason?: $Enums.TransactionReasonEnum
    balanceType?: $Enums.BalanceTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiredAt?: Date | string | null
    withdrawal?: WithdrawalsCreateNestedOneWithoutTransacrionInput
    payment?: PaymentsCreateNestedOneWithoutTransacrionInput
  }

  export type TransactionsUncheckedCreateWithoutBalanceInput = {
    id?: string
    amount?: number
    isHold?: boolean
    type?: $Enums.TransactionTypeEnum
    reason?: $Enums.TransactionReasonEnum
    balanceType?: $Enums.BalanceTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiredAt?: Date | string | null
    withdrawal?: WithdrawalsUncheckedCreateNestedOneWithoutTransacrionInput
    payment?: PaymentsUncheckedCreateNestedOneWithoutTransacrionInput
  }

  export type TransactionsCreateOrConnectWithoutBalanceInput = {
    where: TransactionsWhereUniqueInput
    create: XOR<TransactionsCreateWithoutBalanceInput, TransactionsUncheckedCreateWithoutBalanceInput>
  }

  export type TransactionsCreateManyBalanceInputEnvelope = {
    data: TransactionsCreateManyBalanceInput | TransactionsCreateManyBalanceInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithoutBalanceInput = {
    update: XOR<UsersUpdateWithoutBalanceInput, UsersUncheckedUpdateWithoutBalanceInput>
    create: XOR<UsersCreateWithoutBalanceInput, UsersUncheckedCreateWithoutBalanceInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutBalanceInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutBalanceInput, UsersUncheckedUpdateWithoutBalanceInput>
  }

  export type UsersUpdateWithoutBalanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RolesUpdateOneRequiredWithoutUsersNestedInput
    payments?: PaymentsUpdateManyWithoutUserNestedInput
    referrals?: ReferralsUpdateManyWithoutReferralNestedInput
    inviters?: ReferralsUpdateManyWithoutInviterNestedInput
    telegramData?: UserTelegramDataUpdateOneWithoutUserNestedInput
    language?: LanguageUpdateOneRequiredWithoutUsersNestedInput
    subscriptions?: SubscriptionsUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalsUpdateManyWithoutUserNestedInput
    adsViews?: AdsViewsUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutBalanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: EnumUserRoleEnumFieldUpdateOperationsInput | $Enums.UserRoleEnum
    telegramDataId?: NullableStringFieldUpdateOperationsInput | string | null
    languageId?: StringFieldUpdateOperationsInput | string
    payments?: PaymentsUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralsUncheckedUpdateManyWithoutReferralNestedInput
    inviters?: ReferralsUncheckedUpdateManyWithoutInviterNestedInput
    subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalsUncheckedUpdateManyWithoutUserNestedInput
    adsViews?: AdsViewsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionsUpsertWithWhereUniqueWithoutBalanceInput = {
    where: TransactionsWhereUniqueInput
    update: XOR<TransactionsUpdateWithoutBalanceInput, TransactionsUncheckedUpdateWithoutBalanceInput>
    create: XOR<TransactionsCreateWithoutBalanceInput, TransactionsUncheckedCreateWithoutBalanceInput>
  }

  export type TransactionsUpdateWithWhereUniqueWithoutBalanceInput = {
    where: TransactionsWhereUniqueInput
    data: XOR<TransactionsUpdateWithoutBalanceInput, TransactionsUncheckedUpdateWithoutBalanceInput>
  }

  export type TransactionsUpdateManyWithWhereWithoutBalanceInput = {
    where: TransactionsScalarWhereInput
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyWithoutBalanceInput>
  }

  export type TransactionsScalarWhereInput = {
    AND?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
    OR?: TransactionsScalarWhereInput[]
    NOT?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
    id?: StringFilter<"Transactions"> | string
    amount?: FloatFilter<"Transactions"> | number
    isHold?: BoolFilter<"Transactions"> | boolean
    type?: EnumTransactionTypeEnumFilter<"Transactions"> | $Enums.TransactionTypeEnum
    reason?: EnumTransactionReasonEnumFilter<"Transactions"> | $Enums.TransactionReasonEnum
    balanceType?: EnumBalanceTypeEnumFilter<"Transactions"> | $Enums.BalanceTypeEnum
    createdAt?: DateTimeFilter<"Transactions"> | Date | string
    updatedAt?: DateTimeFilter<"Transactions"> | Date | string
    holdExpiredAt?: DateTimeNullableFilter<"Transactions"> | Date | string | null
    balanceId?: StringFilter<"Transactions"> | string
  }

  export type UsersCreateWithoutSubscriptionsInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    role?: RolesCreateNestedOneWithoutUsersInput
    payments?: PaymentsCreateNestedManyWithoutUserInput
    referrals?: ReferralsCreateNestedManyWithoutReferralInput
    inviters?: ReferralsCreateNestedManyWithoutInviterInput
    telegramData?: UserTelegramDataCreateNestedOneWithoutUserInput
    balance?: UserBalanceCreateNestedOneWithoutUserInput
    language: LanguageCreateNestedOneWithoutUsersInput
    withdrawals?: WithdrawalsCreateNestedManyWithoutUserInput
    adsViews?: AdsViewsCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    roleId?: $Enums.UserRoleEnum
    telegramDataId?: string | null
    balanceId?: string | null
    languageId: string
    payments?: PaymentsUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralsUncheckedCreateNestedManyWithoutReferralInput
    inviters?: ReferralsUncheckedCreateNestedManyWithoutInviterInput
    withdrawals?: WithdrawalsUncheckedCreateNestedManyWithoutUserInput
    adsViews?: AdsViewsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutSubscriptionsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutSubscriptionsInput, UsersUncheckedCreateWithoutSubscriptionsInput>
  }

  export type PaymentsCreateWithoutSubscriptionInput = {
    id?: string
    status?: $Enums.PaymentStatusEnum
    amount?: string
    exchangeRate?: string
    token: string
    linkPay?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutPaymentsInput
    currency: CurrencyCreateNestedOneWithoutPaymentsInput
    method: PaymentMethodsCreateNestedOneWithoutPaymentsInput
    transacrion?: TransactionsCreateNestedOneWithoutPaymentInput
  }

  export type PaymentsUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    status?: $Enums.PaymentStatusEnum
    amount?: string
    exchangeRate?: string
    token: string
    linkPay?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    currencyKey: $Enums.CurrencyEnum
    methodKey: $Enums.PaymentMethodEnum
    transactionId?: string | null
  }

  export type PaymentsCreateOrConnectWithoutSubscriptionInput = {
    where: PaymentsWhereUniqueInput
    create: XOR<PaymentsCreateWithoutSubscriptionInput, PaymentsUncheckedCreateWithoutSubscriptionInput>
  }

  export type PaymentsCreateManySubscriptionInputEnvelope = {
    data: PaymentsCreateManySubscriptionInput | PaymentsCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithoutSubscriptionsInput = {
    update: XOR<UsersUpdateWithoutSubscriptionsInput, UsersUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<UsersCreateWithoutSubscriptionsInput, UsersUncheckedCreateWithoutSubscriptionsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutSubscriptionsInput, UsersUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UsersUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RolesUpdateOneRequiredWithoutUsersNestedInput
    payments?: PaymentsUpdateManyWithoutUserNestedInput
    referrals?: ReferralsUpdateManyWithoutReferralNestedInput
    inviters?: ReferralsUpdateManyWithoutInviterNestedInput
    telegramData?: UserTelegramDataUpdateOneWithoutUserNestedInput
    balance?: UserBalanceUpdateOneWithoutUserNestedInput
    language?: LanguageUpdateOneRequiredWithoutUsersNestedInput
    withdrawals?: WithdrawalsUpdateManyWithoutUserNestedInput
    adsViews?: AdsViewsUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: EnumUserRoleEnumFieldUpdateOperationsInput | $Enums.UserRoleEnum
    telegramDataId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceId?: NullableStringFieldUpdateOperationsInput | string | null
    languageId?: StringFieldUpdateOperationsInput | string
    payments?: PaymentsUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralsUncheckedUpdateManyWithoutReferralNestedInput
    inviters?: ReferralsUncheckedUpdateManyWithoutInviterNestedInput
    withdrawals?: WithdrawalsUncheckedUpdateManyWithoutUserNestedInput
    adsViews?: AdsViewsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PaymentsUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: PaymentsWhereUniqueInput
    update: XOR<PaymentsUpdateWithoutSubscriptionInput, PaymentsUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<PaymentsCreateWithoutSubscriptionInput, PaymentsUncheckedCreateWithoutSubscriptionInput>
  }

  export type PaymentsUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: PaymentsWhereUniqueInput
    data: XOR<PaymentsUpdateWithoutSubscriptionInput, PaymentsUncheckedUpdateWithoutSubscriptionInput>
  }

  export type PaymentsUpdateManyWithWhereWithoutSubscriptionInput = {
    where: PaymentsScalarWhereInput
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type UsersCreateWithoutRoleInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    payments?: PaymentsCreateNestedManyWithoutUserInput
    referrals?: ReferralsCreateNestedManyWithoutReferralInput
    inviters?: ReferralsCreateNestedManyWithoutInviterInput
    telegramData?: UserTelegramDataCreateNestedOneWithoutUserInput
    balance?: UserBalanceCreateNestedOneWithoutUserInput
    language: LanguageCreateNestedOneWithoutUsersInput
    subscriptions?: SubscriptionsCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalsCreateNestedManyWithoutUserInput
    adsViews?: AdsViewsCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutRoleInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    telegramDataId?: string | null
    balanceId?: string | null
    languageId: string
    payments?: PaymentsUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralsUncheckedCreateNestedManyWithoutReferralInput
    inviters?: ReferralsUncheckedCreateNestedManyWithoutInviterInput
    subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalsUncheckedCreateNestedManyWithoutUserInput
    adsViews?: AdsViewsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutRoleInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutRoleInput, UsersUncheckedCreateWithoutRoleInput>
  }

  export type UsersCreateManyRoleInputEnvelope = {
    data: UsersCreateManyRoleInput | UsersCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithWhereUniqueWithoutRoleInput = {
    where: UsersWhereUniqueInput
    update: XOR<UsersUpdateWithoutRoleInput, UsersUncheckedUpdateWithoutRoleInput>
    create: XOR<UsersCreateWithoutRoleInput, UsersUncheckedCreateWithoutRoleInput>
  }

  export type UsersUpdateWithWhereUniqueWithoutRoleInput = {
    where: UsersWhereUniqueInput
    data: XOR<UsersUpdateWithoutRoleInput, UsersUncheckedUpdateWithoutRoleInput>
  }

  export type UsersUpdateManyWithWhereWithoutRoleInput = {
    where: UsersScalarWhereInput
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyWithoutRoleInput>
  }

  export type UsersScalarWhereInput = {
    AND?: UsersScalarWhereInput | UsersScalarWhereInput[]
    OR?: UsersScalarWhereInput[]
    NOT?: UsersScalarWhereInput | UsersScalarWhereInput[]
    id?: StringFilter<"Users"> | string
    telegramId?: StringFilter<"Users"> | string
    tonWallet?: StringNullableFilter<"Users"> | string | null
    isFreePlanAvailable?: BoolFilter<"Users"> | boolean
    isBanned?: BoolFilter<"Users"> | boolean
    isDeleted?: BoolFilter<"Users"> | boolean
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    lastStartedAt?: DateTimeNullableFilter<"Users"> | Date | string | null
    banExpiredAt?: DateTimeNullableFilter<"Users"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Users"> | Date | string | null
    roleId?: EnumUserRoleEnumFilter<"Users"> | $Enums.UserRoleEnum
    telegramDataId?: StringNullableFilter<"Users"> | string | null
    balanceId?: StringNullableFilter<"Users"> | string | null
    languageId?: StringFilter<"Users"> | string
  }

  export type UsersCreateWithoutLanguageInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    role?: RolesCreateNestedOneWithoutUsersInput
    payments?: PaymentsCreateNestedManyWithoutUserInput
    referrals?: ReferralsCreateNestedManyWithoutReferralInput
    inviters?: ReferralsCreateNestedManyWithoutInviterInput
    telegramData?: UserTelegramDataCreateNestedOneWithoutUserInput
    balance?: UserBalanceCreateNestedOneWithoutUserInput
    subscriptions?: SubscriptionsCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalsCreateNestedManyWithoutUserInput
    adsViews?: AdsViewsCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutLanguageInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    roleId?: $Enums.UserRoleEnum
    telegramDataId?: string | null
    balanceId?: string | null
    payments?: PaymentsUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralsUncheckedCreateNestedManyWithoutReferralInput
    inviters?: ReferralsUncheckedCreateNestedManyWithoutInviterInput
    subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalsUncheckedCreateNestedManyWithoutUserInput
    adsViews?: AdsViewsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutLanguageInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutLanguageInput, UsersUncheckedCreateWithoutLanguageInput>
  }

  export type UsersCreateManyLanguageInputEnvelope = {
    data: UsersCreateManyLanguageInput | UsersCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithWhereUniqueWithoutLanguageInput = {
    where: UsersWhereUniqueInput
    update: XOR<UsersUpdateWithoutLanguageInput, UsersUncheckedUpdateWithoutLanguageInput>
    create: XOR<UsersCreateWithoutLanguageInput, UsersUncheckedCreateWithoutLanguageInput>
  }

  export type UsersUpdateWithWhereUniqueWithoutLanguageInput = {
    where: UsersWhereUniqueInput
    data: XOR<UsersUpdateWithoutLanguageInput, UsersUncheckedUpdateWithoutLanguageInput>
  }

  export type UsersUpdateManyWithWhereWithoutLanguageInput = {
    where: UsersScalarWhereInput
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyWithoutLanguageInput>
  }

  export type PaymentsCreateWithoutCurrencyInput = {
    id?: string
    status?: $Enums.PaymentStatusEnum
    amount?: string
    exchangeRate?: string
    token: string
    linkPay?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutPaymentsInput
    Subscription?: SubscriptionsCreateNestedOneWithoutPaymentsInput
    method: PaymentMethodsCreateNestedOneWithoutPaymentsInput
    transacrion?: TransactionsCreateNestedOneWithoutPaymentInput
  }

  export type PaymentsUncheckedCreateWithoutCurrencyInput = {
    id?: string
    status?: $Enums.PaymentStatusEnum
    amount?: string
    exchangeRate?: string
    token: string
    linkPay?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    SubscriptionId?: string | null
    methodKey: $Enums.PaymentMethodEnum
    transactionId?: string | null
  }

  export type PaymentsCreateOrConnectWithoutCurrencyInput = {
    where: PaymentsWhereUniqueInput
    create: XOR<PaymentsCreateWithoutCurrencyInput, PaymentsUncheckedCreateWithoutCurrencyInput>
  }

  export type PaymentsCreateManyCurrencyInputEnvelope = {
    data: PaymentsCreateManyCurrencyInput | PaymentsCreateManyCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type PaymentMethodsCreateWithoutCurrencyInput = {
    key: $Enums.PaymentMethodEnum
    name: string
    isActive?: boolean
    isTonBlockchain?: boolean
    tonSmartContractAddress?: string | null
    minAmount?: number
    maxAmount?: number
    commission?: number
    isPlusCommission?: boolean
    type?: $Enums.PaymentMethodTypeEnum
    system?: $Enums.PaymentSystemEnum
    payments?: PaymentsCreateNestedManyWithoutMethodInput
  }

  export type PaymentMethodsUncheckedCreateWithoutCurrencyInput = {
    key: $Enums.PaymentMethodEnum
    name: string
    isActive?: boolean
    isTonBlockchain?: boolean
    tonSmartContractAddress?: string | null
    minAmount?: number
    maxAmount?: number
    commission?: number
    isPlusCommission?: boolean
    type?: $Enums.PaymentMethodTypeEnum
    system?: $Enums.PaymentSystemEnum
    payments?: PaymentsUncheckedCreateNestedManyWithoutMethodInput
  }

  export type PaymentMethodsCreateOrConnectWithoutCurrencyInput = {
    where: PaymentMethodsWhereUniqueInput
    create: XOR<PaymentMethodsCreateWithoutCurrencyInput, PaymentMethodsUncheckedCreateWithoutCurrencyInput>
  }

  export type PaymentMethodsCreateManyCurrencyInputEnvelope = {
    data: PaymentMethodsCreateManyCurrencyInput | PaymentMethodsCreateManyCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type PaymentsUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: PaymentsWhereUniqueInput
    update: XOR<PaymentsUpdateWithoutCurrencyInput, PaymentsUncheckedUpdateWithoutCurrencyInput>
    create: XOR<PaymentsCreateWithoutCurrencyInput, PaymentsUncheckedCreateWithoutCurrencyInput>
  }

  export type PaymentsUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: PaymentsWhereUniqueInput
    data: XOR<PaymentsUpdateWithoutCurrencyInput, PaymentsUncheckedUpdateWithoutCurrencyInput>
  }

  export type PaymentsUpdateManyWithWhereWithoutCurrencyInput = {
    where: PaymentsScalarWhereInput
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type PaymentMethodsUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: PaymentMethodsWhereUniqueInput
    update: XOR<PaymentMethodsUpdateWithoutCurrencyInput, PaymentMethodsUncheckedUpdateWithoutCurrencyInput>
    create: XOR<PaymentMethodsCreateWithoutCurrencyInput, PaymentMethodsUncheckedCreateWithoutCurrencyInput>
  }

  export type PaymentMethodsUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: PaymentMethodsWhereUniqueInput
    data: XOR<PaymentMethodsUpdateWithoutCurrencyInput, PaymentMethodsUncheckedUpdateWithoutCurrencyInput>
  }

  export type PaymentMethodsUpdateManyWithWhereWithoutCurrencyInput = {
    where: PaymentMethodsScalarWhereInput
    data: XOR<PaymentMethodsUpdateManyMutationInput, PaymentMethodsUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type PaymentMethodsScalarWhereInput = {
    AND?: PaymentMethodsScalarWhereInput | PaymentMethodsScalarWhereInput[]
    OR?: PaymentMethodsScalarWhereInput[]
    NOT?: PaymentMethodsScalarWhereInput | PaymentMethodsScalarWhereInput[]
    key?: EnumPaymentMethodEnumFilter<"PaymentMethods"> | $Enums.PaymentMethodEnum
    name?: StringFilter<"PaymentMethods"> | string
    isActive?: BoolFilter<"PaymentMethods"> | boolean
    isTonBlockchain?: BoolFilter<"PaymentMethods"> | boolean
    tonSmartContractAddress?: StringNullableFilter<"PaymentMethods"> | string | null
    minAmount?: FloatFilter<"PaymentMethods"> | number
    maxAmount?: FloatFilter<"PaymentMethods"> | number
    commission?: FloatFilter<"PaymentMethods"> | number
    isPlusCommission?: BoolFilter<"PaymentMethods"> | boolean
    type?: EnumPaymentMethodTypeEnumFilter<"PaymentMethods"> | $Enums.PaymentMethodTypeEnum
    system?: EnumPaymentSystemEnumFilter<"PaymentMethods"> | $Enums.PaymentSystemEnum
    currencyKey?: EnumCurrencyEnumFilter<"PaymentMethods"> | $Enums.CurrencyEnum
  }

  export type UserBalanceCreateWithoutTransactionsInput = {
    id?: string
    paymentBalance?: number
    holdBalance?: number
    totalEarnedWithdrawalBalance?: number
    withdrawalBalance?: number
    isUseWithdrawalBalance?: boolean
    updatedAt?: Date | string
    user?: UsersCreateNestedOneWithoutBalanceInput
  }

  export type UserBalanceUncheckedCreateWithoutTransactionsInput = {
    id?: string
    paymentBalance?: number
    holdBalance?: number
    totalEarnedWithdrawalBalance?: number
    withdrawalBalance?: number
    isUseWithdrawalBalance?: boolean
    updatedAt?: Date | string
    user?: UsersUncheckedCreateNestedOneWithoutBalanceInput
  }

  export type UserBalanceCreateOrConnectWithoutTransactionsInput = {
    where: UserBalanceWhereUniqueInput
    create: XOR<UserBalanceCreateWithoutTransactionsInput, UserBalanceUncheckedCreateWithoutTransactionsInput>
  }

  export type WithdrawalsCreateWithoutTransacrionInput = {
    id?: string
    status?: $Enums.WithdrawalStatusEnum
    amountStars?: number
    amountUSD?: number
    amountTON?: number
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutWithdrawalsInput
  }

  export type WithdrawalsUncheckedCreateWithoutTransacrionInput = {
    id?: string
    status?: $Enums.WithdrawalStatusEnum
    amountStars?: number
    amountUSD?: number
    amountTON?: number
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type WithdrawalsCreateOrConnectWithoutTransacrionInput = {
    where: WithdrawalsWhereUniqueInput
    create: XOR<WithdrawalsCreateWithoutTransacrionInput, WithdrawalsUncheckedCreateWithoutTransacrionInput>
  }

  export type PaymentsCreateWithoutTransacrionInput = {
    id?: string
    status?: $Enums.PaymentStatusEnum
    amount?: string
    exchangeRate?: string
    token: string
    linkPay?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutPaymentsInput
    currency: CurrencyCreateNestedOneWithoutPaymentsInput
    Subscription?: SubscriptionsCreateNestedOneWithoutPaymentsInput
    method: PaymentMethodsCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentsUncheckedCreateWithoutTransacrionInput = {
    id?: string
    status?: $Enums.PaymentStatusEnum
    amount?: string
    exchangeRate?: string
    token: string
    linkPay?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    currencyKey: $Enums.CurrencyEnum
    SubscriptionId?: string | null
    methodKey: $Enums.PaymentMethodEnum
  }

  export type PaymentsCreateOrConnectWithoutTransacrionInput = {
    where: PaymentsWhereUniqueInput
    create: XOR<PaymentsCreateWithoutTransacrionInput, PaymentsUncheckedCreateWithoutTransacrionInput>
  }

  export type UserBalanceUpsertWithoutTransactionsInput = {
    update: XOR<UserBalanceUpdateWithoutTransactionsInput, UserBalanceUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserBalanceCreateWithoutTransactionsInput, UserBalanceUncheckedCreateWithoutTransactionsInput>
    where?: UserBalanceWhereInput
  }

  export type UserBalanceUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserBalanceWhereInput
    data: XOR<UserBalanceUpdateWithoutTransactionsInput, UserBalanceUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserBalanceUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentBalance?: FloatFieldUpdateOperationsInput | number
    holdBalance?: FloatFieldUpdateOperationsInput | number
    totalEarnedWithdrawalBalance?: FloatFieldUpdateOperationsInput | number
    withdrawalBalance?: FloatFieldUpdateOperationsInput | number
    isUseWithdrawalBalance?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneWithoutBalanceNestedInput
  }

  export type UserBalanceUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentBalance?: FloatFieldUpdateOperationsInput | number
    holdBalance?: FloatFieldUpdateOperationsInput | number
    totalEarnedWithdrawalBalance?: FloatFieldUpdateOperationsInput | number
    withdrawalBalance?: FloatFieldUpdateOperationsInput | number
    isUseWithdrawalBalance?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUncheckedUpdateOneWithoutBalanceNestedInput
  }

  export type WithdrawalsUpsertWithoutTransacrionInput = {
    update: XOR<WithdrawalsUpdateWithoutTransacrionInput, WithdrawalsUncheckedUpdateWithoutTransacrionInput>
    create: XOR<WithdrawalsCreateWithoutTransacrionInput, WithdrawalsUncheckedCreateWithoutTransacrionInput>
    where?: WithdrawalsWhereInput
  }

  export type WithdrawalsUpdateToOneWithWhereWithoutTransacrionInput = {
    where?: WithdrawalsWhereInput
    data: XOR<WithdrawalsUpdateWithoutTransacrionInput, WithdrawalsUncheckedUpdateWithoutTransacrionInput>
  }

  export type WithdrawalsUpdateWithoutTransacrionInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWithdrawalStatusEnumFieldUpdateOperationsInput | $Enums.WithdrawalStatusEnum
    amountStars?: FloatFieldUpdateOperationsInput | number
    amountUSD?: FloatFieldUpdateOperationsInput | number
    amountTON?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutWithdrawalsNestedInput
  }

  export type WithdrawalsUncheckedUpdateWithoutTransacrionInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWithdrawalStatusEnumFieldUpdateOperationsInput | $Enums.WithdrawalStatusEnum
    amountStars?: FloatFieldUpdateOperationsInput | number
    amountUSD?: FloatFieldUpdateOperationsInput | number
    amountTON?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentsUpsertWithoutTransacrionInput = {
    update: XOR<PaymentsUpdateWithoutTransacrionInput, PaymentsUncheckedUpdateWithoutTransacrionInput>
    create: XOR<PaymentsCreateWithoutTransacrionInput, PaymentsUncheckedCreateWithoutTransacrionInput>
    where?: PaymentsWhereInput
  }

  export type PaymentsUpdateToOneWithWhereWithoutTransacrionInput = {
    where?: PaymentsWhereInput
    data: XOR<PaymentsUpdateWithoutTransacrionInput, PaymentsUncheckedUpdateWithoutTransacrionInput>
  }

  export type PaymentsUpdateWithoutTransacrionInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusEnumFieldUpdateOperationsInput | $Enums.PaymentStatusEnum
    amount?: StringFieldUpdateOperationsInput | string
    exchangeRate?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    linkPay?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutPaymentsNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutPaymentsNestedInput
    Subscription?: SubscriptionsUpdateOneWithoutPaymentsNestedInput
    method?: PaymentMethodsUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentsUncheckedUpdateWithoutTransacrionInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusEnumFieldUpdateOperationsInput | $Enums.PaymentStatusEnum
    amount?: StringFieldUpdateOperationsInput | string
    exchangeRate?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    linkPay?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    currencyKey?: EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
    SubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    methodKey?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
  }

  export type UsersCreateWithoutWithdrawalsInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    role?: RolesCreateNestedOneWithoutUsersInput
    payments?: PaymentsCreateNestedManyWithoutUserInput
    referrals?: ReferralsCreateNestedManyWithoutReferralInput
    inviters?: ReferralsCreateNestedManyWithoutInviterInput
    telegramData?: UserTelegramDataCreateNestedOneWithoutUserInput
    balance?: UserBalanceCreateNestedOneWithoutUserInput
    language: LanguageCreateNestedOneWithoutUsersInput
    subscriptions?: SubscriptionsCreateNestedManyWithoutUserInput
    adsViews?: AdsViewsCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutWithdrawalsInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    roleId?: $Enums.UserRoleEnum
    telegramDataId?: string | null
    balanceId?: string | null
    languageId: string
    payments?: PaymentsUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralsUncheckedCreateNestedManyWithoutReferralInput
    inviters?: ReferralsUncheckedCreateNestedManyWithoutInviterInput
    subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUserInput
    adsViews?: AdsViewsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutWithdrawalsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutWithdrawalsInput, UsersUncheckedCreateWithoutWithdrawalsInput>
  }

  export type TransactionsCreateWithoutWithdrawalInput = {
    id?: string
    amount?: number
    isHold?: boolean
    type?: $Enums.TransactionTypeEnum
    reason?: $Enums.TransactionReasonEnum
    balanceType?: $Enums.BalanceTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiredAt?: Date | string | null
    balance: UserBalanceCreateNestedOneWithoutTransactionsInput
    payment?: PaymentsCreateNestedOneWithoutTransacrionInput
  }

  export type TransactionsUncheckedCreateWithoutWithdrawalInput = {
    id?: string
    amount?: number
    isHold?: boolean
    type?: $Enums.TransactionTypeEnum
    reason?: $Enums.TransactionReasonEnum
    balanceType?: $Enums.BalanceTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiredAt?: Date | string | null
    balanceId: string
    payment?: PaymentsUncheckedCreateNestedOneWithoutTransacrionInput
  }

  export type TransactionsCreateOrConnectWithoutWithdrawalInput = {
    where: TransactionsWhereUniqueInput
    create: XOR<TransactionsCreateWithoutWithdrawalInput, TransactionsUncheckedCreateWithoutWithdrawalInput>
  }

  export type UsersUpsertWithoutWithdrawalsInput = {
    update: XOR<UsersUpdateWithoutWithdrawalsInput, UsersUncheckedUpdateWithoutWithdrawalsInput>
    create: XOR<UsersCreateWithoutWithdrawalsInput, UsersUncheckedCreateWithoutWithdrawalsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutWithdrawalsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutWithdrawalsInput, UsersUncheckedUpdateWithoutWithdrawalsInput>
  }

  export type UsersUpdateWithoutWithdrawalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RolesUpdateOneRequiredWithoutUsersNestedInput
    payments?: PaymentsUpdateManyWithoutUserNestedInput
    referrals?: ReferralsUpdateManyWithoutReferralNestedInput
    inviters?: ReferralsUpdateManyWithoutInviterNestedInput
    telegramData?: UserTelegramDataUpdateOneWithoutUserNestedInput
    balance?: UserBalanceUpdateOneWithoutUserNestedInput
    language?: LanguageUpdateOneRequiredWithoutUsersNestedInput
    subscriptions?: SubscriptionsUpdateManyWithoutUserNestedInput
    adsViews?: AdsViewsUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutWithdrawalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: EnumUserRoleEnumFieldUpdateOperationsInput | $Enums.UserRoleEnum
    telegramDataId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceId?: NullableStringFieldUpdateOperationsInput | string | null
    languageId?: StringFieldUpdateOperationsInput | string
    payments?: PaymentsUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralsUncheckedUpdateManyWithoutReferralNestedInput
    inviters?: ReferralsUncheckedUpdateManyWithoutInviterNestedInput
    subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUserNestedInput
    adsViews?: AdsViewsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionsUpsertWithoutWithdrawalInput = {
    update: XOR<TransactionsUpdateWithoutWithdrawalInput, TransactionsUncheckedUpdateWithoutWithdrawalInput>
    create: XOR<TransactionsCreateWithoutWithdrawalInput, TransactionsUncheckedCreateWithoutWithdrawalInput>
    where?: TransactionsWhereInput
  }

  export type TransactionsUpdateToOneWithWhereWithoutWithdrawalInput = {
    where?: TransactionsWhereInput
    data: XOR<TransactionsUpdateWithoutWithdrawalInput, TransactionsUncheckedUpdateWithoutWithdrawalInput>
  }

  export type TransactionsUpdateWithoutWithdrawalInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isHold?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumTransactionTypeEnumFieldUpdateOperationsInput | $Enums.TransactionTypeEnum
    reason?: EnumTransactionReasonEnumFieldUpdateOperationsInput | $Enums.TransactionReasonEnum
    balanceType?: EnumBalanceTypeEnumFieldUpdateOperationsInput | $Enums.BalanceTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: UserBalanceUpdateOneRequiredWithoutTransactionsNestedInput
    payment?: PaymentsUpdateOneWithoutTransacrionNestedInput
  }

  export type TransactionsUncheckedUpdateWithoutWithdrawalInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isHold?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumTransactionTypeEnumFieldUpdateOperationsInput | $Enums.TransactionTypeEnum
    reason?: EnumTransactionReasonEnumFieldUpdateOperationsInput | $Enums.TransactionReasonEnum
    balanceType?: EnumBalanceTypeEnumFieldUpdateOperationsInput | $Enums.BalanceTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balanceId?: StringFieldUpdateOperationsInput | string
    payment?: PaymentsUncheckedUpdateOneWithoutTransacrionNestedInput
  }

  export type UsersCreateWithoutPaymentsInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    role?: RolesCreateNestedOneWithoutUsersInput
    referrals?: ReferralsCreateNestedManyWithoutReferralInput
    inviters?: ReferralsCreateNestedManyWithoutInviterInput
    telegramData?: UserTelegramDataCreateNestedOneWithoutUserInput
    balance?: UserBalanceCreateNestedOneWithoutUserInput
    language: LanguageCreateNestedOneWithoutUsersInput
    subscriptions?: SubscriptionsCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalsCreateNestedManyWithoutUserInput
    adsViews?: AdsViewsCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutPaymentsInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    roleId?: $Enums.UserRoleEnum
    telegramDataId?: string | null
    balanceId?: string | null
    languageId: string
    referrals?: ReferralsUncheckedCreateNestedManyWithoutReferralInput
    inviters?: ReferralsUncheckedCreateNestedManyWithoutInviterInput
    subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalsUncheckedCreateNestedManyWithoutUserInput
    adsViews?: AdsViewsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutPaymentsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutPaymentsInput, UsersUncheckedCreateWithoutPaymentsInput>
  }

  export type CurrencyCreateWithoutPaymentsInput = {
    key: $Enums.CurrencyEnum
    name: string
    symbol: string
    rate?: number
    coinmarketcapUCID?: string | null
    updatedAt?: Date | string
    paymentMethods?: PaymentMethodsCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutPaymentsInput = {
    key: $Enums.CurrencyEnum
    name: string
    symbol: string
    rate?: number
    coinmarketcapUCID?: string | null
    updatedAt?: Date | string
    paymentMethods?: PaymentMethodsUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutPaymentsInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutPaymentsInput, CurrencyUncheckedCreateWithoutPaymentsInput>
  }

  export type SubscriptionsCreateWithoutPaymentsInput = {
    id?: string
    username: string
    isActive?: boolean
    isAutoRenewal?: boolean
    token: string
    period?: $Enums.SubscriptionPeriodEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    expiredAt?: Date | string | null
    user: UsersCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionsUncheckedCreateWithoutPaymentsInput = {
    id?: string
    username: string
    isActive?: boolean
    isAutoRenewal?: boolean
    token: string
    period?: $Enums.SubscriptionPeriodEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    expiredAt?: Date | string | null
    userId: string
  }

  export type SubscriptionsCreateOrConnectWithoutPaymentsInput = {
    where: SubscriptionsWhereUniqueInput
    create: XOR<SubscriptionsCreateWithoutPaymentsInput, SubscriptionsUncheckedCreateWithoutPaymentsInput>
  }

  export type PaymentMethodsCreateWithoutPaymentsInput = {
    key: $Enums.PaymentMethodEnum
    name: string
    isActive?: boolean
    isTonBlockchain?: boolean
    tonSmartContractAddress?: string | null
    minAmount?: number
    maxAmount?: number
    commission?: number
    isPlusCommission?: boolean
    type?: $Enums.PaymentMethodTypeEnum
    system?: $Enums.PaymentSystemEnum
    currency: CurrencyCreateNestedOneWithoutPaymentMethodsInput
  }

  export type PaymentMethodsUncheckedCreateWithoutPaymentsInput = {
    key: $Enums.PaymentMethodEnum
    name: string
    isActive?: boolean
    isTonBlockchain?: boolean
    tonSmartContractAddress?: string | null
    minAmount?: number
    maxAmount?: number
    commission?: number
    isPlusCommission?: boolean
    type?: $Enums.PaymentMethodTypeEnum
    system?: $Enums.PaymentSystemEnum
    currencyKey: $Enums.CurrencyEnum
  }

  export type PaymentMethodsCreateOrConnectWithoutPaymentsInput = {
    where: PaymentMethodsWhereUniqueInput
    create: XOR<PaymentMethodsCreateWithoutPaymentsInput, PaymentMethodsUncheckedCreateWithoutPaymentsInput>
  }

  export type TransactionsCreateWithoutPaymentInput = {
    id?: string
    amount?: number
    isHold?: boolean
    type?: $Enums.TransactionTypeEnum
    reason?: $Enums.TransactionReasonEnum
    balanceType?: $Enums.BalanceTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiredAt?: Date | string | null
    balance: UserBalanceCreateNestedOneWithoutTransactionsInput
    withdrawal?: WithdrawalsCreateNestedOneWithoutTransacrionInput
  }

  export type TransactionsUncheckedCreateWithoutPaymentInput = {
    id?: string
    amount?: number
    isHold?: boolean
    type?: $Enums.TransactionTypeEnum
    reason?: $Enums.TransactionReasonEnum
    balanceType?: $Enums.BalanceTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiredAt?: Date | string | null
    balanceId: string
    withdrawal?: WithdrawalsUncheckedCreateNestedOneWithoutTransacrionInput
  }

  export type TransactionsCreateOrConnectWithoutPaymentInput = {
    where: TransactionsWhereUniqueInput
    create: XOR<TransactionsCreateWithoutPaymentInput, TransactionsUncheckedCreateWithoutPaymentInput>
  }

  export type UsersUpsertWithoutPaymentsInput = {
    update: XOR<UsersUpdateWithoutPaymentsInput, UsersUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UsersCreateWithoutPaymentsInput, UsersUncheckedCreateWithoutPaymentsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutPaymentsInput, UsersUncheckedUpdateWithoutPaymentsInput>
  }

  export type UsersUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RolesUpdateOneRequiredWithoutUsersNestedInput
    referrals?: ReferralsUpdateManyWithoutReferralNestedInput
    inviters?: ReferralsUpdateManyWithoutInviterNestedInput
    telegramData?: UserTelegramDataUpdateOneWithoutUserNestedInput
    balance?: UserBalanceUpdateOneWithoutUserNestedInput
    language?: LanguageUpdateOneRequiredWithoutUsersNestedInput
    subscriptions?: SubscriptionsUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalsUpdateManyWithoutUserNestedInput
    adsViews?: AdsViewsUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: EnumUserRoleEnumFieldUpdateOperationsInput | $Enums.UserRoleEnum
    telegramDataId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceId?: NullableStringFieldUpdateOperationsInput | string | null
    languageId?: StringFieldUpdateOperationsInput | string
    referrals?: ReferralsUncheckedUpdateManyWithoutReferralNestedInput
    inviters?: ReferralsUncheckedUpdateManyWithoutInviterNestedInput
    subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalsUncheckedUpdateManyWithoutUserNestedInput
    adsViews?: AdsViewsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CurrencyUpsertWithoutPaymentsInput = {
    update: XOR<CurrencyUpdateWithoutPaymentsInput, CurrencyUncheckedUpdateWithoutPaymentsInput>
    create: XOR<CurrencyCreateWithoutPaymentsInput, CurrencyUncheckedCreateWithoutPaymentsInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutPaymentsInput, CurrencyUncheckedUpdateWithoutPaymentsInput>
  }

  export type CurrencyUpdateWithoutPaymentsInput = {
    key?: EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    coinmarketcapUCID?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: PaymentMethodsUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateWithoutPaymentsInput = {
    key?: EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    coinmarketcapUCID?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: PaymentMethodsUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type SubscriptionsUpsertWithoutPaymentsInput = {
    update: XOR<SubscriptionsUpdateWithoutPaymentsInput, SubscriptionsUncheckedUpdateWithoutPaymentsInput>
    create: XOR<SubscriptionsCreateWithoutPaymentsInput, SubscriptionsUncheckedCreateWithoutPaymentsInput>
    where?: SubscriptionsWhereInput
  }

  export type SubscriptionsUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: SubscriptionsWhereInput
    data: XOR<SubscriptionsUpdateWithoutPaymentsInput, SubscriptionsUncheckedUpdateWithoutPaymentsInput>
  }

  export type SubscriptionsUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAutoRenewal?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    period?: EnumSubscriptionPeriodEnumFieldUpdateOperationsInput | $Enums.SubscriptionPeriodEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UsersUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionsUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAutoRenewal?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    period?: EnumSubscriptionPeriodEnumFieldUpdateOperationsInput | $Enums.SubscriptionPeriodEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentMethodsUpsertWithoutPaymentsInput = {
    update: XOR<PaymentMethodsUpdateWithoutPaymentsInput, PaymentMethodsUncheckedUpdateWithoutPaymentsInput>
    create: XOR<PaymentMethodsCreateWithoutPaymentsInput, PaymentMethodsUncheckedCreateWithoutPaymentsInput>
    where?: PaymentMethodsWhereInput
  }

  export type PaymentMethodsUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: PaymentMethodsWhereInput
    data: XOR<PaymentMethodsUpdateWithoutPaymentsInput, PaymentMethodsUncheckedUpdateWithoutPaymentsInput>
  }

  export type PaymentMethodsUpdateWithoutPaymentsInput = {
    key?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTonBlockchain?: BoolFieldUpdateOperationsInput | boolean
    tonSmartContractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: FloatFieldUpdateOperationsInput | number
    maxAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    isPlusCommission?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumPaymentMethodTypeEnumFieldUpdateOperationsInput | $Enums.PaymentMethodTypeEnum
    system?: EnumPaymentSystemEnumFieldUpdateOperationsInput | $Enums.PaymentSystemEnum
    currency?: CurrencyUpdateOneRequiredWithoutPaymentMethodsNestedInput
  }

  export type PaymentMethodsUncheckedUpdateWithoutPaymentsInput = {
    key?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTonBlockchain?: BoolFieldUpdateOperationsInput | boolean
    tonSmartContractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: FloatFieldUpdateOperationsInput | number
    maxAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    isPlusCommission?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumPaymentMethodTypeEnumFieldUpdateOperationsInput | $Enums.PaymentMethodTypeEnum
    system?: EnumPaymentSystemEnumFieldUpdateOperationsInput | $Enums.PaymentSystemEnum
    currencyKey?: EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
  }

  export type TransactionsUpsertWithoutPaymentInput = {
    update: XOR<TransactionsUpdateWithoutPaymentInput, TransactionsUncheckedUpdateWithoutPaymentInput>
    create: XOR<TransactionsCreateWithoutPaymentInput, TransactionsUncheckedCreateWithoutPaymentInput>
    where?: TransactionsWhereInput
  }

  export type TransactionsUpdateToOneWithWhereWithoutPaymentInput = {
    where?: TransactionsWhereInput
    data: XOR<TransactionsUpdateWithoutPaymentInput, TransactionsUncheckedUpdateWithoutPaymentInput>
  }

  export type TransactionsUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isHold?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumTransactionTypeEnumFieldUpdateOperationsInput | $Enums.TransactionTypeEnum
    reason?: EnumTransactionReasonEnumFieldUpdateOperationsInput | $Enums.TransactionReasonEnum
    balanceType?: EnumBalanceTypeEnumFieldUpdateOperationsInput | $Enums.BalanceTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: UserBalanceUpdateOneRequiredWithoutTransactionsNestedInput
    withdrawal?: WithdrawalsUpdateOneWithoutTransacrionNestedInput
  }

  export type TransactionsUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isHold?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumTransactionTypeEnumFieldUpdateOperationsInput | $Enums.TransactionTypeEnum
    reason?: EnumTransactionReasonEnumFieldUpdateOperationsInput | $Enums.TransactionReasonEnum
    balanceType?: EnumBalanceTypeEnumFieldUpdateOperationsInput | $Enums.BalanceTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balanceId?: StringFieldUpdateOperationsInput | string
    withdrawal?: WithdrawalsUncheckedUpdateOneWithoutTransacrionNestedInput
  }

  export type PaymentsCreateWithoutMethodInput = {
    id?: string
    status?: $Enums.PaymentStatusEnum
    amount?: string
    exchangeRate?: string
    token: string
    linkPay?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutPaymentsInput
    currency: CurrencyCreateNestedOneWithoutPaymentsInput
    Subscription?: SubscriptionsCreateNestedOneWithoutPaymentsInput
    transacrion?: TransactionsCreateNestedOneWithoutPaymentInput
  }

  export type PaymentsUncheckedCreateWithoutMethodInput = {
    id?: string
    status?: $Enums.PaymentStatusEnum
    amount?: string
    exchangeRate?: string
    token: string
    linkPay?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    currencyKey: $Enums.CurrencyEnum
    SubscriptionId?: string | null
    transactionId?: string | null
  }

  export type PaymentsCreateOrConnectWithoutMethodInput = {
    where: PaymentsWhereUniqueInput
    create: XOR<PaymentsCreateWithoutMethodInput, PaymentsUncheckedCreateWithoutMethodInput>
  }

  export type PaymentsCreateManyMethodInputEnvelope = {
    data: PaymentsCreateManyMethodInput | PaymentsCreateManyMethodInput[]
    skipDuplicates?: boolean
  }

  export type CurrencyCreateWithoutPaymentMethodsInput = {
    key: $Enums.CurrencyEnum
    name: string
    symbol: string
    rate?: number
    coinmarketcapUCID?: string | null
    updatedAt?: Date | string
    payments?: PaymentsCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutPaymentMethodsInput = {
    key: $Enums.CurrencyEnum
    name: string
    symbol: string
    rate?: number
    coinmarketcapUCID?: string | null
    updatedAt?: Date | string
    payments?: PaymentsUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutPaymentMethodsInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutPaymentMethodsInput, CurrencyUncheckedCreateWithoutPaymentMethodsInput>
  }

  export type PaymentsUpsertWithWhereUniqueWithoutMethodInput = {
    where: PaymentsWhereUniqueInput
    update: XOR<PaymentsUpdateWithoutMethodInput, PaymentsUncheckedUpdateWithoutMethodInput>
    create: XOR<PaymentsCreateWithoutMethodInput, PaymentsUncheckedCreateWithoutMethodInput>
  }

  export type PaymentsUpdateWithWhereUniqueWithoutMethodInput = {
    where: PaymentsWhereUniqueInput
    data: XOR<PaymentsUpdateWithoutMethodInput, PaymentsUncheckedUpdateWithoutMethodInput>
  }

  export type PaymentsUpdateManyWithWhereWithoutMethodInput = {
    where: PaymentsScalarWhereInput
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyWithoutMethodInput>
  }

  export type CurrencyUpsertWithoutPaymentMethodsInput = {
    update: XOR<CurrencyUpdateWithoutPaymentMethodsInput, CurrencyUncheckedUpdateWithoutPaymentMethodsInput>
    create: XOR<CurrencyCreateWithoutPaymentMethodsInput, CurrencyUncheckedCreateWithoutPaymentMethodsInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutPaymentMethodsInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutPaymentMethodsInput, CurrencyUncheckedUpdateWithoutPaymentMethodsInput>
  }

  export type CurrencyUpdateWithoutPaymentMethodsInput = {
    key?: EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    coinmarketcapUCID?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentsUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateWithoutPaymentMethodsInput = {
    key?: EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    coinmarketcapUCID?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentsUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type PaymentsCreateManyUserInput = {
    id?: string
    status?: $Enums.PaymentStatusEnum
    amount?: string
    exchangeRate?: string
    token: string
    linkPay?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    currencyKey: $Enums.CurrencyEnum
    SubscriptionId?: string | null
    methodKey: $Enums.PaymentMethodEnum
    transactionId?: string | null
  }

  export type ReferralsCreateManyReferralInput = {
    id?: string
    level?: number
    inviterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralsCreateManyInviterInput = {
    id?: string
    level?: number
    referralId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionsCreateManyUserInput = {
    id?: string
    username: string
    isActive?: boolean
    isAutoRenewal?: boolean
    token: string
    period?: $Enums.SubscriptionPeriodEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    expiredAt?: Date | string | null
  }

  export type WithdrawalsCreateManyUserInput = {
    id?: string
    status?: $Enums.WithdrawalStatusEnum
    amountStars?: number
    amountUSD?: number
    amountTON?: number
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId: string
  }

  export type AdsViewsCreateManyUserInput = {
    id?: string
    networkKey?: $Enums.AdsNetworkEnum
    type?: $Enums.AdsViewTypeEnum
    createdAt?: Date | string
  }

  export type PaymentsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusEnumFieldUpdateOperationsInput | $Enums.PaymentStatusEnum
    amount?: StringFieldUpdateOperationsInput | string
    exchangeRate?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    linkPay?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: CurrencyUpdateOneRequiredWithoutPaymentsNestedInput
    Subscription?: SubscriptionsUpdateOneWithoutPaymentsNestedInput
    method?: PaymentMethodsUpdateOneRequiredWithoutPaymentsNestedInput
    transacrion?: TransactionsUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusEnumFieldUpdateOperationsInput | $Enums.PaymentStatusEnum
    amount?: StringFieldUpdateOperationsInput | string
    exchangeRate?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    linkPay?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currencyKey?: EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
    SubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    methodKey?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusEnumFieldUpdateOperationsInput | $Enums.PaymentStatusEnum
    amount?: StringFieldUpdateOperationsInput | string
    exchangeRate?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    linkPay?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currencyKey?: EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
    SubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    methodKey?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferralsUpdateWithoutReferralInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviter?: UsersUpdateOneRequiredWithoutInvitersNestedInput
  }

  export type ReferralsUncheckedUpdateWithoutReferralInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    inviterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralsUncheckedUpdateManyWithoutReferralInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    inviterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralsUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referral?: UsersUpdateOneRequiredWithoutReferralsNestedInput
  }

  export type ReferralsUncheckedUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    referralId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralsUncheckedUpdateManyWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    referralId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAutoRenewal?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    period?: EnumSubscriptionPeriodEnumFieldUpdateOperationsInput | $Enums.SubscriptionPeriodEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payments?: PaymentsUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAutoRenewal?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    period?: EnumSubscriptionPeriodEnumFieldUpdateOperationsInput | $Enums.SubscriptionPeriodEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payments?: PaymentsUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAutoRenewal?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    period?: EnumSubscriptionPeriodEnumFieldUpdateOperationsInput | $Enums.SubscriptionPeriodEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawalsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWithdrawalStatusEnumFieldUpdateOperationsInput | $Enums.WithdrawalStatusEnum
    amountStars?: FloatFieldUpdateOperationsInput | number
    amountUSD?: FloatFieldUpdateOperationsInput | number
    amountTON?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transacrion?: TransactionsUpdateOneRequiredWithoutWithdrawalNestedInput
  }

  export type WithdrawalsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWithdrawalStatusEnumFieldUpdateOperationsInput | $Enums.WithdrawalStatusEnum
    amountStars?: FloatFieldUpdateOperationsInput | number
    amountUSD?: FloatFieldUpdateOperationsInput | number
    amountTON?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: StringFieldUpdateOperationsInput | string
  }

  export type WithdrawalsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWithdrawalStatusEnumFieldUpdateOperationsInput | $Enums.WithdrawalStatusEnum
    amountStars?: FloatFieldUpdateOperationsInput | number
    amountUSD?: FloatFieldUpdateOperationsInput | number
    amountTON?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: StringFieldUpdateOperationsInput | string
  }

  export type AdsViewsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAdsViewTypeEnumFieldUpdateOperationsInput | $Enums.AdsViewTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    network?: AdsNetworksUpdateOneRequiredWithoutAdsViewsNestedInput
  }

  export type AdsViewsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    networkKey?: EnumAdsNetworkEnumFieldUpdateOperationsInput | $Enums.AdsNetworkEnum
    type?: EnumAdsViewTypeEnumFieldUpdateOperationsInput | $Enums.AdsViewTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdsViewsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    networkKey?: EnumAdsNetworkEnumFieldUpdateOperationsInput | $Enums.AdsNetworkEnum
    type?: EnumAdsViewTypeEnumFieldUpdateOperationsInput | $Enums.AdsViewTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdsViewsCreateManyNetworkInput = {
    id?: string
    type?: $Enums.AdsViewTypeEnum
    createdAt?: Date | string
    userId: string
  }

  export type AdsViewsUpdateWithoutNetworkInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAdsViewTypeEnumFieldUpdateOperationsInput | $Enums.AdsViewTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutAdsViewsNestedInput
  }

  export type AdsViewsUncheckedUpdateWithoutNetworkInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAdsViewTypeEnumFieldUpdateOperationsInput | $Enums.AdsViewTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AdsViewsUncheckedUpdateManyWithoutNetworkInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAdsViewTypeEnumFieldUpdateOperationsInput | $Enums.AdsViewTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionsCreateManyBalanceInput = {
    id?: string
    amount?: number
    isHold?: boolean
    type?: $Enums.TransactionTypeEnum
    reason?: $Enums.TransactionReasonEnum
    balanceType?: $Enums.BalanceTypeEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiredAt?: Date | string | null
  }

  export type TransactionsUpdateWithoutBalanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isHold?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumTransactionTypeEnumFieldUpdateOperationsInput | $Enums.TransactionTypeEnum
    reason?: EnumTransactionReasonEnumFieldUpdateOperationsInput | $Enums.TransactionReasonEnum
    balanceType?: EnumBalanceTypeEnumFieldUpdateOperationsInput | $Enums.BalanceTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawal?: WithdrawalsUpdateOneWithoutTransacrionNestedInput
    payment?: PaymentsUpdateOneWithoutTransacrionNestedInput
  }

  export type TransactionsUncheckedUpdateWithoutBalanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isHold?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumTransactionTypeEnumFieldUpdateOperationsInput | $Enums.TransactionTypeEnum
    reason?: EnumTransactionReasonEnumFieldUpdateOperationsInput | $Enums.TransactionReasonEnum
    balanceType?: EnumBalanceTypeEnumFieldUpdateOperationsInput | $Enums.BalanceTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawal?: WithdrawalsUncheckedUpdateOneWithoutTransacrionNestedInput
    payment?: PaymentsUncheckedUpdateOneWithoutTransacrionNestedInput
  }

  export type TransactionsUncheckedUpdateManyWithoutBalanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isHold?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumTransactionTypeEnumFieldUpdateOperationsInput | $Enums.TransactionTypeEnum
    reason?: EnumTransactionReasonEnumFieldUpdateOperationsInput | $Enums.TransactionReasonEnum
    balanceType?: EnumBalanceTypeEnumFieldUpdateOperationsInput | $Enums.BalanceTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentsCreateManySubscriptionInput = {
    id?: string
    status?: $Enums.PaymentStatusEnum
    amount?: string
    exchangeRate?: string
    token: string
    linkPay?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    currencyKey: $Enums.CurrencyEnum
    methodKey: $Enums.PaymentMethodEnum
    transactionId?: string | null
  }

  export type PaymentsUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusEnumFieldUpdateOperationsInput | $Enums.PaymentStatusEnum
    amount?: StringFieldUpdateOperationsInput | string
    exchangeRate?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    linkPay?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutPaymentsNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutPaymentsNestedInput
    method?: PaymentMethodsUpdateOneRequiredWithoutPaymentsNestedInput
    transacrion?: TransactionsUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentsUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusEnumFieldUpdateOperationsInput | $Enums.PaymentStatusEnum
    amount?: StringFieldUpdateOperationsInput | string
    exchangeRate?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    linkPay?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    currencyKey?: EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
    methodKey?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentsUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusEnumFieldUpdateOperationsInput | $Enums.PaymentStatusEnum
    amount?: StringFieldUpdateOperationsInput | string
    exchangeRate?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    linkPay?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    currencyKey?: EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
    methodKey?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsersCreateManyRoleInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    telegramDataId?: string | null
    balanceId?: string | null
    languageId: string
  }

  export type UsersUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payments?: PaymentsUpdateManyWithoutUserNestedInput
    referrals?: ReferralsUpdateManyWithoutReferralNestedInput
    inviters?: ReferralsUpdateManyWithoutInviterNestedInput
    telegramData?: UserTelegramDataUpdateOneWithoutUserNestedInput
    balance?: UserBalanceUpdateOneWithoutUserNestedInput
    language?: LanguageUpdateOneRequiredWithoutUsersNestedInput
    subscriptions?: SubscriptionsUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalsUpdateManyWithoutUserNestedInput
    adsViews?: AdsViewsUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    telegramDataId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceId?: NullableStringFieldUpdateOperationsInput | string | null
    languageId?: StringFieldUpdateOperationsInput | string
    payments?: PaymentsUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralsUncheckedUpdateManyWithoutReferralNestedInput
    inviters?: ReferralsUncheckedUpdateManyWithoutInviterNestedInput
    subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalsUncheckedUpdateManyWithoutUserNestedInput
    adsViews?: AdsViewsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    telegramDataId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceId?: NullableStringFieldUpdateOperationsInput | string | null
    languageId?: StringFieldUpdateOperationsInput | string
  }

  export type UsersCreateManyLanguageInput = {
    id?: string
    telegramId: string
    tonWallet?: string | null
    isFreePlanAvailable?: boolean
    isBanned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastStartedAt?: Date | string | null
    banExpiredAt?: Date | string | null
    deletedAt?: Date | string | null
    roleId?: $Enums.UserRoleEnum
    telegramDataId?: string | null
    balanceId?: string | null
  }

  export type UsersUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RolesUpdateOneRequiredWithoutUsersNestedInput
    payments?: PaymentsUpdateManyWithoutUserNestedInput
    referrals?: ReferralsUpdateManyWithoutReferralNestedInput
    inviters?: ReferralsUpdateManyWithoutInviterNestedInput
    telegramData?: UserTelegramDataUpdateOneWithoutUserNestedInput
    balance?: UserBalanceUpdateOneWithoutUserNestedInput
    subscriptions?: SubscriptionsUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalsUpdateManyWithoutUserNestedInput
    adsViews?: AdsViewsUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: EnumUserRoleEnumFieldUpdateOperationsInput | $Enums.UserRoleEnum
    telegramDataId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceId?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: PaymentsUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralsUncheckedUpdateManyWithoutReferralNestedInput
    inviters?: ReferralsUncheckedUpdateManyWithoutInviterNestedInput
    subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalsUncheckedUpdateManyWithoutUserNestedInput
    adsViews?: AdsViewsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateManyWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    tonWallet?: NullableStringFieldUpdateOperationsInput | string | null
    isFreePlanAvailable?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: EnumUserRoleEnumFieldUpdateOperationsInput | $Enums.UserRoleEnum
    telegramDataId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentsCreateManyCurrencyInput = {
    id?: string
    status?: $Enums.PaymentStatusEnum
    amount?: string
    exchangeRate?: string
    token: string
    linkPay?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    SubscriptionId?: string | null
    methodKey: $Enums.PaymentMethodEnum
    transactionId?: string | null
  }

  export type PaymentMethodsCreateManyCurrencyInput = {
    key: $Enums.PaymentMethodEnum
    name: string
    isActive?: boolean
    isTonBlockchain?: boolean
    tonSmartContractAddress?: string | null
    minAmount?: number
    maxAmount?: number
    commission?: number
    isPlusCommission?: boolean
    type?: $Enums.PaymentMethodTypeEnum
    system?: $Enums.PaymentSystemEnum
  }

  export type PaymentsUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusEnumFieldUpdateOperationsInput | $Enums.PaymentStatusEnum
    amount?: StringFieldUpdateOperationsInput | string
    exchangeRate?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    linkPay?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutPaymentsNestedInput
    Subscription?: SubscriptionsUpdateOneWithoutPaymentsNestedInput
    method?: PaymentMethodsUpdateOneRequiredWithoutPaymentsNestedInput
    transacrion?: TransactionsUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentsUncheckedUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusEnumFieldUpdateOperationsInput | $Enums.PaymentStatusEnum
    amount?: StringFieldUpdateOperationsInput | string
    exchangeRate?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    linkPay?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    SubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    methodKey?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentsUncheckedUpdateManyWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusEnumFieldUpdateOperationsInput | $Enums.PaymentStatusEnum
    amount?: StringFieldUpdateOperationsInput | string
    exchangeRate?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    linkPay?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    SubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    methodKey?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentMethodsUpdateWithoutCurrencyInput = {
    key?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTonBlockchain?: BoolFieldUpdateOperationsInput | boolean
    tonSmartContractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: FloatFieldUpdateOperationsInput | number
    maxAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    isPlusCommission?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumPaymentMethodTypeEnumFieldUpdateOperationsInput | $Enums.PaymentMethodTypeEnum
    system?: EnumPaymentSystemEnumFieldUpdateOperationsInput | $Enums.PaymentSystemEnum
    payments?: PaymentsUpdateManyWithoutMethodNestedInput
  }

  export type PaymentMethodsUncheckedUpdateWithoutCurrencyInput = {
    key?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTonBlockchain?: BoolFieldUpdateOperationsInput | boolean
    tonSmartContractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: FloatFieldUpdateOperationsInput | number
    maxAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    isPlusCommission?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumPaymentMethodTypeEnumFieldUpdateOperationsInput | $Enums.PaymentMethodTypeEnum
    system?: EnumPaymentSystemEnumFieldUpdateOperationsInput | $Enums.PaymentSystemEnum
    payments?: PaymentsUncheckedUpdateManyWithoutMethodNestedInput
  }

  export type PaymentMethodsUncheckedUpdateManyWithoutCurrencyInput = {
    key?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTonBlockchain?: BoolFieldUpdateOperationsInput | boolean
    tonSmartContractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: FloatFieldUpdateOperationsInput | number
    maxAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    isPlusCommission?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumPaymentMethodTypeEnumFieldUpdateOperationsInput | $Enums.PaymentMethodTypeEnum
    system?: EnumPaymentSystemEnumFieldUpdateOperationsInput | $Enums.PaymentSystemEnum
  }

  export type PaymentsCreateManyMethodInput = {
    id?: string
    status?: $Enums.PaymentStatusEnum
    amount?: string
    exchangeRate?: string
    token: string
    linkPay?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    currencyKey: $Enums.CurrencyEnum
    SubscriptionId?: string | null
    transactionId?: string | null
  }

  export type PaymentsUpdateWithoutMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusEnumFieldUpdateOperationsInput | $Enums.PaymentStatusEnum
    amount?: StringFieldUpdateOperationsInput | string
    exchangeRate?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    linkPay?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutPaymentsNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutPaymentsNestedInput
    Subscription?: SubscriptionsUpdateOneWithoutPaymentsNestedInput
    transacrion?: TransactionsUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentsUncheckedUpdateWithoutMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusEnumFieldUpdateOperationsInput | $Enums.PaymentStatusEnum
    amount?: StringFieldUpdateOperationsInput | string
    exchangeRate?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    linkPay?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    currencyKey?: EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
    SubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentsUncheckedUpdateManyWithoutMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusEnumFieldUpdateOperationsInput | $Enums.PaymentStatusEnum
    amount?: StringFieldUpdateOperationsInput | string
    exchangeRate?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    linkPay?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    currencyKey?: EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
    SubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}